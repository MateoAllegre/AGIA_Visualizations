{"version":3,"file":"babylonjs.serializers.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,cACR,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,wBAAyB,CAAC,aAAcJ,GACrB,iBAAZC,QACdA,QAAQ,yBAA2BD,EAAQG,QAAQ,cAEnDJ,EAAkB,YAAIC,EAAQD,EAAc,QAC7C,CATD,CASoB,oBAATO,KAAuBA,KAAyB,oBAAXC,OAAyBA,OAASC,MAAQC,G,kCCT1FP,EAAOD,QAAUQ,C,GCCbC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaZ,QAGrB,IAAIC,EAASQ,EAAyBE,GAAY,CAGjDX,QAAS,CAAC,GAOX,OAHAc,EAAoBH,GAAUV,EAAQA,EAAOD,QAASU,GAG/CT,EAAOD,OACf,CCrBAU,EAAoBK,EAAI,CAACf,EAASgB,KACjC,IAAI,IAAIC,KAAOD,EACXN,EAAoBQ,EAAEF,EAAYC,KAASP,EAAoBQ,EAAElB,EAASiB,IAC5EE,OAAOC,eAAepB,EAASiB,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EP,EAAoBa,EAAI,WACvB,GAA0B,iBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOjB,MAAQ,IAAIkB,SAAS,cAAb,EAChB,CAAE,MAAOC,GACR,GAAsB,iBAAXC,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxBjB,EAAoBQ,EAAI,CAACU,EAAKC,IAAUV,OAAOW,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFnB,EAAoBuB,EAAKjC,IACH,oBAAXkC,QAA0BA,OAAOC,aAC1ChB,OAAOC,eAAepB,EAASkC,OAAOC,YAAa,CAAEC,MAAO,WAE7DjB,OAAOC,eAAepB,EAAS,aAAc,CAAEoC,OAAO,K,i9ECMvD,0BA8LA,QArLkB,EAAAC,IAAd,SAAkBC,EAAgBC,EAAqBC,EAAqBC,GACxE,IAAMC,EAAmB,GACrBC,EAAI,EAEJC,EAAW,EAEXL,IACKC,IACDA,EAAa,OAEjBE,EAAOG,KAAK,UAAYL,EAAa,SAEzC,IAAK,IAAIM,EAAI,EAAGA,EAAIR,EAAOS,OAAQD,IAAK,CACpC,IAAME,EAAOV,EAAOQ,GACdG,EAAaD,EAAKE,MAAQ,cAAOJ,EAAC,KACxCJ,EAAOG,KAAK,YAAKI,IAGjB,IAAIE,EAAqC,KACzC,GAAIV,EAAgB,CAChB,IAAMW,EAAYJ,EAAKK,oBAAmB,GAC1CF,EAAmB,IAAI,EAAAG,OACvBF,EAAUG,YAAYJ,GAEtBH,EAAKQ,0BAA0BJ,EACnC,CAIA,GAAIb,EAAW,CACX,IAAMkB,EAAMT,EAAKU,SAEbD,GACAf,EAAOG,KAAK,UAAYY,EAAIE,GAEpC,CACA,IAAMpC,EAAwByB,EAAKY,SAEnC,GAAKrC,EAAL,CAKA,IAAMsC,EAAatC,EAAEuC,gBAAgB,YAC/BC,EAAexC,EAAEuC,gBAAgB,UACjCE,EAAUzC,EAAEuC,gBAAgB,MAC5BG,EAAa1C,EAAE2C,aACjBC,EAAW,EACXC,EAAkB,EAEtB,GAAKP,GAAeI,EAApB,CAQA,IAHA,IACMI,EADuB/B,EAAO,GAAGgC,WAAWC,qBACJ,GAAK,EAE1CC,EAAI,EAAGA,EAAIX,EAAWd,OAAQyB,GAAK,EACxC9B,EAAOG,KAAK,KAAOgB,EAAWW,GAAKH,EAAiB,IAAMR,EAAWW,EAAI,GAAK,IAAMX,EAAWW,EAAI,IACnGL,IAGJ,GAAoB,MAAhBJ,EACA,IAASS,EAAI,EAAGA,EAAIT,EAAahB,OAAQyB,GAAK,EAC1C9B,EAAOG,KAAK,MAAQkB,EAAaS,GAAKH,EAAiB,IAAMN,EAAaS,EAAI,GAAK,IAAMT,EAAaS,EAAI,IAGlH,GAAe,MAAXR,EACA,IAASQ,EAAI,EAAGA,EAAIR,EAAQjB,OAAQyB,GAAK,EACrC9B,EAAOG,KAAK,MAAQmB,EAAQQ,GAAK,IAAMR,EAAQQ,EAAI,IACnDJ,IAIR,IAAMK,EAAmB,CAAC,GAAI,GAAI,IAI5B,GAHWzB,EAAKU,UAAYV,EAAKsB,WAAWI,iBAEjBC,yBAAyB3B,KACX,EAAA4B,SAASC,yBAA2B,CAAC,EAAG,GAAK,CAAC,EAAG,GAAzFC,EAAO,KAAEC,EAAO,KAEvB,IAASP,EAAI,EAAGA,EAAIP,EAAWlB,OAAQyB,GAAK,EAAG,CAC3C,IAAMQ,EAAU,CAACC,OAAOhB,EAAWO,GAAK7B,GAAIsC,OAAOhB,EAAWO,EAAIM,GAAWnC,GAAIsC,OAAOhB,EAAWO,EAAIO,GAAWpC,IAC5GuC,EAAiB,CAACD,OAAOhB,EAAWO,GAAK5B,GAAWqC,OAAOhB,EAAWO,EAAIM,GAAWlC,GAAWqC,OAAOhB,EAAWO,EAAIO,GAAWnC,IAEjIuC,EAAgBH,EAChBI,EAAqB,MAAXpB,EAAkBkB,EAAiBT,EAC7CY,EAA8B,MAAhBtB,EAAuBiB,EAAUP,EAErD/B,EAAOG,KACH,KACIsC,EAAc,GACd,IACAC,EAAQ,GACR,IACAC,EAAY,GACZ,IACAF,EAAc,GACd,IACAC,EAAQ,GACR,IACAC,EAAY,GACZ,IACAF,EAAc,GACd,IACAC,EAAQ,GACR,IACAC,EAAY,GAExB,CAEI5C,GAAkBU,GAClBH,EAAKQ,0BAA0BL,GAEnCR,GAAKwB,EACLvB,GAAYwB,CA9DZ,MAFI,EAAAkB,MAAMC,KAAK,yDAVf,MAFI,EAAAD,MAAMC,KAAK,qCA6EnB,CAEA,OADqB7C,EAAO8C,KAAK,KAErC,EAQc,EAAAC,IAAd,SAAkBzC,GACd,IAAMN,EAAS,GACTgD,EAAsB1C,EAAKU,SAkDjC,OAjDAhB,EAAOG,KAAK,eACZH,EAAOG,KAAK,QAAU6C,EAAEC,cAAcC,QAAQ,IAC9ClD,EAAOG,KAAK,eACZH,EAAOG,KAAK,OAAS6C,EAAEG,MAAMD,QAAQ,IACrClD,EAAOG,KAAK,eACZH,EAAOG,KAAK,6BACZH,EAAOG,KAAK,aACZH,EAAOG,KAAK,QAAU6C,EAAEI,aAAa7D,EAAE2D,QAAQ,GAAK,IAAMF,EAAEI,aAAavE,EAAEqE,QAAQ,GAAK,IAAMF,EAAEI,aAAaC,EAAEH,QAAQ,IACvHlD,EAAOG,KAAK,QAAU6C,EAAEM,aAAa/D,EAAE2D,QAAQ,GAAK,IAAMF,EAAEM,aAAazE,EAAEqE,QAAQ,GAAK,IAAMF,EAAEM,aAAaD,EAAEH,QAAQ,IACvHlD,EAAOG,KAAK,QAAU6C,EAAEO,cAAchE,EAAE2D,QAAQ,GAAK,IAAMF,EAAEO,cAAc1E,EAAEqE,QAAQ,GAAK,IAAMF,EAAEO,cAAcF,EAAEH,QAAQ,IAC1HlD,EAAOG,KAAK,QAAU6C,EAAEQ,cAAcjE,EAAE2D,QAAQ,GAAK,IAAMF,EAAEQ,cAAc3E,EAAEqE,QAAQ,GAAK,IAAMF,EAAEQ,cAAcH,EAAEH,QAAQ,IAMtHF,EAAES,gBACFzD,EAAOG,KAAK,YAAwB6C,EAAES,eAAejD,MAGrDwC,EAAEU,gBACF1D,EAAOG,KAAK,YAAwB6C,EAAEU,eAAelD,MAIrDwC,EAAEW,iBACF3D,EAAOG,KAAK,YAAwB6C,EAAEW,gBAAgBnD,MActDwC,EAAEY,aACF5D,EAAOG,KAAK,yBAAqC6C,EAAEY,YAAYpD,MAG/DwC,EAAEa,gBACF7D,EAAOG,KAAK,WAAuB6C,EAAEa,eAAerD,MAG3CR,EAAO8C,KAAK,KAE7B,EACJ,EA9LA,GCTWgB,EAA2B,ECItC,0BAIoB,KAAAC,MAA+C,CAAC,CAmBpE,QAdI,sBAAW,wBAAS,C,IAApB,WACI,OAAOlG,KAAKkG,KAChB,E,gCAKO,YAAAC,cAAP,WACI,IAAK,IAAMzF,KAAOV,KAAKkG,MAAO,CAC1B,IAAMrE,EAAQ7B,KAAKkG,MAAMxF,GACnB0F,EAAO,IAAIC,KAAK,CAACxE,GAAQ,CAAEyE,MAAM,IAAAC,aAAY7F,KACnD,EAAAqE,MAAMyB,SAASJ,EAAM1F,EACzB,CACJ,EACJ,EAvBA,GCyBW+F,EAAW,WAQpB,OAPAA,EAAW7F,OAAO8F,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAG3C,EAAI,EAAG4C,EAAIC,UAAUtE,OAAQyB,EAAI4C,EAAG5C,IAE5C,IAAK,IAAI8C,KADTH,EAAIE,UAAU7C,GACOrD,OAAOW,UAAUC,eAAeC,KAAKmF,EAAGG,KAAIJ,EAAEI,GAAKH,EAAEG,IAE9E,OAAOJ,CACX,EACOF,EAASO,MAAMhH,KAAM8G,UAC9B,EA0EO,SAASG,EAAUC,EAASC,EAAYC,EAAGC,GAEhD,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAU5F,GAAS,IAAM6F,EAAKL,EAAUM,KAAK9F,GAAS,CAAE,MAAOV,GAAKqG,EAAOrG,EAAI,CAAE,CAC1F,SAASyG,EAAS/F,GAAS,IAAM6F,EAAKL,EAAiB,MAAExF,GAAS,CAAE,MAAOV,GAAKqG,EAAOrG,EAAI,CAAE,CAC7F,SAASuG,EAAKG,GAJlB,IAAehG,EAIagG,EAAOC,KAAOP,EAAQM,EAAOhG,QAJ1CA,EAIyDgG,EAAOhG,MAJhDA,aAAiBuF,EAAIvF,EAAQ,IAAIuF,GAAE,SAAUG,GAAWA,EAAQ1F,EAAQ,KAIjBkG,KAAKN,EAAWG,EAAW,CAC7GF,GAAML,EAAYA,EAAUL,MAAME,EAASC,GAAc,KAAKQ,OAClE,GACF,CAEO,SAASK,EAAYd,EAASe,GACnC,IAAsGC,EAAGC,EAAGxB,EAAxGyB,EAAI,CAAEC,MAAO,EAAGC,KAAM,WAAa,GAAW,EAAP3B,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,EAAI,EAAG4B,KAAM,GAAIC,IAAK,IAAexH,EAAIJ,OAAO6H,QAA4B,mBAAbC,SAA0BA,SAAW9H,QAAQW,WACtL,OAAOP,EAAE2G,KAAOgB,EAAK,GAAI3H,EAAS,MAAI2H,EAAK,GAAI3H,EAAU,OAAI2H,EAAK,GAAsB,mBAAXhH,SAA0BX,EAAEW,OAAOiH,UAAY,WAAa,OAAO5I,IAAM,GAAIgB,EAC1J,SAAS2H,EAAK9B,GAAK,OAAO,SAAUzE,GAAK,OACzC,SAAcyG,GACV,GAAIX,EAAG,MAAM,IAAIY,UAAU,mCAC3B,KAAO9H,IAAMA,EAAI,EAAG6H,EAAG,KAAOT,EAAI,IAAKA,OACnC,GAAIF,EAAI,EAAGC,IAAMxB,EAAY,EAARkC,EAAG,GAASV,EAAU,OAAIU,EAAG,GAAKV,EAAS,SAAOxB,EAAIwB,EAAU,SAAMxB,EAAElF,KAAK0G,GAAI,GAAKA,EAAER,SAAWhB,EAAIA,EAAElF,KAAK0G,EAAGU,EAAG,KAAKf,KAAM,OAAOnB,EAE3J,OADIwB,EAAI,EAAGxB,IAAGkC,EAAK,CAAS,EAARA,EAAG,GAAQlC,EAAE9E,QACzBgH,EAAG,IACP,KAAK,EAAG,KAAK,EAAGlC,EAAIkC,EAAI,MACxB,KAAK,EAAc,OAAXT,EAAEC,QAAgB,CAAExG,MAAOgH,EAAG,GAAIf,MAAM,GAChD,KAAK,EAAGM,EAAEC,QAASF,EAAIU,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKT,EAAEI,IAAIO,MAAOX,EAAEG,KAAKQ,MAAO,SACxC,QACI,MAAkBpC,GAAZA,EAAIyB,EAAEG,MAAY/F,OAAS,GAAKmE,EAAEA,EAAEnE,OAAS,KAAkB,IAAVqG,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAET,EAAI,EAAG,QAAU,CAC3G,GAAc,IAAVS,EAAG,MAAclC,GAAMkC,EAAG,GAAKlC,EAAE,IAAMkC,EAAG,GAAKlC,EAAE,IAAM,CAAEyB,EAAEC,MAAQQ,EAAG,GAAI,KAAO,CACrF,GAAc,IAAVA,EAAG,IAAYT,EAAEC,MAAQ1B,EAAE,GAAI,CAAEyB,EAAEC,MAAQ1B,EAAE,GAAIA,EAAIkC,EAAI,KAAO,CACpE,GAAIlC,GAAKyB,EAAEC,MAAQ1B,EAAE,GAAI,CAAEyB,EAAEC,MAAQ1B,EAAE,GAAIyB,EAAEI,IAAIlG,KAAKuG,GAAK,KAAO,CAC9DlC,EAAE,IAAIyB,EAAEI,IAAIO,MAChBX,EAAEG,KAAKQ,MAAO,SAEtBF,EAAKZ,EAAKxG,KAAKyF,EAASkB,EAC5B,CAAE,MAAOjH,GAAK0H,EAAK,CAAC,EAAG1H,GAAIgH,EAAI,CAAG,CAAE,QAAUD,EAAIvB,EAAI,CAAG,CACzD,GAAY,EAARkC,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAEhH,MAAOgH,EAAG,GAAKA,EAAG,QAAK,EAAQf,MAAM,EAC9E,CAtBgDJ,CAAK,CAACb,EAAGzE,GAAK,CAAG,CAuBnE,CA+DO,SAAS4G,EAAcC,EAAIC,EAAMC,GACtC,GAAIA,GAA6B,IAArBrC,UAAUtE,OAAc,IAAK,IAA4B4G,EAAxBnF,EAAI,EAAGoF,EAAIH,EAAK1G,OAAYyB,EAAIoF,EAAGpF,KACxEmF,GAAQnF,KAAKiF,IACRE,IAAIA,EAAKE,MAAM/H,UAAUgI,MAAM9H,KAAKyH,EAAM,EAAGjF,IAClDmF,EAAGnF,GAAKiF,EAAKjF,IAGrB,OAAOgF,EAAGO,OAAOJ,GAAME,MAAM/H,UAAUgI,MAAM9H,KAAKyH,GACpD,CArE6BtI,OAAO6H,OA2GX7H,OAAO6H,OAoEkB,mBAApBgB,iBAAiCA,gBC1S/D,IAAMC,EAAU,KACVC,EAAqB,IAAI,EAAAC,OAAO,IAAM,IAAM,KAC5CC,EAAmB,KACnBC,EAAQ,EAAAF,OAAOE,QACfC,EAAQ,EAAAH,OAAOG,QA2CrB,SAAeC,EAAoBC,G,sGAE/B,OADMC,EAAkBD,EAAeE,uBACY,IAA3BD,EAAgBE,OAGpCF,EAAgBG,QACT,CAAP,EAAO,OAGLC,EAASJ,EAAgBK,QAG3BC,EAAYP,EAA2BO,SAEtCF,EAAD,MACO,GAAM,EAAAvF,MAAM0F,cAAcP,EAAgBQ,OAZ1C,CAAP,EAAO,M,cAYPC,EAAO,SACPH,GAAW,IAAAjE,aAAY2D,EAAgBQ,MAAQF,E,qBACxCI,YAAYC,OAAOP,IAC1BK,EAAOL,EAAOA,OAAOf,MAAMe,EAAOQ,WAAYR,EAAOQ,WAAaR,EAAOS,Y,QADlE,M,cAEAT,aAAkBM,aACzBD,EAAOL,E,QADA,M,cAEAA,aAAkBjE,KAClB,GAAMiE,EAAOU,eADb,M,cACPL,EAAO,SACPH,EAAWF,EAAOhE,MAAQkE,E,oBACD,iBAAXF,EAAP,MACA,GAAM,EAAAvF,MAAM0F,cAAcH,I,cAAjCK,EAAO,SACPH,GAAW,IAAAjE,aAAY+D,IAAWE,E,oBACC,oBAArBS,kBAAoCX,aAAkBW,iBAC7D,GAAM,EAAAlG,MAAM0F,cAAcH,EAAOY,MADjC,O,OACPP,EAAO,SACPH,GAAW,IAAAjE,aAAY+D,EAAOY,MAAQV,E,mBAG1C,OAAIG,GAAQH,EACD,CAAP,EAAO,CAAEG,KAAI,EAAEH,SAAQ,IAGpB,CAAP,EAAO,M,OAWJ,SAASW,EAAeC,EAAiBC,EAAkBC,GAC9D,GAAID,EAAW1B,EAAmBjI,EAE9B,OAAO,EAGX,IAAM6J,EAAI5B,EAAmBjI,EACvB8D,EAAK4F,EAAUE,GAA6B,EAAM3B,EAAmBjI,GAAK2J,EAAW,EAAM1B,EAAmBjI,EAE9GlB,EAAIgF,EAAIA,EAAI,EAAM+F,GADd5B,EAAmBjI,EAAI2J,GAEjC,OAAO,EAAAG,OAAOC,QAAQjG,EAAIkG,KAAKC,KAAKnL,KAAO,EAAM+K,GAAI,EAAG,EAC5D,CAMO,SAASK,EAAmCC,GAC/C,IAAMT,EAAUS,EAAwBpG,aAAaqG,cAAcD,EAAwB9H,WAAWgI,YAAYC,yBAAyBC,MAAM,IAC3IC,EAAUL,EAAwBvG,MAClCF,EAAgB,EAAAoG,OAAOC,MAAMI,EAAwBzG,cAAe,EAAGyE,GAEvEsC,GAAY,IAAAC,0BAAyBhH,GAQ3C,MANgE,CAC5DiH,gBAAiB,CAACjB,EAAQ1J,EAAG0J,EAAQpK,EAAGoK,EAAQ5F,EAAG0G,GACnDI,eAAgB,EAChBC,gBAAiBJ,EAIzB,CAOA,SAASK,EAAaC,EAAyBC,GACvCA,EAAgBC,oBAChBF,EAAaG,UAAY,QAClBF,EAAgBG,qBACvBJ,EAAaG,UAAY,OACzBH,EAAaK,YAAcJ,EAAgBK,YAEnD,CAEA,SAASC,EAAmBC,EAAeC,EAAgBC,GAGvD,IAFA,IAAMxC,EAAO,IAAIyC,WAAWH,EAAQC,EAAS,GAEpCjJ,EAAI,EAAGA,EAAI0G,EAAKnI,OAAQyB,GAAQ,EACrC0G,EAAK1G,GAAK0G,EAAK1G,EAAI,GAAK0G,EAAK1G,EAAI,GAAK0G,EAAK1G,EAAI,GAAK,IAKxD,OAFmB,EAAAoJ,WAAWC,kBAAkB3C,EAAMsC,EAAOC,EAAQC,EAGzE,CAEA,SAASI,EAA2BC,GAChC,GAAIA,aAAkBJ,WAAY,CAG9B,IAFA,IAAM,EAASI,EAAOhL,OAChB8H,EAAS,IAAImD,aAAaD,EAAOhL,QAC9ByB,EAAI,EAAGA,EAAI,IAAUA,EAC1BqG,EAAOrG,GAAKuJ,EAAOvJ,GAAK,IAE5B,OAAOqG,CACX,CAAO,GAAIkD,aAAkBC,aACzB,OAAOD,EAEP,MAAM,IAAIE,MAAM,4BAExB,CAMA,iBAOI,WAA6BC,GAAA,KAAAA,UAAAA,EALrB,KAAAC,YAAc,IAAIC,IAGlB,KAAAC,wBAA2F,CAAC,CAE7C,CA4yB3D,OA1yBW,YAAAC,eAAP,SAAsB9D,G,MAClB,OAAOA,GAAsD,QAApC,EAAAjK,KAAK4N,YAAY7M,IAAIkJ,UAAe,QAAY,IAC7E,EAEa,YAAA+D,4BAAb,SAAyCnC,EAA2CoC,G,qHAC1EC,EAAuBtC,EAAmCC,GAE1D1I,EAAsB,CAAER,KAAMkJ,EAAwBlJ,MACb,MAA3CkJ,EAAwBsC,iBAA4BtC,EAAwBsC,kBACvEtC,EAAwBuC,kBACzB,EAAArJ,MAAMC,KAAK6G,EAAwBlJ,KAAO,0FAE9CQ,EAASkL,aAAc,GAGvBJ,GACMK,EAA4B,IAE5BzI,EAAiBgG,EAAwBhG,iBAE3CyI,EAAShM,KACLtC,KAAKuO,mBAAmB1I,GAAgBkC,MAAK,SAACyG,GACtCA,IACAN,EAAqBO,iBAAmBD,EAEhD,MAIF,EAAc3C,EAAwB9F,cAExCuI,EAAShM,KACLtC,KAAKuO,mBAAmB,GAAaxG,MAAK,SAACyG,GACnCA,IACArL,EAASuL,cAAgBF,EACC,IAAtB,EAAYG,QACZxL,EAASuL,cAAczC,MAAQ,EAAY0C,OAGvD,MAIFC,EAAkB/C,EAAwB+C,mBAE5CzL,EAAS0L,eAAiB,CAAC,EAAK,EAAK,GAErCP,EAAShM,KACLtC,KAAKuO,mBAAmBK,GAAiB7G,MAAK,SAACyG,GACvCA,IACArL,EAASyL,gBAAkBJ,EAEnC,OAIF5I,EAAiBiG,EAAwBjG,iBAE3C0I,EAAShM,KACLtC,KAAKuO,mBAAmB3I,GAAgBmC,MAAK,SAACyG,GAC1C,GAAIA,EAAa,CACb,IAAMM,EAAkD,CACpDC,MAAOP,EAAYO,OAEvB5L,EAAS2L,iBAAmBA,CAChC,CACJ,KAIJR,EAAS9L,OAAS,GAClBxC,KAAK2N,UAAUqB,qBAAqBC,IAAIpD,GACxC,GAAMvE,QAAQ4H,IAAIZ,KAFlB,OAvDJ,M,OAyDI,S,iBAmBR,OAfIzC,EAAwBvG,MAAQ,GAAOuG,EAAwB7F,kBAC3D6F,EAAwBe,YAAc,EAAAuC,UAAUC,cAChDjM,EAASyJ,UAAY,QAErB,EAAA7H,MAAMC,KAAK6G,EAAwBlJ,KAAO,2CAA6CkJ,EAAwBe,UAAUyC,aAI7HxD,EAAwBlG,gBAAkBkG,EAAwBlG,cAAc2J,kBAAkBvF,EAAOL,KACzGvG,EAAS0L,eAAiBhD,EAAwBlG,cAAc4J,WAGpEpM,EAAS+K,qBAAuBA,EAChC1B,EAAarJ,EAAU0I,GAEvB,GAAM7L,KAAKwP,qBAAqBrM,EAAU0I,I,OAI1C,OAJA,UAEM7J,EAAYhC,KAAK2N,UAAU8B,YACvBnN,KAAKa,GACR,CAAP,EAAOnB,EAAUQ,OAAS,G,QAGhB,YAAAgN,qBAAd,SAAmC/C,EAAyBC,G,wGAKxD,IAJMgD,EAAW1P,KAAK2N,UAAUgC,gDAAgD,iBAAkBlD,EAAcC,GAE1G4B,EAAmD,GAEpD,EAAL,EAAsB,EAAAoB,EAAA,eAAXE,EAAO,KACdtB,EAAShM,KAAKtC,KAAKuO,mBAAmBqB,IAG1C,SAAMtI,QAAQ4H,IAAIZ,I,OAElB,OAFA,SAEA,GAAMtO,KAAK2N,UAAUkC,mCAAmC,iBAAkBpD,EAAcC,I,cAAxF,S,YAGU,YAAAoD,mBAAd,SAAiCxF,EAAoB2C,EAAeC,EAAgB1C,G,0FACzE,SAAM,EAAAuF,UAAUC,cAAc/C,EAAOC,EAAQ5C,EAAQE,OAAUlK,GAAW,GAAO,I,OAAxF,MAAO,CAAP,EAAO,U,QAUH,YAAA2P,gCAAR,SAAwCC,EAAiCC,EAAiChD,GACtG,IAEIiD,EACAC,EAHEC,EAAeJ,EAAWA,EAASK,UAAY,CAAEtD,MAAO,EAAGC,OAAQ,GACnEsD,EAAeL,EAAWA,EAASI,UAAY,CAAEtD,MAAO,EAAGC,OAAQ,GAuBzE,OAnBIoD,EAAarD,MAAQuD,EAAavD,OAE9BmD,EADAF,GAAYA,aAAoB,EAAAO,QACd,EAAAC,aAAaC,kBAAkBT,EAAUM,EAAavD,MAAOuD,EAAatD,QAAQ,GAElFF,EAAmBwD,EAAavD,MAAOuD,EAAatD,OAAQC,GAElFkD,EAAkBF,GACXG,EAAarD,MAAQuD,EAAavD,OAErCoD,EADAF,GAAYA,aAAoB,EAAAM,QACd,EAAAC,aAAaC,kBAAkBR,EAAUG,EAAarD,MAAOqD,EAAapD,QAAQ,GAElFF,EAAmBsD,EAAarD,MAAOqD,EAAapD,OAAQC,GAElFiD,EAAkBF,IAElBE,EAAkBF,EAClBG,EAAkBF,GAGf,CACHD,SAAUE,EACVD,SAAUE,EAElB,EAYc,YAAAO,2DAAd,SACI/K,EACAgL,EACAC,EACAtG,G,mKAEM8D,EAAW,IAAIhF,MACfzD,GAAkBgL,EAApB,MACO,GAAMvJ,QAAQE,OAAO,8D,qCA0I5B,MAAO,CAAP,EAAO,U,cAvIL2F,EAAyBtH,EAAiBA,EAAe9B,WAAa8M,EAA4BA,EAA0B9M,WAAa,OAErIgN,EAAkB/Q,KAAKiQ,gCAAgCpK,EAAgBgL,EAA2B1D,GAElG6D,EAAsC,QAAxB,EAAAD,EAAgBb,gBAAQ,eAAEK,UAE1CU,OAAa,EACbC,OAAwB,EAEtBjE,EAAQ+D,EAAY/D,MACpBC,EAAS8D,EAAY9D,OAEL,GAAM6D,EAAgBb,SAASiB,eAXrD,O,OAYuB,OADjBC,EAAgB,SACC,GAAML,EAAgBZ,SAASgB,c,cAAhDE,EAAiB,SAEnBD,GACAH,EAAgB1D,EAA2B6D,G,OAD3C,M,OAGO,SAAM9J,QAAQE,OAAO,oD,cAE5B6J,GACAH,EAA2B3D,EAA2B8D,G,QADtD,M,OAGO,SAAM/J,QAAQE,OAAO,gE,QAahC,IAVMuD,EAAamG,EAAyBnG,WAEtCuG,EAA0B,IAAIlE,WAAWrC,GACzCwG,EAAkB,IAAInE,WAAWrC,GAGjCyG,EAAezH,EACjB0H,EAAc,EACdC,EAAe,EAEVC,EAAI,EAAGA,EAAIzE,IAAUyE,EAC1B,IAASC,EAAI,EAAGA,EAAI3E,IAAS2E,EACnBC,EAPK,GAOK5E,EAAQ0E,EAAIC,GAEtBnM,EAAe,IAAI,EAAAmE,OAAOqH,EAAcY,GAASZ,EAAcY,EAAS,GAAIZ,EAAcY,EAAS,IACpG/F,cAAcqB,EAAMpB,YAAYC,yBAChC8F,SAAShB,EAAQrL,cAChBC,EAAgB,IAAI,EAAAkE,OAAOsH,EAAyBW,GAASX,EAAyBW,EAAS,GAAIX,EAAyBW,EAAS,IACtI/F,cAAcqB,EAAMpB,YAAYC,yBAChC8F,SAAShB,EAAQpL,eAChBqM,EAAab,EAAyBW,EAAS,GAAKf,EAAQiB,WAE5DC,EAA6C,CAC/CvM,aAAcA,EACdC,cAAeA,EACfqM,WAAYA,GAGVE,EAAoBjS,KAAKkS,8CAA8CF,GAC7ER,EAAa9P,EAAIgK,KAAKyG,IAAIX,EAAa9P,EAAGuQ,EAAkBG,UAAU1Q,GACtE8P,EAAaxQ,EAAI0K,KAAKyG,IAAIX,EAAaxQ,EAAGiR,EAAkBG,UAAUpR,GACtEwQ,EAAahM,EAAIkG,KAAKyG,IAAIX,EAAahM,EAAGyM,EAAkBG,UAAU5M,GACtEiM,EAAc/F,KAAKyG,IAAIV,EAAaQ,EAAkBI,UACtDX,EAAehG,KAAKyG,IAAIT,EAAcO,EAAkB9F,WAExDoF,EAAgBM,GAA0C,IAAhCI,EAAkBG,UAAU1Q,EACtD6P,EAAgBM,EAAS,GAAqC,IAAhCI,EAAkBG,UAAUpR,EAC1DuQ,EAAgBM,EAAS,GAAqC,IAAhCI,EAAkBG,UAAU5M,EAC1D+L,EAAgBM,EAAS,GAAKd,EAAgBb,SAASoC,SAAuC,IAA5BrB,EAAcY,EAAS,GAAW,IAEpGP,EAAwBO,GAAU,EAClCP,EAAwBO,EAAS,GAAoC,IAA/BI,EAAkB9F,UACxDmF,EAAwBO,EAAS,GAAmC,IAA9BI,EAAkBI,SACxDf,EAAwBO,EAAS,GAAK,IAc9C,IATM,EAAkD,CACpDO,UAAWZ,EACXa,SAAUZ,EACVtF,UAAWuF,GAGXa,GAAmC,EACnCC,GAA2B,EAEtBb,EAAI,EAAGA,EAAIzE,IAAUyE,EAC1B,IAASC,EAAI,EAAGA,EAAI3E,IAAS2E,EAGzBL,EAFMkB,EAtDK,GAsDgBxF,EAAQ0E,EAAIC,KAED,EAAyBQ,UAAU1Q,EAAIgI,EAAU,EAAyB0I,UAAU1Q,EAAI,EAC9H6P,EAAgBkB,EAAoB,IAAM,EAAyBL,UAAUpR,EAAI0I,EAAU,EAAyB0I,UAAUpR,EAAI,EAClIuQ,EAAgBkB,EAAoB,IAAM,EAAyBL,UAAU5M,EAAIkE,EAAU,EAAyB0I,UAAU5M,EAAI,EAE5HkN,EAAuB,EAAA9I,OAAO+I,SAChCpB,EAAgBkB,GAChBlB,EAAgBkB,EAAoB,GACpClB,EAAgBkB,EAAoB,IAElCG,EAAqBF,EAAqBG,aAAa1F,EAAMpB,YAAYC,yBAC/EuF,EAAgBkB,GAA4C,IAAvBG,EAAmBlR,EACxD6P,EAAgBkB,EAAoB,GAA4B,IAAvBG,EAAmB5R,EAC5DuQ,EAAgBkB,EAAoB,GAA4B,IAAvBG,EAAmBpN,EAEvDoN,EAAmBtD,kBAAkBxF,EAAOJ,KAC7C8I,GAA2B,GAG/BlB,EAAwBmB,EAAoB,IAAM,EAAyBtG,UAAazC,EAAU,EAAyByC,UAAa,EACxImF,EAAwBmB,EAAoB,IAAM,EAAyBJ,SAAY3I,EAAU,EAAyB2I,SAAY,EAEvG,EAAAzI,OAAO+I,SAAS,IAAKrB,EAAwBmB,EAAoB,GAAInB,EAAwBmB,EAAoB,IAEpHnD,kBAAkBxF,EAAOJ,KACjD6I,GAAmC,GAoBxC,OAfHA,GACAjE,EAAShM,KACLtC,KAAK8P,mBAAmBwB,EAAyBrE,EAAOC,EAAQ1C,GAAUzC,MAAK,SAAC4C,GAC5E,EAAyBmI,6BAA+BnI,CAC5D,KAGJ6H,GACAlE,EAAShM,KACLtC,KAAK8P,mBAAmByB,EAAiBtE,EAAOC,EAAQ1C,GAAUzC,MAAK,SAAC4C,GACpE,EAAyBoI,qBAAuBpI,CACpD,KAID,GAAMrD,QAAQ4H,IAAIZ,GAAUvG,MAAK,WACpC,OAAO,CACX,K,QAEO,SAAMT,QAAQE,OAAO,2F,QAS5B,YAAA0K,8CAAR,SAAsDF,GAClD,IAAMgB,EAA6BhT,KAAKiT,wBAAwBjB,EAAmBvM,cAC7EyN,EAA8BlT,KAAKiT,wBAAwBjB,EAAmBtM,eAC9E4F,EAA2B,EAAItL,KAAKmT,iBAAiBnB,EAAmBtM,eACxE2M,EAAWlH,EAAe6H,EAA4BE,EAA6B5H,GACnF8H,EAAuBpB,EAAmBvM,aAAawG,MAAMX,GAA4B,EAAM3B,EAAmBjI,GAAKgK,KAAKyG,IAAI,EAAIE,IACpIgB,EAAwBrB,EAAmBtM,cAAc4N,SAAS3J,EAAmBsC,MAAM,EAAIoG,IAAWpG,MAAM,EAAIP,KAAKyG,IAAIE,IAC/HD,EAAY,EAAAxI,OAAO2J,KAAKH,EAAsBC,EAAuBhB,EAAWA,GASpF,MANiD,CAC7CD,UAHJA,EAAYA,EAAUoB,WAAW,EAAG,EAAGpB,GAInCC,SAAUA,EACVlG,UAAW,EAAI6F,EAAmBD,WAI1C,EAOQ,YAAAkB,wBAAR,SAAgCQ,GAC5B,OAAIA,EACO/H,KAAKC,KAAK,KAAQ8H,EAAM/R,EAAI+R,EAAM/R,EAAI,KAAQ+R,EAAMzS,EAAIyS,EAAMzS,EAAI,KAAQyS,EAAMjO,EAAIiO,EAAMjO,GAE9F,CACX,EAOQ,YAAA2N,iBAAR,SAAyBM,GACrB,OAAIA,EACO/H,KAAKyG,IAAIsB,EAAM/R,EAAGgK,KAAKyG,IAAIsB,EAAMzS,EAAGyS,EAAMjO,IAE9C,CACX,EASc,YAAAkO,kDAAd,SACIC,EACAC,EACA3F,G,6GAEMK,EAA4B,GAE5B2D,EAA2C,CAC7CG,UAAWuB,EAAmBE,aAC9BxB,SAAUsB,EAAmBG,UAC7B3H,UAAWwH,EAAmBI,YAG9B9F,KACM+F,EAAgBL,EAAmBM,iBAErC3F,EAAShM,KACLtC,KAAKuO,mBAAmByF,GAAejM,MAAK,SAACmM,GACrCA,IACAN,EAAyBnF,iBAAmByF,EAEpD,MAGFC,EAAkBR,EAAmBS,mBAEvC9F,EAAShM,KACLtC,KAAKuO,mBAAmB4F,GAAiBpM,MAAK,SAACmM,GACvCA,IACAN,EAAyBS,yBAA2BH,EAE5D,MAKR5F,EAAS9L,OAAS,GAClBxC,KAAK2N,UAAUqB,qBAAqBC,IAAI0E,GACxC,GAAMrM,QAAQ4H,IAAIZ,KAFlB,M,OAEA,S,iBAGJ,MAAO,CAAP,EAAO2D,G,QAGH,YAAAqC,mBAAR,SAA2B1E,GACvB,IAAM2E,EAAoB,CAAC,EAC3B,KAAK3E,GAAaA,aAAmB,EAAAa,SACjC,OAAO8D,EAGX,IAAMC,EAAQxU,KAAKyU,wBAAwB7E,EAAQ8E,OACrC,QAAVF,IACAD,EAAQC,MAAQA,GAGpB,IAAMG,EAAQ3U,KAAKyU,wBAAwB7E,EAAQgF,OAKnD,OAJc,QAAVD,IACAJ,EAAQI,MAAQA,GAGZ/E,EAAQiF,cACZ,KAAK,EAAApE,QAAQqE,cACTP,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQwE,eACTV,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQyE,eACTX,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQ0E,yBACTZ,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQ2E,gBACTb,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQ4E,0BACTd,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQ6E,0BACTf,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQ8E,yBACThB,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQ+E,0BACTjB,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQgF,wBACTlB,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQiF,yBACTnB,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KACpB,MAEJ,KAAK,EAAAvE,QAAQkF,2BACTpB,EAAQQ,UAAY,KACpBR,EAAQS,UAAY,KAK5B,OAAOT,CACX,EAEQ,YAAAE,wBAAR,SAAgCmB,GAC5B,OAAQA,GACJ,KAAK,EAAAnF,QAAQoF,iBACT,OAAO,MAEX,KAAK,EAAApF,QAAQqF,kBACT,OAAO,MAEX,KAAK,EAAArF,QAAQsF,mBACT,OAAO,MAEX,QAEI,OADA,EAAAhR,MAAM2I,MAAM,wCAAiCkI,EAAQ,MAC9C,MAGnB,EASc,YAAAI,iDAAd,SACIrC,EACAzF,EACAD,G,uHAEMzD,EAAW,YACXyL,EAAoC,CACtCxQ,aAAckO,EAAmBE,aACjCnO,cAAeiO,EAAmBuC,mBAClCnE,WAAY4B,EAAmBwC,eAG7BnC,EAAgBL,EAAmBM,eACnCmC,EAAsBzC,EAAmB0C,qBACzCC,EAA0C3C,EAAmB4C,0CAC/DH,GAAwBE,EAAxB,MACO,GAAMhP,QAAQE,OAAO,gH,OAA5B,MAAO,CAAP,EAAO,U,cAGNwM,GAAiBoC,IAAwBnI,GAC1CjO,KAAK2N,UAAUqB,qBAAqBC,IAAI0E,GAElC6C,EAAexW,KAAKyW,sBAAsBzC,GAAiBoC,GAChC,GAAMpW,KAAK4Q,2DAA2DoD,EAAeoC,EAAqBH,EAAWzL,KAJtJ,M,OAkBA,OAdMkM,EAA2B,SAE3BhH,EAAW1P,KAAK2N,UAAUgJ,UAE5BD,EAAyB3D,uBACnB6D,EAAa5W,KAAK6W,aAAa,mBAAYnH,EAASlN,QAAUgI,EAAUkM,EAAyB3D,sBACvG7E,EAAqBO,iBAAmBzO,KAAK8W,mBAAmBF,EAAYJ,EAAcxC,aAAa,EAAbA,EAAe+C,mBAGzGL,EAAyB5D,+BACnB8D,EAAa5W,KAAK6W,aAAa,2BAAoBnH,EAASlN,QAAUgI,EAAUkM,EAAyB5D,8BAC/G5E,EAAqBmG,yBAA2BrU,KAAK8W,mBAAmBF,EAAYJ,EAAcJ,aAAmB,EAAnBA,EAAqBW,mBAGpH,CAAP,EAAOL,G,OAEP,MAAO,CAAP,EAAO1W,KAAKkS,8CAA8C+D,I,QAIrD,YAAAe,uBAAb,SAAoCrD,EAAqC1F,G,qHAC/D2F,EAA0D,CAAC,EAE3DnH,EAA0B,CAC5B9J,KAAMgR,EAAmBhR,OAGvBsU,EAAuBtD,EAAmBuD,wBAGtCC,EAAcxD,EAAmBE,aACjCvO,EAAQqO,EAAmBrO,MAC7B6R,IACAvD,EAAyBvH,gBAAkB,CAAC8K,EAAYzV,EAAGyV,EAAYnW,EAAGmW,EAAY3R,EAAGF,KAIvE2R,EACpB,GAAMjX,KAAK0T,kDAAkDC,EAAoBC,EAA0B3F,IADvF,M,cACpB,W,aACA,SAAMjO,KAAKgW,iDAAiDrC,EAAoBC,EAA0B3F,I,OAA1G,W,iBAEN,OAJMgE,EAAoB,EAI1B,GAAMjS,KAAKoX,sCAAsCnF,EAAmB0B,EAAoBlH,EAAcmH,EAA0B3F,I,OAChI,OADA,SACA,GAAMjO,KAAKwP,qBAAqB/C,EAAckH,I,OAI9C,OAJA,UAEM3R,EAAYhC,KAAK2N,UAAU8B,YACvBnN,KAAKmK,GACR,CAAP,EAAOzK,EAAUQ,OAAS,G,QAGhB,YAAA4U,sCAAd,SACInF,EACA0B,EACAlH,EACAmH,EACA3F,G,+GAEAzB,EAAaC,EAAckH,GAEtB1B,EAAkBG,UAAU9C,kBAAkBxF,EAAOJ,IAAa,EAAA8B,OAAO6L,cAAc1D,EAAmBrO,MAAO,EAAGoE,KACrHkK,EAAyBvH,gBAAkB,CAAC4F,EAAkBG,UAAU1Q,EAAGuQ,EAAkBG,UAAUpR,EAAGiR,EAAkBG,UAAU5M,EAAGmO,EAAmBrO,QAG9H,MAA9B2M,EAAkBI,UAAmD,IAA/BJ,EAAkBI,WACxDuB,EAAyBtH,eAAiB2F,EAAkBI,UAE7B,MAA/BJ,EAAkB9F,WAAqD,IAAhC8F,EAAkB9F,YACzDyH,EAAyBrH,gBAAkB0F,EAAkB9F,WAGvB,MAAtCwH,EAAmBxF,iBAA4BwF,EAAmBxF,kBAC7DwF,EAAmB2D,mBACpB,EAAAvS,MAAMC,KAAK2O,EAAmBhR,KAAO,0FAEzC8J,EAAa4B,aAAc,GAG3BJ,GACMK,EAA4B,IAE5B,EAAcqF,EAAmB4D,eAEnCjJ,EAAShM,KACLtC,KAAKuO,mBAAmB,GAAaxG,MAAK,SAACmM,GACnCA,IACAzH,EAAaiC,cAAgBwF,EACH,IAAtB,EAAYvF,QACZlC,EAAaiC,cAAczC,MAAQ,EAAY0C,OAG3D,MAIF/I,EAAiB+N,EAAmB6D,kBAEtClJ,EAAShM,KACLtC,KAAKuO,mBAAmB3I,GAAgBmC,MAAK,SAACmM,GAC1C,GAAIA,EAAa,CACb,IAAMpF,EAAkD,CACpDC,MAAOmF,EAAYnF,MACnB0I,SAAUvD,EAAYuD,SACtBC,WAAYxD,EAAYwD,YAG5BjL,EAAaqC,iBAAmBA,EAChC,IAAM6I,EAAyBhE,EAAmBiE,wBAC9CD,IACA7I,EAAiB+I,SAAWF,EAEpC,CACJ,MAIF/I,EAAkB+E,EAAmBmE,mBAEvCxJ,EAAShM,KACLtC,KAAKuO,mBAAmBK,GAAiB7G,MAAK,SAACmM,GACvCA,IACAzH,EAAamC,gBAAkBsF,EAEvC,KAIJ5F,EAAS9L,OAAS,GAClBxC,KAAK2N,UAAUqB,qBAAqBC,IAAI0E,GACxC,GAAMrM,QAAQ4H,IAAIZ,KAFlB,OAjDJ,M,OAmDI,S,wBAIF3I,EAAgBgO,EAAmBoE,gBACtBzI,kBAAkBvF,EAAOL,KACxC+C,EAAaoC,eAAiBlJ,EAAc4J,WAGhD9C,EAAayB,qBAAuB0F,E,YAG3B,YAAArF,mBAAb,SAAgCtE,G,oGAE5B,OADIuE,EAAcxO,KAAK4N,YAAY7M,IAAIkJ,IAE5B,CAAP,EAAOuE,IAGLgI,EAAexW,KAAKyW,sBAAsBxM,GAC7B,GAAMjK,KAAKgY,yBAAyB/N,K,OAMvD,OANM2M,EAAa,SAEnBpI,EAAcxO,KAAK8W,mBAAmBF,EAAYJ,EAAcvM,EAAe8M,kBAC/E/W,KAAK4N,YAAYqK,IAAIhO,EAAgBuE,GAErCxO,KAAK2N,UAAUuK,8BAA8B,WAAY1J,EAAavE,GAC/D,CAAP,EAAOuE,G,QAGG,YAAAwJ,yBAAd,SAAuC/N,G,+GA2C5B,OA1CDkO,EAAwD,QAAnC,EAAAlO,EAA2BO,gBAAQ,QAAI,OAI5D4N,EAAyBpY,KAAK8N,wBAC9BuK,EAA0BpO,EAAeE,qBAAsBmO,SACrEF,EAAuBC,GAA2BD,EAAuBC,IAA4B,CAAC,OAG5E/X,KAFtBiY,EAAoBH,EAAuBC,GAAyBF,MAGpEI,EAAqB,8B,gEAEH,SAAMvO,EAAoBC,I,OACxC,IADMuO,EAAQ,YACsB,SAAtBL,GAAgCK,EAAMhO,WAAa2N,GAC7D,MAAO,CAAP,EAAOnY,KAAK6W,aAAa5M,EAAetH,KAAM6V,EAAMhO,SAA2BgO,EAAM7N,OAKzF,GADIH,EAAW,YACW,SAAtB2N,EACA,OAAQA,GACJ,IAAK,aACL,IAAK,YACL,IAAK,aACD3N,EAAW2N,EACX,MACJ,QACI,EAAApT,MAAMC,KAAK,kCAA2BmT,EAAiB,gCAMpD,OADTM,EAAOxO,EAAesG,UACb,IAAM,IAAAmI,qBAAoBzO,I,OAC5B,OADPuD,EAAS,SACF,GAAMxN,KAAK8P,mBAAmBtC,EAAQiL,EAAKxL,MAAOwL,EAAKvL,OAAQ1C,I,OAE5E,OAFMG,EAAO,SAEN,CAAP,EAAO3K,KAAK6W,aAAa5M,EAAetH,KAAM6H,EAAUG,I,OAG5DyN,EAAuBC,GAAyBF,GAAqBI,GAGlE,GAAMA,G,OAAb,MAAO,CAAP,EAAO,U,QAGH,YAAA1B,aAAR,SAAqBlU,EAAc6H,EAAyBG,GACxD,IAEIgO,EAFEC,EAAS5Y,KAAK2N,UAAUkL,QAG9B,GAAI7Y,KAAK2N,UAAUmL,cAAe,CAC9BH,EAAQ,CACJhW,KAAMA,EACN6H,SAAUA,EACVuO,gBAAYzY,GAEhB,IAAMyY,EAAa/Y,KAAK2N,UAAUqL,eAAeC,iBAAiB,IAAI7L,WAAWzC,IACjF3K,KAAK2N,UAAUqL,eAAeE,cAAcP,EAAOI,EACvD,KAAO,CAEH,IAAMI,EAAWxW,EAAKyW,QAAQ,mBAAoB,KAC5CC,EAj5BlB,SAAsC7O,GAClC,OAAQA,GACJ,IAAK,aACD,MAAO,OACX,IAAK,YACD,MAAO,OACX,IAAK,aACD,MAAO,QACX,IAAK,aACD,MAAO,QACX,IAAK,aACD,MAAO,QAEnB,CAo4B8B8O,CAA6B9O,GAC3C,EAAW2O,EAAWE,EACtBT,EAAOW,MAAK,SAACZ,GAAU,OAAAA,EAAMa,MAAQ,CAAd,MACvB,EAAW,UAAGL,EAAQ,YAAI,EAAApU,MAAM0U,YAAU,OAAGJ,IAGjDV,EAAQ,CACJhW,KAAMA,EACN6W,IAAK,GAETxZ,KAAK2N,UAAU+L,WAAW,GAAY,CAAE/O,KAAMA,EAAMH,SAAUA,EAClE,CAIA,OAFAoO,EAAOtW,KAAKqW,GAELC,EAAOpW,OAAS,CAC3B,EAEQ,YAAAsU,mBAAR,SAA2BF,EAAoBJ,EAAsBO,GACjE,IAAMrH,EAAW1P,KAAK2N,UAAUgJ,UAC5BgD,EAAejK,EAASkK,WAAU,SAACjT,GAAM,OAAAA,EAAE4N,SAAWiC,GAAgB7P,EAAEyD,SAAWwM,CAA1C,KACvB,IAAlB+C,IACAA,EAAejK,EAASlN,OACxBkN,EAASpN,KAAK,CACV8H,OAAQwM,EACRrC,QAASiC,KAIjB,IAAMhI,EAA4B,CAAEO,MAAO4K,GAI3C,OAHI5C,IACAvI,EAAYiJ,SAAWV,GAEpBvI,CACX,EAEQ,YAAAiI,sBAAR,SAA8B7G,GAC1B,IAAM2E,EAAUvU,KAAKsU,mBAAmB1E,GAGlCiK,EAAW7Z,KAAK2N,UAAUmM,UAC1BtD,EAAeqD,EAASD,WAC1B,SAAChT,GAAM,OAAAA,EAAEoO,YAAcT,EAAQS,WAAapO,EAAEmO,YAAcR,EAAQQ,WAAanO,EAAE4N,QAAUD,EAAQC,OAAS5N,EAAE+N,QAAUJ,EAAQI,KAA3H,IAEX,OAAsB,IAAlB6B,EACOA,GAGXqD,EAASvX,KAAKiS,GACPsF,EAASrX,OAAS,EAC7B,EACJ,EAnzBA,GC/LauX,EAA0B,EAAAhX,OAAOiX,QAAQ,IAAI,EAAAC,SAAS,EAAG,EAAG,GAAI,EAAAC,WAAWC,WAAY,EAAAF,QAAQG,QAMrG,SAASC,EAAWC,EAAYtW,GACnC,KAAMsW,aAAgB,EAAAC,eAClB,OAAO,EAIX,GAAIvW,GAEA,IADesW,EAAKE,iBACRlL,kBAAkB,EAAAvM,OAAO0X,iBAAkB,EAAA/Q,SACnD,OAAO,OAIX,IADe4Q,EAAKE,iBAAiBE,cAAcX,EAAyB,EAAAY,WAAW5X,OAAO,IAClFuM,kBAAkB,EAAAvM,OAAO0X,iBAAkB,EAAA/Q,SACnD,OAAO,EAKf,QAAI4Q,aAAgB,EAAAM,cAAgBN,EAAKjX,SAK7C,CCrBO,IAAMwX,EAAqB,EAAAZ,QAAQG,OAC7BU,EAAkB,EAAAZ,WAAWC,WAC7BY,EAAe,EAAAd,QAAQe,MAC9BC,EAAmC,IAAI,EAAAhB,SAAS,EAAG,EAAG,GAQrD,SAASiB,EAAoBC,EAA4BpZ,GACpD,IAAA+I,EAA6CqQ,EAAY,WAA7CC,EAAiCD,EAAY,WAAjC7U,EAAqB6U,EAAY,KAA3BE,EAAeF,EAAY,WAC3DG,EAAiBH,EAAa5K,UAC9BgL,EAAgBxZ,EAAOyZ,QAAO,SAACrJ,EAAKsJ,GACtC,OAAOA,EAAQC,mBAAqBvJ,EAAMsJ,EAAQC,mBAAqBvJ,CAC3E,IAAIwJ,OAAOC,WAIX,MAAO,CAAE9Q,WAAU,EAAEsQ,WAAU,EAAEE,eAAc,EAAEhV,KAAI,EAAEuV,MAHzCN,EAAgBD,EAGgCD,WAAU,EAAEE,cAAa,EAAEO,KAF5EX,EAAaY,UAG9B,CAEO,SAASC,EAAwBC,GACpC,OAAQA,GACJ,IAAK,OAYL,IAAK,OACD,OAAO,EAXX,IAAK,OACD,OAAO,EACX,IAAK,OACD,OAAO,GACX,IAAK,SACD,OAAO,EACX,IAAK,OACD,OAAO,EACX,IAAK,OACD,OAAO,EAInB,CAMO,SAASC,EAA0B5V,GACtC,OAAQA,GACJ,KAAK,EAAA6V,aAAaC,aAClB,KAAK,EAAAD,aAAaE,WAClB,KAAK,EAAAF,aAAaG,YAClB,KAAK,EAAAH,aAAaI,UAClB,KAAK,EAAAJ,aAAaK,oBAClB,KAAK,EAAAL,aAAaM,yBAClB,KAAK,EAAAN,aAAaO,oBAClB,KAAK,EAAAP,aAAaQ,yBAClB,KAAK,EAAAR,aAAaS,OAClB,KAAK,EAAAT,aAAaU,QAClB,KAAK,EAAAV,aAAaW,QAClB,KAAK,EAAAX,aAAaY,QAClB,KAAK,EAAAZ,aAAaa,QAClB,KAAK,EAAAb,aAAac,QACd,OAAO,EAEf,OAAO,CACX,CAgEO,SAASC,EAAiBC,GAC7B,OAAQA,GACJ,KAAK,EAAA9Y,SAAS+Y,iBACV,OAAO,EACX,KAAK,EAAA/Y,SAASgZ,sBACV,OAAO,EACX,KAAK,EAAAhZ,SAASiZ,oBACV,OAAO,EACX,KAAK,EAAAjZ,SAASkZ,kBACd,KAAK,EAAAlZ,SAASmZ,cACV,OAAO,EACX,KAAK,EAAAnZ,SAASoZ,iBACV,OAAO,EACX,KAAK,EAAApZ,SAASqZ,iBACV,OAAO,EACX,KAAK,EAAArZ,SAASsZ,kBACV,OAAO,EAGf,MAAM,IAAIjQ,MAAM,6BAAsByP,GAC1C,CAaO,SAASS,EAAiBC,GAC7B,IAAMrb,EAASkJ,KAAKC,KAAKkS,EAAQC,EAAID,EAAQC,EAAID,EAAQ1V,EAAI0V,EAAQ1V,EAAI0V,EAAQE,EAAIF,EAAQE,GACzFvb,EAAS,IACTqb,EAAQC,GAAKtb,EACbqb,EAAQ1V,GAAK3F,EACbqb,EAAQE,GAAKvb,EAErB,CAEO,SAASwb,EAA6Bnc,GAEzC,OADAA,EAAMic,IAAM,EACLjc,CACX,CAaO,SAASoc,EAA6Bpc,GAQzC,GAAIA,EAAMic,EAAIjc,EAAMic,EAAIjc,EAAMsG,EAAItG,EAAMsG,EAAI,GAAK,CAC7C,IAAM+V,EAAOxS,KAAKyS,IAAItc,EAAMic,GACtBM,EAAO1S,KAAKyS,IAAItc,EAAMsG,GAC5B,GAAI+V,EAAOE,EAAM,CACb,IAAMC,EAAO3S,KAAK2S,KAAKxc,EAAMic,GAC7Bjc,EAAMic,EAAII,EACVrc,EAAMsG,IAAMkW,EACZxc,EAAMkc,IAAMM,EACZxc,EAAM+P,GAAKyM,CACf,MACUA,EAAO3S,KAAK2S,KAAKxc,EAAMsG,GAC7BtG,EAAMic,IAAMO,EACZxc,EAAMsG,EAAIiW,EACVvc,EAAMkc,GAAKM,EACXxc,EAAM+P,IAAMyM,CAEpB,KAAO,CACH,IAAMC,EAAO5S,KAAKyS,IAAItc,EAAMkc,GACtBQ,EAAO7S,KAAKyS,IAAItc,EAAM+P,GACxB0M,EAAOC,GACDF,EAAO3S,KAAK2S,KAAKxc,EAAMkc,GAC7Blc,EAAMic,IAAMO,EACZxc,EAAMsG,GAAKkW,EACXxc,EAAMkc,EAAIO,EACVzc,EAAM+P,IAAMyM,IAENA,EAAO3S,KAAK2S,KAAKxc,EAAM+P,GAC7B/P,EAAMic,GAAKO,EACXxc,EAAMsG,IAAMkW,EACZxc,EAAMkc,IAAMM,EACZxc,EAAM+P,EAAI2M,EAElB,CAEA,OAAO1c,CACX,CAMO,SAAS2c,EAAWC,GAEvBA,EAASC,gBAAgBD,EAASV,EAAGU,EAAS7M,EAAG6M,EAASX,GAAIW,EAAStW,EAC3E,CAQO,SAASwW,EAAwBrE,EAAasE,GACjD,IAAMC,EAAoB,EAAA5E,QAAQ6E,eAAeF,EAAWG,aAAe,CAAC,EAAG,EAAG,GAAI,EAAG,EAAApE,WAAWV,QAAQ,IACtG+E,EAAiB,EAAA9E,WAAW4E,eAAeF,EAAWH,UAAY,CAAC,EAAG,EAAG,EAAG,GAAI,EAAG,EAAA9D,WAAWT,WAAW,IACzG+E,EAAe,EAAAlc,OAAOmc,aAAanE,EAAciE,EAAgBH,EAAmB,EAAAlE,WAAW5X,OAAO,IAEtGgc,EAAc,EAAA9E,QAAQ6E,eAAexE,EAAKyE,aAAe,CAAC,EAAG,EAAG,GAAI,EAAG,EAAApE,WAAWV,QAAQ,IAC1FwE,EAAW,EAAAvE,WAAW4E,eAAexE,EAAKmE,UAAY,CAAC,EAAG,EAAG,EAAG,GAAI,EAAG,EAAA9D,WAAWT,WAAW,IAC7FiF,EAAS,EAAApc,OAAOmc,aAAanE,EAAc0D,EAAUM,EAAa,EAAApE,WAAW5X,OAAO,IAE1Fkc,EAAavE,cAAcyE,EAAQA,GACnCA,EAAOC,eAAU9e,EAAW0e,EAAgBH,GAExCA,EAAkBvP,kBAAkBuL,EAAoB,EAAAnR,gBACjDkV,EAAWG,YAElBH,EAAWG,YAAcF,EAAkBtP,UAG3CyP,EAAe1P,kBAAkBwL,EAAiB,EAAApR,gBAC3CkV,EAAWH,SAElBG,EAAWH,SAAWO,EAAezP,UAGrCqP,EAAW3S,cACJ2S,EAAW3S,KAE1B,CAUO,SAASoT,EAAmBC,EAAyCC,GACxE,KAAMA,aAA6B,EAAAhF,eAC/B,OAAO,EAKX,GADoE,IAA3CgF,EAAkBC,cAAchd,QAAqD,IAArC8c,EAAYE,cAAchd,QAAgB8c,EAAYG,SAAWF,EAEtI,OAAO,EAIX,IAAMpS,EAAQmS,EAAYvb,WACpB2b,EAAgBJ,aAAuB,EAAAK,eAAiBxS,EAAMnJ,qBAAuBiX,EAAmCF,EAE9H,QAAKwE,EAAkBK,QAAQtQ,kBAAkBoQ,EAAe,EAAAhW,WAC5D,EAAAmW,OAAO7a,KAAK,+BAAwBsa,EAAY3c,KAAI,6BAAqB4c,EAAkB5c,KAAI,6BACxF,EAIf,CAuDO,SAASmd,EAAoCC,EAAWC,GAC3D,IAA2B,UAAApf,OAAOqf,QAAQF,GAAf,eAAwB,CAAxC,WAACrf,EAAG,KAAEmB,EAAK,KACZqe,EAAeF,EAActf,IAC9B4I,MAAM6W,QAAQte,IAAUyH,MAAM6W,QAAQD,IAAiBE,EAAeve,EAAOqe,IAAkBre,IAAUqe,WACnGH,EAAOrf,EAEtB,CACA,OAAOqf,CACX,CAEA,SAASK,EAAeC,EAAmBC,GACvC,OAAOD,EAAO7d,SAAW8d,EAAO9d,QAAU6d,EAAOE,OAAM,SAACC,EAAKvc,GAAM,OAAAuc,IAAQF,EAAOrc,EAAf,GACvE,CCnYA,IAAMwc,EAA0B,IAAI5S,IAA+E,CAC/G,CAAC6S,UAAW,SAAClgB,EAAGgF,EAAGpD,GAAM,OAAA5B,EAAEmgB,QAAQnb,EAAGpD,EAAb,GACzB,CAACgL,WAAY,SAACwT,EAAIC,EAAIze,GAAM,OAAAwe,EAAGE,SAASD,EAAIze,EAAhB,GAC5B,CAAC2e,kBAAmB,SAACH,EAAIC,EAAIze,GAAM,OAAAwe,EAAGE,SAASD,EAAIze,EAAhB,GACnC,CAAC4e,WAAY,SAACJ,EAAIC,EAAIze,GAAM,OAAAwe,EAAGK,SAASJ,EAAIze,GAAG,EAAnB,GAC5B,CAAC8e,YAAa,SAACN,EAAIC,EAAIze,GAAM,OAAAwe,EAAGO,UAAUN,EAAIze,GAAG,EAApB,GAC7B,CAACgf,WAAY,SAACR,EAAIC,EAAIze,GAAM,OAAAwe,EAAGS,SAASR,EAAIze,GAAG,EAAnB,GAC5B,CAACkf,YAAa,SAACV,EAAIC,EAAIze,GAAM,OAAAwe,EAAGW,UAAUV,EAAIze,GAAG,EAApB,GAC7B,CAACqL,aAAc,SAACmT,EAAIC,EAAIze,GAAM,OAAAwe,EAAGY,WAAWX,EAAIze,GAAG,EAArB,GAC9B,CAACqf,aAAc,SAACb,EAAIC,EAAIze,GAAM,OAAAwe,EAAGc,WAAWb,EAAIze,GAAG,EAArB,KAIlC,aAcI,WAAmB2I,GACf/K,KAAK2hB,MAAQ,IAAIvU,WAAWrC,GAC5B/K,KAAK4hB,UAAY,IAAIC,SAAS7hB,KAAK2hB,MAAMrX,QACzCtK,KAAK8hB,YAAc,CACvB,CAmEJ,OAhFW,YAAAC,gBAAP,SAAuBlgB,GACnB7B,KAAKgiB,iBAAiBngB,EAAMkJ,YAE5B,IADA,IAAMkX,EAAYxB,EAAwB1f,IAAIc,EAAMqgB,aAC3Cje,EAAI,EAAGA,EAAIpC,EAAMW,OAAQyB,IAC9Bge,EAAUjiB,KAAK4hB,UAAW5hB,KAAK8hB,YAAajgB,EAAMoC,IAClDjE,KAAK8hB,aAAejgB,EAAMsgB,iBAElC,EAQA,sBAAW,yBAAU,C,IAArB,WACI,OAAOniB,KAAK8hB,WAChB,E,gCAEO,YAAAM,cAAP,WACI,OAAO,IAAIhV,WAAWpN,KAAK2hB,MAAMrX,OAAQ,EAAGtK,KAAK8hB,YACrD,EAEO,YAAAO,WAAP,SAAkBxgB,GACd7B,KAAKgiB,iBAAiB,GACtBhiB,KAAK4hB,UAAUd,SAAS9gB,KAAK8hB,YAAajgB,GAC1C7B,KAAK8hB,aACT,EAEO,YAAAQ,UAAP,SAAiBzgB,GACb7B,KAAKgiB,iBAAiB,GACtBhiB,KAAK4hB,UAAUjB,QAAQ3gB,KAAK8hB,YAAajgB,GACzC7B,KAAK8hB,aACT,EAEO,YAAAS,WAAP,SAAkBC,GACdxiB,KAAKgiB,iBAAiB,GACtBhiB,KAAK4hB,UAAUX,SAASjhB,KAAK8hB,YAAaU,GAAO,GACjDxiB,KAAK8hB,aAAe,CACxB,EAEO,YAAAW,YAAP,SAAmB5gB,GACf7B,KAAKgiB,iBAAiB,GACtBhiB,KAAK4hB,UAAUT,UAAUnhB,KAAK8hB,YAAajgB,GAAO,GAClD7B,KAAK8hB,aAAe,CACxB,EAEO,YAAAY,WAAP,SAAkBF,GACdxiB,KAAKgiB,iBAAiB,GACtBhiB,KAAK4hB,UAAUP,SAASrhB,KAAK8hB,YAAaU,GAAO,GACjDxiB,KAAK8hB,aAAe,CACxB,EAEO,YAAAa,YAAP,SAAmB9gB,GACf7B,KAAKgiB,iBAAiB,GACtBhiB,KAAK4hB,UAAUL,UAAUvhB,KAAK8hB,YAAajgB,GAAO,GAClD7B,KAAK8hB,aAAe,CACxB,EAEO,YAAAc,aAAP,SAAoB/gB,GAChB7B,KAAKgiB,iBAAiB,GACtBhiB,KAAK4hB,UAAUJ,WAAWxhB,KAAK8hB,YAAajgB,GAAO,GACnD7B,KAAK8hB,aAAe,CACxB,EAEO,YAAAe,aAAP,SAAoBhhB,GAChB7B,KAAKgiB,iBAAiB,GACtBhiB,KAAK4hB,UAAUF,WAAW1hB,KAAK8hB,YAAajgB,GAAO,GACnD7B,KAAK8hB,aAAe,CACxB,EAEQ,YAAAE,iBAAR,SAAyBjX,GACrB,IAAM+X,EAAgB9iB,KAAK8K,WAAaC,EACxC,GAAI+X,EAAgB9iB,KAAK2hB,MAAM5W,WAAY,CACvC,IAAMgY,EAAU,IAAI3V,WAA2B,EAAhB0V,GAC/BC,EAAQ9K,IAAIjY,KAAK2hB,OACjB3hB,KAAK2hB,MAAQoB,EACb/iB,KAAK4hB,UAAY,IAAIC,SAAS7hB,KAAK2hB,MAAMrX,OAC7C,CACJ,EACJ,EArFA,GCPA,SAAS0Y,GAAwBjY,GAC7B,OAAIA,EAAa,GAAM,EACZ,EAEPA,EAAa,GAAM,EACZ,EAEJ,CACX,CAMA,ICgDKkY,GDhDL,2BAIY,KAAAC,kBAAyD,IAAIrV,IAK7D,KAAAsV,wBAAuE,IAAItV,IAK3E,KAAAuV,sBAAqD,IAAIvV,GAoJrE,QA7IW,YAAAwV,eAAP,SAAsBC,GAElB,IAAIC,EAAkB,EACtBvjB,KAAKkjB,kBAAkBM,SAAQ,SAAC7Y,GAC5B4Y,GAAmB5Y,EAAKI,UAC5B,IAOA,IANA,IAAM0Y,EAAa,IAAIC,EAAWH,GAMT,MAHEja,MAAMJ,KAAKlJ,KAAKkjB,kBAAkBS,QAAQC,MAAK,SAACrY,EAAG/F,GAAM,OAAAwd,GAAwBxd,EAAEuF,YAAciY,GAAwBzX,EAAER,WAAlE,IAG3D,eAAoB,CAAxC,IAAMgO,EAAU,KACjBA,EAAWjO,WAAa2Y,EAAW3Y,WACnCwY,EAAYhhB,KAAKyW,GAIjB,IAFA,IAAM8K,EAAkBP,EAAY9gB,OAAS,EAExB,MADFxC,KAAK8jB,4BAA4B/K,GAC/B,eAAJ,KACNA,WAAa8K,EAGxBJ,EAAW1B,gBAAgB/hB,KAAKkjB,kBAAkBniB,IAAIgY,IAEtD/Y,KAAKkjB,kBAAkBa,OAAOhL,EAClC,CAEA,OAAO0K,EAAWrB,eACtB,EAQO,YAAAnJ,iBAAP,SAAwBtO,EAAyByQ,GAC7C,IAAMrC,EAA0B,CAC5BzO,OAAQ,EACRQ,gBAAYxK,EACZyK,WAAYJ,EAAKI,WACjBqQ,WAAYA,GAGhB,OADApb,KAAKkjB,kBAAkBjL,IAAIc,EAAYpO,GAChCoO,CACX,EAaO,YAAAiL,eAAP,SACIjL,EACAzS,EACA2d,EACApI,EACA/Q,EACAoZ,EACA7I,GAEArb,KAAKmkB,kBAAkBpL,GACvB,IAAMqL,EAAsB,CACxBrL,gBAAYzY,EACZ2jB,cAAeA,EACfpI,MAAOA,EACPvV,KAAMA,EACN+d,IAAKH,aAAM,EAANA,EAAQG,IACblS,IAAK+R,aAAM,EAANA,EAAQ/R,IACbkJ,WAAYA,EACZvQ,WAAYA,GAIhB,OAFA9K,KAAKkZ,cAAckL,EAAUrL,GAC7B/Y,KAAKojB,sBAAsBnL,IAAImM,EAAUrL,GAClCqL,CACX,EAOO,YAAAlL,cAAP,SAAqB6G,EAAiChH,GAClD/Y,KAAKmkB,kBAAkBpL,GACJ/Y,KAAK8jB,4BAA4B/K,GACzCzW,KAAKyd,EACpB,EAMO,YAAAuE,iBAAP,SAAwBvL,GAEpB,IAFJ,WAEyB,MADF/Y,KAAK8jB,4BAA4B/K,GAC/B,eAAY,CAA5B,IAAMgH,EAAM,UACazf,IAAtByf,EAAOhH,mBACAgH,EAAOhH,UAEtB,CAEA/Y,KAAKkjB,kBAAkBa,OAAOhL,GAC9B/Y,KAAKmjB,wBAAwBY,OAAOhL,GACpC/Y,KAAKojB,sBAAsBI,SAAQ,SAACe,EAAIH,GAChCG,IAAOxL,SAEqBzY,IAAxB8jB,EAAStZ,mBACFsZ,EAAStZ,WAEpB,EAAKsY,sBAAsBW,OAAOK,GAE1C,GACJ,EAEO,YAAAI,cAAP,SAAqBJ,GACjB,IAAMrL,EAAa/Y,KAAKojB,sBAAsBriB,IAAIqjB,GAElD,OADApkB,KAAKmkB,kBAAkBpL,GAChBA,CACX,EAEO,YAAA+K,4BAAP,SAAmC/K,G,MAG/B,OAFA/Y,KAAKmkB,kBAAkBpL,GACvB/Y,KAAKmjB,wBAAwBlL,IAAIc,EAAwD,QAA5C,EAAA/Y,KAAKmjB,wBAAwBpiB,IAAIgY,UAAW,QAAI,IACtF/Y,KAAKmjB,wBAAwBpiB,IAAIgY,EAC5C,EAEO,YAAA0L,QAAP,SAAe1L,GAEX,OADA/Y,KAAKmkB,kBAAkBpL,GAChB/Y,KAAKkjB,kBAAkBniB,IAAIgY,EACtC,EAEQ,YAAAoL,kBAAR,SAA0BpL,GACtB,QAAmBzY,IAAfyY,IAA6B/Y,KAAKkjB,kBAAkBwB,IAAI3L,GACxD,MAAM,IAAIrL,MAAM,qBAAcqL,EAAU,gCAEhD,EACJ,EAlKA,ICgDA,SAAKkK,GAID,6BAIA,8BACH,CATD,CAAKA,KAAAA,GAAY,KAejB,+BA+9BA,QAz9BmB,EAAA0B,iBAAf,SAAgCrF,GAC5B,OAAOA,IAAgBA,aAAuB,EAAA/E,eAAiB+E,aAAuB,EAAAsF,QAAUtF,aAAuB,EAAAuF,MAC3H,EAYc,EAAAC,qBAAd,SACIC,EACAC,EACAC,EACAC,EACAC,GAEA,GAAInlB,KAAK2kB,iBAAiBI,GAAuB,CAC7C,IAAMK,EAAmB,GACnBC,EAAsB,GACtBC,EAAYN,EAAUO,UACtBC,EAAkBC,EAAeC,0BAA0BJ,GAC3DK,EAAsBF,EAAeG,qBAAqBN,EAAWL,EAA4BC,GAEjGW,EAAgBF,EAAoBG,kBACpCC,EAAsBJ,EAAoBI,oBAsChD,GApCIA,EACAN,EAAeO,sBACXjB,EACAC,EACAC,EACAO,EAAgBnB,IAChBmB,EAAgBrT,IAChB6S,EAAUiB,eACVd,EACAC,EACAC,EACAG,EACAN,GAGkB,WAAlBW,GAA4E,SAAlBA,EAC1DJ,EAAeS,6BAA6BnB,EAAsBC,EAAWC,EAA4BG,EAAQC,EAASH,GACjG,gBAAlBW,EACPJ,EAAeU,4BAA4BpB,EAAsBC,EAAWC,EAA4BG,EAAQC,EAASH,GAEzHO,EAAeO,sBACXjB,EACAC,EACAC,EACAO,EAAgBnB,IAChBmB,EAAgBrT,IAChB6S,EAAUiB,eACVd,EACAC,EACAC,EACAG,EACAN,GAKRE,EAAO5iB,QAAU6iB,EAAQ7iB,OASzB,MARgC,CAC5B4iB,OAAQA,EACRC,QAASA,EACTe,qBAAsBP,EACtBQ,UAAWN,EAAsBP,EAAgBnB,IAAM,EAAAtf,MAAMuhB,WAAWd,EAAgBnB,IAAMW,EAAUiB,gBACxGM,UAAWR,EAAsBP,EAAgBrT,IAAM,EAAApN,MAAMuhB,WAAWd,EAAgBrT,IAAM6S,EAAUiB,gBAKpH,CAEA,OAAO,IACX,EAEe,EAAAO,qBAAf,SAAoCxB,GAChC,IAAIC,EAAmE,KACnEwB,EAAmB,OACnBvB,GAAyB,EACvBwB,EAAW1B,EAAU2B,eAAeC,MAAM,KAChD,OAAQF,EAAS,IACb,IAAK,UACDzB,EAA6B,QAC7B,MAEJ,IAAK,WACDA,EAA6B,cAC7B,MAEJ,IAAK,WACDwB,EAAmB,OACnBxB,EAA6B,WAC7B,MAEJ,IAAK,qBACDwB,EAAmB,OACnBvB,GAAgB,EAChBD,EAA6B,WAC7B,MAEJ,IAAK,YACDwB,EAAmB,SACnBxB,EAA6B,UAC7B,MAEJ,QACI,EAAAlgB,MAAM2I,MAAM,0CAAmCgZ,EAAS,KAGhE,OAAIzB,EACO,CAAEA,2BAA4BA,EAA4BwB,iBAAkBA,EAAkBvB,cAAeA,IAEpH,EAAAngB,MAAM2I,MAAM,yEAET,KACX,EAec,EAAAmZ,uCAAd,SACIvH,EACAwH,EACAC,EACAC,EACAC,EACAC,EACA5D,EACA6D,EACAhC,EACAiC,EACAC,GAEA,IAAIC,EACJ,GAAI7B,EAAed,iBAAiBrF,IAC5BA,EAAYiI,WACZ,IAAwB,UAAAjI,EAAYiI,WAAZ,eAAwB,CAA3C,IAAMvC,EAAS,KAChB,IAAIqC,GAA0BA,EAAsBrC,GAApD,CAGA,IAAMwC,EAAgB/B,EAAee,qBAAqBxB,GACtDwC,IACAF,EAAgB,CACZ3kB,KAAMqiB,EAAUriB,KAChBkX,SAAU,GACV4N,SAAU,IAEdhC,EAAeiC,cACX,UAAG1C,EAAUriB,MACbqiB,EAAU2C,4BAA8Bb,EAAuBQ,EAC/DhI,EACA0F,EACAwC,EAAcf,iBACde,EAAcvC,2BACd+B,EACAE,EACA5D,EACA6D,EACAK,EAActC,cACdC,EACAiC,GAEAE,EAAczN,SAASrX,QAAU8kB,EAAcG,SAASjlB,QACxDukB,EAAmBzkB,KAAKglB,GAxBhC,CA2BJ,CAGZ,EAec,EAAAM,qDAAd,SACItI,EACAwH,EACAC,EACAC,EACAC,EACAC,EACA5D,EACA6D,EACAhC,EACAiC,EACAC,GAEA,IAAIC,EACJ,GAAIhI,aAAuB,EAAAuI,KAAM,CAC7B,IAAMC,EAAqBxI,EAAYwI,mBACvC,GAAIA,EACA,IAAK,IAAI7jB,EAAI,EAAGA,EAAI6jB,EAAmBC,aAAc9jB,EAEjD,IADA,IACwB,MADJ6jB,EAAmBE,UAAU/jB,GACbsjB,WAAZ,eAAwB,CAA3C,IAAMvC,EAAS,KAChB,IAAIqC,GAA0BA,EAAsBrC,GAApD,CAcA,IAXA,IAAMiD,EAAoB,IAAI,EAAAC,UAC1B,UAAGlD,EAAUriB,MACb,YACAqiB,EAAUiB,eACVjB,EAAUmD,SACVnD,EAAUoD,SACVpD,EAAUqD,gBAERC,EAAyC,GACzCC,EAAgBvD,EAAUO,UAEvBhjB,EAAI,EAAGA,EAAIgmB,EAAc/lB,SAAUD,EAExC,IADA,IAAMimB,EAAeD,EAAchmB,GAC1BkmB,EAAI,EAAGA,EAAIX,EAAmBC,aAAcU,EAC7CA,GAAKxkB,EACLqkB,EAAsBhmB,KAAKkmB,GAE3BF,EAAsBhmB,KAAK,CAAEomB,MAAOF,EAAaE,MAAO7mB,MAAO,IAI3EomB,EAAkBU,QAAQL,GAC1B,IAAMd,EAAgB/B,EAAee,qBAAqByB,GACtDT,IACAF,EAAgB,CACZ3kB,KAAMslB,EAAkBtlB,KACxBkX,SAAU,GACV4N,SAAU,IAEdhC,EAAeiC,cACX1C,EAAUriB,KACVqiB,EAAU2C,4BAA8Bb,EAAuBQ,EAC/DhI,EACA2I,EACAT,EAAcf,iBACde,EAAcvC,2BACd+B,EACAE,EACA5D,EACA6D,EACAK,EAActC,cACdC,EACAiC,EACAU,EAAmBC,YAEnBT,EAAczN,SAASrX,QAAU8kB,EAAcG,SAASjlB,QACxDukB,EAAmBzkB,KAAKglB,GA/ChC,CAkDJ,CAGZ,CACJ,EAcc,EAAAsB,gDAAd,SACIC,EACAC,EACA9B,EACAE,EACA5D,EACA6D,EACAhC,EACA4D,EACA1B,G,MAEIC,EACJ,GAAIuB,EAAaG,gBAEb,IADA,IAAMA,EAAkBH,EAAaG,gB,WAC1BC,GACP,IAAMC,EAA0D,IAAIrb,IAC9Dsb,EAAyC,IAAItb,IAC7Cub,EAAkC,IAAIC,IACtCC,EAA0BL,EAAehgB,GAAKggB,EAAe/f,KACnEoe,EAAgB,CACZ3kB,KAAMsmB,EAAetmB,KACrB8kB,SAAU,GACV5N,SAAU,IAEd,I,eAAS5V,GACL,IAAMslB,EAAkBN,EAAeO,mBAAmBvlB,GACpDwlB,EAASF,EAAgBE,OACzBzE,EAAYuE,EAAgBvE,UAClC,GAAIqC,IAA0BA,EAAsBrC,G,iBAIpD,IAAM0E,EAAuBX,EAAgBrE,IAAI+E,GAEjD,GAAI,EAAK9E,iBAAiB8E,IAA8B,IAAlBA,EAAOjnB,QAAgB,EAAKmiB,iBAAiB8E,EAAO,KAEtF,GADMjC,EAAgB/B,EAAee,qBAAqB+C,EAAgBvE,WACvD,CACf,IAAMD,EAAuB,EAAKJ,iBAAiB8E,GAAUA,EAAS,EAAK9E,iBAAiB8E,EAAO,IAAMA,EAAO,GAAK,KACjH1E,GACAU,EAAeiC,cACX,UAAG1C,EAAUriB,MACb2kB,EACAvC,EACAC,EACAwC,EAAcf,iBACde,EAAcvC,2BACd+B,EACAE,EACA5D,EACA6D,EACAK,EAActC,cACdC,EACAuE,EAGZ,OACG,GAAID,aAAkB,EAAAE,aAAkC,IAAlBF,EAAOjnB,QAAgBinB,EAAO,aAAc,EAAAE,YAAc,CACnG,IAAMnC,EACN,GADMA,EAAgB/B,EAAee,qBAAqB+C,EAAgBvE,WACvD,CACf,IAAM,EAAqByE,aAAkB,EAAAE,YAAcF,EAAUA,EAAO,GAC5E,GAAI,EAAoB,CACpB,IAAM,EAA4BZ,EAAae,oBAAoBC,MAAK,SAAC/B,GACrE,IAAK,IAAIvlB,EAAI,EAAGA,EAAIulB,EAAmBC,aAAcxlB,EACjD,GAAIulB,EAAmBE,UAAUzlB,KAAO,EACpC,OAAO,EAGf,OAAO,CACX,IACA,GAAI,EAA2B,CAC3B,IAAMunB,EAAcjB,EAAa9mB,OAAO8nB,MAAK,SAACpnB,GAC1C,OAAQA,EAAcqlB,qBAAuB,CACjD,IACIgC,IACKZ,EAAgBxE,IAAIoF,IACrBZ,EAAgBjR,IAAI6R,EAAa,IAAIjc,KAET,QAAhC,EAAAqb,EAAgBnoB,IAAI+oB,UAAY,SAAE7R,IAAI,EAAoB+M,GAC1DoE,EAAqBna,IAAI6a,GACzBX,EAAiBlR,IAAI6R,EAAa9E,GAE1C,CACJ,CACJ,CACJ,C,EA5DK/gB,EAAI,EAAGA,EAAIglB,EAAeO,mBAAmBhnB,SAAUyB,E,EAAvDA,GAgETmlB,EAAqB5F,SAAQ,SAAC/gB,GAgB1B,IAfA,IAAMqlB,EAAqBrlB,EAAKqlB,mBAC5BiC,EAA8C,KAC5CxB,EAAiC,GAEjCyB,EADkBb,EAAiBpoB,IAAI0B,GACD8iB,UACtC0E,EAAmBD,EAAoBxnB,OAUpCyB,EAAI,EAAGA,EAAIgmB,IAAoBhmB,EACpC,IAAK,IAAI1B,EAAI,EAAGA,EAAIulB,EAAmBC,aAAcxlB,EAAG,CACpD,IAAM2nB,EAAcpC,EAAmBE,UAAUzlB,GAC3C4nB,EAA0BjB,EAAgBnoB,IAAI0B,GACpD,GAAI0nB,EAAyB,CACzB,IAAMC,EAAuBD,EAAwBppB,IAAImpB,GACrDE,GACKL,IACDA,EAAyB,IAAI,EAAA7B,UACzB,UAAGe,EAAetmB,KAAI,YAAIF,EAAKE,KAAI,yBACnC,YACAynB,EAAqBnE,eACrB,EAAAiC,UAAUmC,oBACVD,EAAqBhC,SACrBgC,EAAqB/B,iBAG7BE,EAAcjmB,KAAK8nB,EAAqB7E,UAAUthB,KAElDskB,EAAcjmB,KAAK,CACfomB,MAAOO,EAAe/f,KAAQogB,EAA0BW,EAAoBhmB,EAC5EpC,MAAOqoB,EAAYI,UACnBC,UAAWP,EAAoB,GAAGO,UAAY,OAAIjqB,EAClDkqB,WAAYR,EAAoB,GAAGQ,WAAa,OAAIlqB,GAGhE,CACJ,CAEJypB,EAAwBpB,QAAQJ,GAChC,IAAMf,EAAgB/B,EAAee,qBAAqBuD,GACtDvC,GACA/B,EAAeiC,cACX,UAAGuB,EAAetmB,KAAI,YAAIF,EAAKE,KAAI,yBACnC2kB,EACA7kB,EACAsnB,EACAvC,EAAcf,iBACde,EAAcvC,2BACd+B,EACAE,EACA5D,EACA6D,EACAK,EAActC,cACdC,GACA,EACA2C,aAAkB,EAAlBA,EAAoBC,WAGhC,IACIT,EAAcG,SAASjlB,QAAU8kB,EAAczN,SAASrX,QACxDsmB,EAAexmB,KAAKglB,E,SA7IC,MAAA0B,EAAA,e,EAAJ,KAiJjC,EAEe,EAAAtB,cAAf,SACI/kB,EACA2kB,EACAvC,EACAC,EACAyB,EACAxB,EACA+B,EACAE,EACA5D,EACA6D,EACAjC,EACAC,EACAuE,EACAe,GAEA,IACI1R,EACAqL,EACAsG,EACAC,EACAC,EACAC,EANEC,EAAgBrF,EAAeX,qBAAqBC,EAAsBC,EAAWC,EAA4BC,EAAeC,GAQtI,GAAI2F,EAAe,CAMf,GAAIL,EAAwB,CAIxB,IAHA,IAAI1b,EAAQ,EACRgc,EAAuB,EACrBC,EAAsB,GACrBF,EAAc1F,OAAO5iB,OAAS,GACjCuoB,EAAeD,EAAc1F,OAAO6F,QAChClc,EAAQ0b,GAA0B,GAClCO,EAAU1oB,KAAKyoB,GAEnBhc,IAEJ+b,EAAc1F,OAAS4F,CAC3B,CAEA,IAAME,EAAYlE,EAAQjmB,IAAIgkB,GAGxBoG,EAAY,IAAI1d,aAAaqd,EAAc1F,QACjDrM,EAAamO,EAAcjO,iBAAiBkS,GAC5C/G,EAAW8C,EAAclD,eAAejL,EAAY,SAAF,KAAoD+R,EAAc1F,OAAO5iB,YAAQlC,EAAW,CAC1I+jB,IAAK,CAACyG,EAAczE,WACpBlU,IAAK,CAAC2Y,EAAcvE,aAExBY,EAAU7kB,KAAK8hB,GACfsG,EAAwBvD,EAAU3kB,OAAS,EAG3C,IAAM,EAAqB,IAAI,EAAA0X,WACzB,EAAY,IAAI,EAAAD,QAChB,EAAW,IAAI,EAAAA,QACf,EAAW8K,aAAgC,EAAAH,OAE3C,EAAe5I,EAAwByK,GACvC,EAAa,IAAIhZ,aAAaqd,EAAczF,QAAQ7iB,OAAS,GACnEsoB,EAAczF,QAAQ7B,SAAQ,SAAUrhB,EAAkB4M,GACtD,IAAIqc,EAA0BjpB,EAC9B,OAAQ8iB,GACJ,IAAK,cACGyE,IACA,EAAAzP,QAAQ6E,eAAe3c,EAAQ,EAAG,GAClC6b,EAA6B,GAC7B,EAASqN,QAAQD,IAErB,MACJ,IAAK,WACqB,IAAlBjpB,EAAOK,OACP,EAAA0X,WAAW4E,eAAe3c,EAAQ,EAAG,IAErCipB,EAAgB,IAAI9hB,MAAM,GAC1B,EAAA2Q,QAAQ6E,eAAe3c,EAAQ,EAAG,GAClC,EAAA+X,WAAWoR,qBAAqB,EAAW,IAG3C5B,IACAzL,EAA6B,GACzB,GACAO,EAAW,IAInB,EAAmB6M,QAAQD,GAGnC,EAAWnT,IAAImT,EAAerc,EAAQ,EAC1C,IAGAgK,EAAamO,EAAcjO,iBAAiB,GAC5CmL,EAAW8C,EAAclD,eAAejL,EAAY0N,EAAkB,KAA6BqE,EAAczF,QAAQ7iB,QACzH2kB,EAAU7kB,KAAK8hB,GACfuG,EAAoBxD,EAAU3kB,OAAS,EAGvCooB,EAAmB,CACf/E,cAAeiF,EAAc1E,qBAC7BmF,MAAOb,EACPvoB,OAAQwoB,GAEZrD,EAAczN,SAASvX,KAAKsoB,GAG5BC,EAAmB,CACftW,QAAS+S,EAAczN,SAASrX,OAAS,EACzCinB,OAAQ,CACJnP,KAAM4Q,EACNM,KAAMvG,IAGdqC,EAAcG,SAASnlB,KAAKuoB,EAChC,CACJ,EAkBe,EAAA7E,sBAAf,SACIjB,EACAC,EACAC,EACAwG,EACAC,EACAC,EACAC,EACAxG,EACAC,EACAwG,EACA3G,GAEA,IAAIrjB,EAGAiqB,EAFEC,EAA8B,EAAA7R,WAAWC,WAC3C6R,EAAiC,KAEjCC,EAAiC,KACjCC,EAAwC,KACxCC,EAAwC,KACxCC,EAAwC,KACxCC,EAA6B,KACjCR,EAAaxH,IAAM,EAAAtf,MAAMuhB,WAAWmF,EAAWE,GAI/C,IAFA,IAAMrG,EAAYN,EAAUO,UAEnBthB,EAAI,EAAG,EAASqhB,EAAU9iB,OAAQyB,EAAI,IAAUA,EAAG,CAIxD,GAHAooB,EAAW,KACXH,EAAe5G,EAAUrhB,GAErBA,EAAI,EAAI,EAER,GADAkoB,EAAe7G,EAAUrhB,EAAI,GACxBioB,EAAarqB,MAAMyqB,QAAUJ,EAAarqB,MAAMyqB,OAAOH,EAAatqB,QAAWqqB,EAAarqB,QAAUsqB,EAAatqB,MAAO,CAC3H,GAAU,IAANoC,EAIA,SAFAooB,EAAWH,EAAaxD,KAIhC,MACI2D,EAAWF,EAAazD,UAEzB,CAGH,GADA0D,EAAe9G,EAAUrhB,EAAI,GACxBioB,EAAarqB,MAAMyqB,QAAUJ,EAAarqB,MAAMyqB,OAAOF,EAAavqB,QAAWqqB,EAAarqB,QAAUuqB,EAAavqB,MACpH,SAEAwqB,EAAWX,CAEnB,CACA,GAAIW,EACA,IAAK,IAAInkB,EAAIgkB,EAAaxD,MAAOxgB,GAAKmkB,EAAUnkB,GAAK0jB,EAEjD,IADAE,EAAO,EAAA/mB,MAAMuhB,WAAWpe,EAAIyjB,MACfK,EAAb,CAGAA,EAAeF,EACfG,EAAeH,EACf,IAAMS,EAAQ,CACV7rB,IAAK,EACL8rB,YAAa,EACbpE,SAAUpD,EAAUoD,UAExBvmB,EAAQmjB,EAAUyH,aAAavkB,EAAGqkB,GAElC9G,EAAeiH,sBAAsB3H,EAAsBljB,EAAOiqB,EAAM9G,EAAWC,EAA4B8G,EAAiB3G,EAAQC,EAASH,EAVjJ,CAaZ,CACI+G,IACAJ,EAAa1Z,IAAM8Z,EAE3B,EAEe,EAAAU,oCAAf,SACIC,EACA7H,EACAC,EACAC,EACAC,GAEA,IAAM2H,EAA8BpH,EAAeqH,gCAAgC/H,EAAsBE,EAA4BC,GAE/HwB,EAAW1B,EAAU2B,eAAeC,MAAM,KAC1CmG,EAAgBrG,EAAWA,EAAS,GAAK,GACzC7kB,EAAQqjB,EAAgB,EAAAhL,WAAW8S,UAAUH,GAA6BI,YAAc,EAAAhT,QAAQ+S,UAAUH,GAEhH,OAAQE,GACJ,IAAK,IACL,IAAK,IACL,IAAK,IACDlrB,EAAMkrB,GAAiBH,EACvB,MAEJ,IAAK,IACA/qB,EAAqB+P,EAAIgb,EAC1B,MAEJ,QACI,EAAA7nB,MAAM2I,MAAM,qDAA8Cqf,EAAa,OAI/E,OAAOlrB,CACX,EAEe,EAAA6qB,sBAAf,SACI3H,EACAljB,EACAiqB,EACA9G,EACAC,EACA8G,EACA3G,EACAC,EACAH,GAEA,IAAIgI,EACJ9H,EAAO9iB,KAAKwpB,GAEuB,YAA/B7G,GAKAD,EAAUmD,WAAa,EAAAD,UAAUmC,sBACjCxoB,EAAQ7B,KAAK2sB,oCAAoC9qB,EAAiBkjB,EAAsBC,EAAWC,EAA4BC,IAGhG,aAA/BD,GACIC,EACA6G,EAAkBlqB,GAElBqrB,EAAarrB,EACb,EAAAqY,WAAWiT,0BAA0BD,EAAW/kB,EAAG+kB,EAAWpP,EAAGoP,EAAWnP,EAAGgO,IAEnF1G,EAAQ/iB,KAAKypB,EAAgBxc,aAG7B2d,EAAarrB,EACbwjB,EAAQ/iB,KAAK4qB,EAAW3d,aAnBxB8V,EAAQ/iB,KAAK,CAACT,GAqBtB,EAWe,EAAAqkB,6BAAf,SACInB,EACAC,EACAC,EACAG,EACAC,EACAH,GAEA,IAAuB,UAAAF,EAAUO,UAAV,eAAqB,CAAvC,IAAM6H,EAAQ,KACfhI,EAAO9iB,KAAK8qB,EAAS1E,MAAQ1D,EAAUiB,gBACvCR,EAAe4H,kBAAkBD,EAAUpI,EAAWK,EAASJ,EAA4BF,EAAsBG,EACrH,CACJ,EAWe,EAAAiB,4BAAf,SACIpB,EACAC,EACAC,EACAG,EACAC,EACAH,GAEAF,EAAUO,UAAU/B,SAAQ,SAAU4J,GAClChI,EAAO9iB,KAAK8qB,EAAS1E,MAAQ1D,EAAUiB,gBACvCR,EAAe6H,kBAAkBrK,GAAasK,UAAWlI,EAASJ,EAA4B,cAA2CmI,EAAUlI,GACnJO,EAAe4H,kBAAkBD,EAAUpI,EAAWK,EAASJ,EAA4BF,EAAsBG,GAEjHO,EAAe6H,kBAAkBrK,GAAauK,WAAYnI,EAASJ,EAA4B,cAA2CmI,EAAUlI,EACxJ,GACJ,EAEe,EAAA4H,gCAAf,SAA+C/H,EAA4BE,EAAwDC,GAC/H,IAAI2H,EACJ,GAAmC,aAA/B5H,EACA,GAAIC,EAAe,CACf,IAAMuI,EAAK1I,EAAuC2I,mBAClDb,GAA+BY,QAAAA,EAAK,EAAAvT,WAAWC,YAAY5K,SAC/D,KAAO,CACH,IAAM7N,EAAcqjB,EAAuCtG,SAC3DoO,GAA+BnrB,QAAAA,EAAK,EAAAuY,QAAQG,QAAQ7K,SACxD,MACG,GAAmC,gBAA/B0V,EAAuE,CAC9E,IAAMle,EAAcge,EAAuC4I,SAC3Dd,GAA+B9lB,QAAAA,EAAK,EAAAkT,QAAQG,QAAQ7K,SACxD,KAAO,CAEH,IAAM3I,EAAcme,EAAuCnF,QAC3DiN,GAA+BjmB,QAAAA,EAAK,EAAAqT,QAAQe,OAAOzL,SACvD,CACA,OAAOsd,CACX,EAWe,EAAAQ,kBAAf,SACID,EACApI,EACAK,EACAJ,EACAF,EACAG,GAEA,IAAI0I,EACEC,EAAgB7I,EAAUmD,SAChC,GAAI0F,IAAkB,EAAA3F,UAAU4F,sBAAuB,CACnD,IAAIjsB,EAAQurB,EAASvrB,MAAM0N,UAC3B,GAAmC,aAA/B0V,EAAoE,CACpE,IAAM8I,EAAQ,EAAA9T,QAAQ+S,UAAUnrB,GAEhCA,EAD2B,EAAAqY,WAAW8T,qBAAqBD,EAAM5lB,EAAG4lB,EAAMjQ,EAAGiQ,EAAMhQ,GACxDxO,SAC/B,CACA8V,EAAQ/iB,KAAKT,EACjB,MAAO,GAAIgsB,IAAkB,EAAA3F,UAAUmC,qBACnC,GAAmC,YAA/BpF,EACAI,EAAQ/iB,KAAK,CAAC8qB,EAASvrB,aAUvB,GAPA+rB,EAA6B5tB,KAAK2sB,oCAC9BS,EAASvrB,MACTkjB,EACAC,EACAC,EACAC,GAE4B,CAC5B,GAAmC,aAA/BD,EAAoE,CACpE,IAAMgJ,EAAc/I,EACb0I,EACD,EAAA1T,WAAW8T,qBAAqBJ,EAA2BzlB,EAAGylB,EAA2B9P,EAAG8P,EAA2B7P,GAAGkP,YAChI5H,EAAQ/iB,KAAK2rB,EAAY1e,UAC7B,CACA8V,EAAQ/iB,KAAKsrB,EAA2Bre,UAC5C,OAEGse,IAAkB,EAAA3F,UAAUgG,yBACnC7I,EAAQ/iB,KAAM8qB,EAASvrB,MAAqBorB,YAAY1d,WAExD,EAAAxK,MAAM2I,MAAM,6DAEpB,EASe,EAAAkY,qBAAf,SACIN,EACAL,EACAC,GAEA,IAAIY,EAEAplB,EADAqlB,GAAsB,EAG1B,GAAmC,aAA/Bd,IAAuEC,EACvE,MAAO,CAAEY,kBAAmB,SAAsCC,qBAAqB,GAG3F,IAAK,IAAI9hB,EAAI,EAAG,EAASqhB,EAAU9iB,OAAQyB,EAAI,IAAUA,EAErD,IADAvD,EAAM4kB,EAAUrhB,IACRsmB,WAAa7pB,EAAI8pB,WACrB,GAAI1E,GACA,GAA0B,gBAAtBA,EAAiE,CACjEA,EAAoB,SACpBC,GAAsB,EACtB,KACJ,OAEAD,EAAoB,mBAGxB,GAAIA,GACA,GAC0B,gBAAtBA,GACCplB,EAAImlB,eAAuC,IAAtBnlB,EAAImlB,eAA0E,SAAtBC,EAChF,CACEA,EAAoB,SACpBC,GAAsB,EACtB,KACJ,OAGID,EADAplB,EAAImlB,eAAuC,IAAtBnlB,EAAImlB,cACL,OAEA,SASpC,OAJKC,IACDA,EAAoB,UAGjB,CAAEA,kBAAmBA,EAAmBC,oBAAqBA,EACxE,EAYe,EAAAuH,kBAAf,SACIa,EACA9I,EACAJ,EACAY,EACAuH,EACAlI,GAEA,IAAIrH,EACEuQ,EAA8CD,IAAgBlL,GAAasK,UAAYH,EAAS7C,UAAY6C,EAAS5C,WAC3H,GAAsB,gBAAlB3E,EAA6D,CAC7D,GAAmC,aAA/BZ,EACA,GAAImJ,EACA,GAAIlJ,EACArH,EAAWuQ,EAA4B7e,cACpC,CACH,IAAMwe,EAAQK,EACdvQ,EAAU,EAAA3D,WAAW8T,qBAAqBD,EAAM5lB,EAAG4lB,EAAMjQ,EAAGiQ,EAAMhQ,GAAGxO,SACzE,MAEAsO,EAAU,CAAC,EAAG,EAAG,EAAG,QAIpBA,EAFkC,YAA/BoH,EACHmJ,EACU,CAACA,GAED,CAAC,GAGXA,EACWA,EAAyB7e,UAE1B,CAAC,EAAG,EAAG,GAIzB8V,EAAQ/iB,KAAKub,EACjB,CACJ,EAOe,EAAA6H,0BAAf,SAAyCJ,GACrC,IAAIjB,EAAcgK,IACdlc,GAAc,IAMlB,OALAmT,EAAU9B,SAAQ,SAAU4J,GACxB/I,EAAM3Y,KAAK2Y,IAAIA,EAAK+I,EAAS1E,OAC7BvW,EAAMzG,KAAKyG,IAAIA,EAAKib,EAAS1E,MACjC,IAEO,CAAErE,IAAKA,EAAKlS,IAAKA,EAC5B,EACJ,EA/9BA,GClEO,SAASmc,GACZpE,EACAznB,EACAykB,EACA5D,EACA6D,EACAuC,GAEA,IAAM7hB,EAA2B,CAC7B0mB,WAAY,CAAC,EACbjE,UAAWJ,EAAYI,UACvB3nB,KAAMunB,EAAYvnB,MAGhBU,EAAWZ,EAAKY,SACtB,IAAKA,EAED,OADA,EAAA0B,MAAMC,KAAK,+FACJ6C,EAGX,IAAM2mB,EAAQ9E,GAAwB,EAAI,EAEpC+E,EAAa,EAAAxU,QAAQG,OAEvBsU,EAAc,EAElB,GAAIxE,EAAYyE,aAAc,CAC1B,IAAMC,EAAiB1E,EAAY2E,eAC7BC,EAAoBzrB,EAASE,gBAAgB,EAAA4Y,aAAaC,cAEhE,GAAI0S,EAAmB,CACnB,IAAMC,EAAe,IAAIthB,aAAaqhB,EAAkBtsB,QAClD6hB,EAAM,CAACgK,IAAUA,IAAUA,KAC3Blc,EAAM,EAAC,KAAW,KAAW,KACnCuc,EAAcI,EAAkBtsB,OAAS,EAEzC,IAAK,IAAIyB,EADK,EACYA,EAAIyqB,IAAezqB,EAAG,CAC5C,IAAM+qB,EAAmB,EAAA/U,QAAQ+S,UAAU8B,EAAuB,EAAJ7qB,GACxC,EAAAgW,QAAQ+S,UAAU4B,EAAoB,EAAJ3qB,GAC1CgrB,cAAcD,EAAkBP,GAC9CA,EAAW3Q,GAAK0Q,EAEhBnK,EAAI,GAAK3Y,KAAK2Y,IAAIA,EAAI,GAAIoK,EAAW3Q,GACrC3L,EAAI,GAAKzG,KAAKyG,IAAIA,EAAI,GAAIsc,EAAW3Q,GAErCuG,EAAI,GAAK3Y,KAAK2Y,IAAIA,EAAI,GAAIoK,EAAWtmB,GACrCgK,EAAI,GAAKzG,KAAKyG,IAAIA,EAAI,GAAIsc,EAAWtmB,GAErCkc,EAAI,GAAK3Y,KAAK2Y,IAAIA,EAAI,GAAIoK,EAAW1Q,GACrC5L,EAAI,GAAKzG,KAAKyG,IAAIA,EAAI,GAAIsc,EAAW1Q,GAErCgR,EAAiB,EAAJ9qB,GAASwqB,EAAW3Q,EACjCiR,EAAiB,EAAJ9qB,EAAQ,GAAKwqB,EAAWtmB,EACrC4mB,EAAiB,EAAJ9qB,EAAQ,GAAKwqB,EAAW1Q,CACzC,CAEA,IAAMhF,EAAamO,EAAcjO,iBAAiB8V,EAAcG,IAC1D9K,EAAW8C,EAAclD,eAAejL,EAAY,OAAF,KAAkD6V,EAAepsB,OAAS,EAAG,EAAG,CAAE6hB,IAAG,EAAElS,IAAG,IAClJgV,EAAU7kB,KAAK8hB,GACfvc,EAAO0mB,WAAqB,SAAIpH,EAAU3kB,OAAS,CACvD,MACI,EAAAuC,MAAMC,KAAK,0CAAmCvC,EAAKE,KAAI,+DAE/D,CAEA,GAAIunB,EAAYiF,WAAY,CACxB,IAAMC,EAAelF,EAAYmF,aAC3BC,EAAkBjsB,EAASE,gBAAgB,EAAA4Y,aAAaE,YAE9D,GAAIiT,EAAiB,CACjB,IAAMC,EAAa,IAAI9hB,aAAa6hB,EAAgB9sB,QAGpD,IAFAksB,EAAcY,EAAgB9sB,OAAS,EAE9ByB,EADK,EACYA,EAAIyqB,IAAezqB,EAAG,CAC5C,IAAMurB,EAAiB,EAAAvV,QAAQ+S,UAAUsC,EAAqB,EAAJrrB,GAAOgpB,YAC7C,EAAAhT,QAAQ+S,UAAUoC,EAAkB,EAAJnrB,GAAOgpB,YAC/CgC,cAAcO,EAAgBf,GAE1Cc,EAAe,EAAJtrB,GAASwqB,EAAW3Q,EAAI0Q,EACnCe,EAAe,EAAJtrB,EAAQ,GAAKwqB,EAAWtmB,EACnConB,EAAe,EAAJtrB,EAAQ,GAAKwqB,EAAW1Q,CACvC,CAEMhF,EAAamO,EAAcjO,iBAAiBsW,EAAYL,IACxD9K,EAAW8C,EAAclD,eAAejL,EAAY,OAAF,KAAkDqW,EAAa5sB,OAAS,EAAG,GACnI2kB,EAAU7kB,KAAK8hB,GACfvc,EAAO0mB,WAAmB,OAAIpH,EAAU3kB,OAAS,CACrD,MACI,EAAAuC,MAAMC,KAAK,wCAAiCvC,EAAKE,KAAI,8DAE7D,CAEA,GAAIunB,EAAYuF,YAAa,CACzB,IAAMC,EAAgBxF,EAAYyF,cAC5BC,EAAmBvsB,EAASE,gBAAgB,EAAA4Y,aAAaG,aAE/D,GAAIsT,EAAkB,CAClBlB,EAAckB,EAAiBptB,OAAS,EACxC,IAAMqtB,EAAc,IAAIpiB,aAA2B,EAAdihB,GAErC,IAASzqB,EADK,EACYA,EAAIyqB,IAAezqB,EAAG,CAE5C,IAAM6rB,EAAkB,EAAA7V,QAAQ+S,UAAU4C,EAAsB,EAAJ3rB,GAC5D2Z,EAAiBkS,GAGjB,IAAMC,EAAe,EAAA9V,QAAQ+S,UAAU0C,EAAmB,EAAJzrB,GACtD2Z,EAAiBmS,GAEjBA,EAAad,cAAca,EAAiBrB,GAC5CoB,EAAgB,EAAJ5rB,GAASwqB,EAAW3Q,EAAI0Q,EACpCqB,EAAgB,EAAJ5rB,EAAQ,GAAKwqB,EAAWtmB,EACpC0nB,EAAgB,EAAJ5rB,EAAQ,GAAKwqB,EAAW1Q,CACxC,CACMhF,EAAamO,EAAcjO,iBAAiB4W,EAAaX,IACzD9K,EAAW8C,EAAclD,eAAejL,EAAY,OAAF,KAAkD2V,EAAa,GACvHvH,EAAU7kB,KAAK8hB,GACfvc,EAAO0mB,WAAoB,QAAIpH,EAAU3kB,OAAS,CACtD,MACI,EAAAuC,MAAMC,KAAK,yCAAkCvC,EAAKE,KAAI,+DAE9D,CAEA,GAAIunB,EAAY8F,UAAW,CACvB,IAAMC,EAAc/F,EAAYgG,YAC1BC,EAAiB9sB,EAASE,gBAAgB,EAAA4Y,aAAaI,WACvDjS,EAASjH,EAAS+sB,gBAAgB,EAAAjU,aAAaI,WAErD,GAAI4T,GAAkB7lB,EAAQ,CAC1B,IAAM+lB,EAAgB/lB,EAAOiG,UAE7Bme,EAAcyB,EAAe3tB,OAAS6tB,EACtC,IAAMC,EAAY,IAAI7iB,aAAaihB,EAAc2B,GAEjD,IAASpsB,EADK,EACYA,EAAIyqB,IAAezqB,EACzC,GAAsB,IAAlBosB,EAAqB,CACrB,IAAME,EAAgB,EAAAtW,QAAQ+S,UAAUmD,EAAgBlsB,EAAIosB,GACzC,EAAApW,QAAQ+S,UAAUiD,EAAahsB,EAAIosB,GAE3CpB,cAAcsB,EAAe9B,GACxC6B,EAAc,EAAJrsB,GAASwqB,EAAW3Q,EAC9BwS,EAAc,EAAJrsB,EAAQ,GAAKwqB,EAAWtmB,EAClCmoB,EAAc,EAAJrsB,EAAQ,GAAKwqB,EAAW1Q,CACtC,MAAO,GAAsB,IAAlBsS,EAAqB,CAC5B,IAAMG,EAAc,IAAI,EAAAC,QAClBF,EAAgB,EAAAE,QAAQzD,UAAUmD,EAAgBlsB,EAAIosB,GACzC,EAAAI,QAAQzD,UAAUiD,EAAahsB,EAAIosB,GAE3CpB,cAAcsB,EAAeC,GACxCF,EAAc,EAAJrsB,GAASusB,EAAY1S,EAC/BwS,EAAc,EAAJrsB,EAAQ,GAAKusB,EAAYroB,EACnCmoB,EAAc,EAAJrsB,EAAQ,GAAKusB,EAAYzS,EACnCuS,EAAc,EAAJrsB,EAAQ,GAAKusB,EAAY5e,CACvC,MACI,EAAA7M,MAAMC,KAAK,gEAAyDqrB,IAGtEtX,EAAamO,EAAcjO,iBAAiBqX,EAxIxC,EAwI+DD,GACnEjM,EAAW8C,EAAclD,eAAejL,EAA8B,IAAlBsX,EAAsB,OAAoB,OAAmB,KAA6B3B,EAAa,GACjKvH,EAAU7kB,KAAK8hB,GACfvc,EAAO0mB,WAAoB,QAAIpH,EAAU3kB,OAAS,CACtD,MACI,EAAAuC,MAAMC,KAAK,uCAAgCvC,EAAKE,KAAI,6DAE5D,CAEA,OAAOkF,CACX,CCzGA,kBAqBI,WAAmB6hB,EAA+BgH,GAnB1C,KAAAC,oBAAsB,IAAI9iB,IAG1B,KAAA+iB,qBAAuB,IAAI/iB,IAG3B,KAAAgjB,mBAAqB,IAAIhjB,IAEzB,KAAAijB,oBAAsB,IAAIjjB,IAE1B,KAAAkjB,oBAAsB,IAAIljB,IAE1B,KAAAmjB,qBAAuB,IAAInjB,IAE3B,KAAAojB,eAAiB,IAAI5H,IAGrB,KAAA6H,SAAW,IAAIrjB,IAYP,KAAAsjB,8BAAgC,IAAItjB,IAThD7N,KAAK0pB,qBAAuBA,EAC5B1pB,KAAK0wB,mBAAqBA,CAC9B,CAmHJ,OA1GW,YAAAU,mBAAP,SAA0B3sB,EAAiC4sB,EAAexV,EAAehK,EAAgByf,G,YACrG,OAAiF,QAA1E,EAA6D,QAA7D,EAAiD,QAAjD,EAAqC,QAArC,EAAAtxB,KAAK2wB,oBAAoB5vB,IAAI0D,UAAQ,eAAE1D,IAAIswB,UAAM,eAAEtwB,IAAI8a,UAAM,eAAE9a,IAAI8Q,UAAO,eAAE9Q,IAAIuwB,EAC3F,EAEO,YAAAC,mBAAP,SAA0B9sB,EAAiC4sB,EAAexV,EAAehK,EAAgByf,EAAeE,GACpH,IAAIC,EAAOzxB,KAAK2wB,oBAAoB5vB,IAAI0D,GACnCgtB,IACDA,EAAO,IAAI5jB,IACX7N,KAAK2wB,oBAAoB1Y,IAAIxT,EAASgtB,IAG1C,IAAIC,EAAOD,EAAK1wB,IAAIswB,GACfK,IACDA,EAAO,IAAI7jB,IACX4jB,EAAKxZ,IAAIoZ,EAAOK,IAGpB,IAAIC,EAAOD,EAAK3wB,IAAI8a,GACf8V,IACDA,EAAO,IAAI9jB,IACX6jB,EAAKzZ,IAAI4D,EAAO8V,IAGpB,IAAIC,EAAOD,EAAK5wB,IAAI8Q,GACf+f,IACDA,EAAO,IAAI/jB,IACX8jB,EAAK1Z,IAAIpG,EAAQ+f,IAGrBA,EAAK3Z,IAAIqZ,EAAME,EACnB,EAEO,YAAAK,iBAAP,SAAwBvX,GACfta,KAAKixB,eAAevM,IAAIpK,IACzBta,KAAKixB,eAAehiB,IAAIqL,EAEhC,EAEO,YAAAwX,YAAP,WACI,OAAO9xB,KAAKixB,cAChB,EAEO,YAAAc,oBAAP,SAA2BznB,GACvB,OAAOtK,KAAK4wB,qBAAqB7vB,IAAIuJ,EACzC,EAEO,YAAA0nB,oBAAP,SAA2B1nB,EAAgByO,GACvC/Y,KAAK4wB,qBAAqB3Y,IAAI3N,EAAQyO,EAC1C,EAEO,YAAAkZ,sBAAP,SAA6B3nB,EAAgB6Q,EAA4BpC,GACrE/Y,KAAK8wB,oBAAoB7Y,IAAI3N,EAAQ,IAAIuD,KACzC7N,KAAK8wB,oBAAoB/vB,IAAIuJ,GAAS2N,IAAIkD,EAAcpC,EAC5D,EAEO,YAAAmZ,sBAAP,SAA6B5nB,EAAgB6Q,G,MACzC,OAA2C,QAApC,EAAAnb,KAAK8wB,oBAAoB/vB,IAAIuJ,UAAO,eAAEvJ,IAAIoa,EACrD,EAEO,YAAAgX,kBAAP,SAAyBhX,EAA4BkW,EAAexV,G,QAChE,OAA4D,QAArD,EAAyC,QAAzC,EAAA7b,KAAK6wB,mBAAmB9vB,IAAIoa,UAAa,eAAEpa,IAAIswB,UAAM,eAAEtwB,IAAI8a,EACtE,EAEO,YAAAuW,kBAAP,SAAyBjX,EAA4BkW,EAAexV,EAAe2V,GAC/E,IAAIC,EAAOzxB,KAAK6wB,mBAAmB9vB,IAAIoa,GAClCsW,IACDA,EAAO,IAAI5jB,IACX7N,KAAK6wB,mBAAmB5Y,IAAIkD,EAAcsW,IAG9C,IAAIC,EAAOD,EAAK1wB,IAAIswB,GACfK,IACDA,EAAO,IAAI7jB,IACX4jB,EAAKxZ,IAAIoZ,EAAOK,IAGpBA,EAAKzZ,IAAI4D,EAAO2V,EACpB,EAEO,YAAAa,oBAAP,SAA2BlX,GACvB,OAAOnb,KAAKgxB,qBAAqBjwB,IAAIoa,KAAiB,CAC1D,EAEO,YAAAmX,uBAAP,SAA8BnX,EAA4B7I,GACtD,OAAOtS,KAAKgxB,qBAAqB/Y,IAAIkD,EAAc7I,EACvD,EAEO,YAAAigB,QAAP,SAAe9vB,GACX,OAAOzC,KAAKkxB,SAASnwB,IAAI0B,EAC7B,EAEO,YAAA+vB,QAAP,SAAe/vB,EAAoBgwB,GAC/BzyB,KAAKkxB,SAASjZ,IAAIxV,EAAMgwB,EAC5B,EAEO,YAAAC,oBAAP,SAA2BjwB,EAAoBkwB,GAC3C,IAAMC,EAAe5yB,KAAK+wB,oBAAoBhwB,IAAI0B,IAAS,GAC3DzC,KAAK+wB,oBAAoB9Y,IAAIxV,EAAMmwB,IACM,IAArCA,EAAaC,QAAQF,IACrBC,EAAatwB,KAAKqwB,EAE1B,EAEO,YAAAG,wBAAP,SAA+BrwB,GAC3B,OAAOzC,KAAK+wB,oBAAoBhwB,IAAI0B,EACxC,EACJ,EA3IA,GA8IA,cAwLI,WAAmBomB,EAA8DkK,GAC7E,QADe,IAAAlK,IAAAA,EAAgC,EAAAmK,YAAYC,kBAvL/C,KAAAC,MAAe,CAC3BC,MAAO,CAAE9rB,UAAW,sBAAe,EAAA+rB,OAAOC,SAAWC,QAAS,QAGlD,KAAAC,YAA4B,GAC5B,KAAAC,WAA0B,GAC1B,KAAAC,aAA8B,GAC9B,KAAAC,SAAsB,GACtB,KAAA7a,QAAoB,GACpB,KAAApJ,WAA0B,GAC1B,KAAAkkB,QAAmB,GACnB,KAAAC,OAAkB,GAClB,KAAA9Z,UAAwB,GACxB,KAAA+Z,QAAoB,GACpB,KAAAC,OAAkB,GAClB,KAAAnd,UAAwB,GAGxB,KAAA+C,WAAqF,CAAC,EAS/F,KAAAZ,eAAyB,EAEhB,KAAAib,kBAAoB,IAAIC,EAAqBh0B,MAE5C,KAAAi0B,YAA4D,CAAC,EAE9D,KAAAjb,eAAiB,IAAIkb,GAEpB,KAAAC,qBAAuB,IAAItmB,IAG3B,KAAAumB,SAAW,IAAIvmB,IAGhB,KAAAwmB,aAAe,IAAIxmB,IAClB,KAAAymB,YAAc,IAAIzmB,IAClB,KAAA0mB,gBAAkB,IAAI1mB,IACtB,KAAA2mB,SAAW,IAAI3mB,IACf,KAAA4mB,cAAgB,IAAI5mB,IAGrB,KAAAmB,qBAAuB,IAAIqa,KAwIlCR,EACD,MAAM,IAAInb,MAAM,gCAGpB1N,KAAK00B,cAAgB7L,EAErB7oB,KAAK20B,SAAW,GACZC,iBAAkB,WAAM,UACxBvN,sBAAuB,WAAM,UAC7BwN,iBAAkB,SAACC,GAAQ,MAAK,OAAc,QAAd,EAAAA,aAAQ,EAARA,EAAUC,YAAI,eAAEC,MAAM,EACtD7P,oBAAqB,EAAI,GACzB8P,8BAA8B,EAC9BC,iBAAiB,EACjBC,qBAAqB,EACrBC,wCAAwC,EACxCC,sBAAuB,QACpBtC,GAGP/yB,KAAKs1B,iBACT,CAylCJ,OA/uCY,YAAAC,gBAAR,SACIjb,EACA5C,EACA3I,EACAymB,GAJJ,WAMI,GAAIzmB,GAAS2I,EAAWlV,OACpB,OAAO8E,QAAQC,QAAQ+S,GAG3B,IAAMmb,EAAiBD,EAAY9d,EAAW3I,GAAQuL,GAEtD,OAAKmb,EAKEA,EAAe1tB,MAAK,SAAO2tB,GAAO,sE,8BAAMA,EAAU,GAAM11B,KAAKu1B,gBAAgBG,EAAShe,EAAY3I,EAAQ,EAAGymB,IAArE,M,cAAU,W,aAA0E,O,iBAArF,Y,UAJnCx1B,KAAKu1B,gBAAgBjb,EAAM5C,EAAY3I,EAAQ,EAAGymB,EAKjE,EAGQ,YAAAG,iBAAR,SAA4Brb,EAASkb,GAEjC,IADA,IAAM9d,EAAyC,GAC5B,MAAAke,EAAaC,gBAAb,eAA8B,CAA5C,IAAM,EAAI,KACXne,EAAWpV,KAAKtC,KAAKi0B,YAAY,GACrC,CAEA,OAAOj0B,KAAKu1B,gBAAgBjb,EAAM5C,EAAY,EAAG8d,EACrD,EAGO,YAAAM,+BAAP,SAAsCC,EAAiBzb,EAAagF,EAAmB0H,EAA4B0C,GAAnH,WACI,OAAO1pB,KAAK21B,iBACRrb,GAEA,SAACjB,EAAWiB,GAAS,OAAAjB,EAAU2c,qBAAuB3c,EAAU2c,oBAAoBD,EAASzb,EAAMgF,EAAa0H,EAAS0C,EAAsB,EAAK1Q,eAA/H,GAE7B,EAGO,YAAAnJ,mCAAP,SAA0CkmB,EAAiB5yB,EAAqBuJ,GAE5E,OAAO1M,KAAK21B,iBAAiBxyB,GAAU,SAACkW,EAAWiB,GAAS,OAAAjB,EAAU4c,yBAA2B5c,EAAU4c,wBAAwBF,EAASzb,EAAM5N,EAAtF,GAChE,EAEO,YAAAiD,gDAAP,SAAuDomB,EAAiB5yB,EAAqBuJ,GAGzF,IAFA,IAAMvK,EAAwB,GAEX,MAAAyzB,EAAaC,gBAAb,eAA8B,CAA5C,IAAM,EAAI,KACLxc,EAAYrZ,KAAKi0B,YAAY,GAE/B5a,EAAU6c,sCACV/zB,EAAOG,KAAI,MAAXH,EAAekX,EAAU6c,qCAAqCH,EAAS5yB,EAAUuJ,GAEzF,CAEA,OAAOvK,CACX,EAEO,YAAA+V,8BAAP,SAAqC6d,EAAiBvnB,EAA2BvE,GAC7E,IAAmB,UAAA2rB,EAAaC,gBAAb,eAA8B,CAA5C,IAAM,EAAI,KACLxc,EAAYrZ,KAAKi0B,YAAY,GAE/B5a,EAAU8c,mBACV9c,EAAU8c,kBAAkBJ,EAASvnB,EAAavE,EAE1D,CACJ,EAEO,YAAAmsB,mCAAP,SAA0CC,GACtC,IAAmB,UAAAT,EAAaC,gBAAb,eAA8B,CAA5C,IAAM,EAAI,KACLxc,EAAYrZ,KAAKi0B,YAAY,GAE/B5a,EAAUid,yBACVjd,EAAUid,wBAAwBD,EAAWr2B,KAAKgZ,eAAgBhZ,KAAKwzB,WAE/E,CACJ,EAEa,YAAA+C,kCAAb,W,0GACuB,EAAAX,EAAaC,gB,wBAAb,YAAd,QACKxc,EAAYrZ,KAAKi0B,YAAY,IAErBuC,uBAEV,GAAMnd,EAAUmd,uBAAuBx2B,KAAKgZ,iBAF5C,OAHuC,M,OAKvC,S,wBALW,I,+BAUf,YAAAyd,mBAAR,SAA2BC,GACvB,IAAmB,UAAAd,EAAaC,gBAAb,eAA8B,CAA5C,IAAM,EAAI,KACLxc,EAAYrZ,KAAKi0B,YAAY,GAC/B5a,EAAUsd,SACVD,EAAOrd,EAEf,CACJ,EAEQ,YAAAud,uBAAR,sBACI52B,KAAKy2B,oBAAmB,SAACpd,G,UACjBA,EAAUwd,WACV,IAAK3D,OAAM4D,iBAAc,EAAdA,eAAmB,KAC6B,IAAvD,EAAK5D,MAAM4D,eAAejE,QAAQxZ,EAAU1W,OAC5C,EAAKuwB,MAAM4D,eAAex0B,KAAK+W,EAAU1W,MAGzC0W,EAAU0d,YACV,IAAK7D,OAAM8D,qBAAkB,EAAlBA,mBAAuB,KAC6B,IAA3D,EAAK9D,MAAM8D,mBAAmBnE,QAAQxZ,EAAU1W,OAChD,EAAKuwB,MAAM8D,mBAAmB10B,KAAK+W,EAAU1W,QAIrD,IAAKuwB,OAAMxb,aAAU,EAAVA,WAAe,CAAC,GACvB2B,EAAU4d,aACV5d,EAAU4d,cAGtB,GACJ,EAEQ,YAAA3B,gBAAR,WACI,IAAmB,UAAAM,EAAaC,gBAAb,eAA8B,CAA5C,IAAM,EAAI,KACLxc,EAAYuc,EAAasB,oBAAoB,GAAMl3B,MACzDA,KAAKi0B,YAAY,GAAQ5a,CAC7B,CACJ,EAyBO,YAAA8d,QAAP,WACI,IAAK,IAAMz2B,KAAOV,KAAKi0B,YACDj0B,KAAKi0B,YAAYvzB,GACzBy2B,SAElB,EAEA,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK20B,QAChB,E,gCAEc,EAAAyC,kBAAd,SAAgCz0B,EAAcnD,GACtCo2B,EAAayB,oBAAoB10B,IACjC,EAAAoC,MAAMC,KAAK,kCAA2BrC,EAAI,oBAG9CizB,EAAasB,oBAAoBv0B,GAAQnD,EACzCo2B,EAAaC,gBAAgBvzB,KAAKK,EACtC,EAEc,EAAA00B,oBAAd,SAAkC10B,GAC9B,IAAKizB,EAAasB,oBAAoBv0B,GAClC,OAAO,SAEJizB,EAAasB,oBAAoBv0B,GAExC,IAAMoM,EAAQ6mB,EAAaC,gBAAgBhD,QAAQlwB,GAKnD,OAJe,IAAXoM,GACA6mB,EAAaC,gBAAgByB,OAAOvoB,EAAO,IAGxC,CACX,EAEQ,YAAAwoB,cAAR,SAAsBC,EAA0BC,EAAmBC,GAC/D,IAAMptB,EAAkB,CAAES,WAAYysB,GA+CtC,OA7CIltB,EAAOS,aACP/K,KAAKkzB,MAAMyE,QAAU,CAACrtB,IAEtBtK,KAAK4zB,QAAU5zB,KAAK4zB,OAAOpxB,SAC3BxC,KAAKkzB,MAAMjM,MAAQjnB,KAAK4zB,QAExB5zB,KAAK2zB,SAAW3zB,KAAK2zB,QAAQnxB,SAC7BxC,KAAKkzB,MAAMnxB,OAAS/B,KAAK2zB,SAEzB3zB,KAAK6zB,SAAW7zB,KAAK6zB,QAAQrxB,SAC7BxC,KAAKkzB,MAAM0E,OAAS53B,KAAK6zB,QACzB7zB,KAAKkzB,MAAM/lB,MAAQ,GAEnBnN,KAAK0zB,UAAY1zB,KAAK0zB,SAASlxB,SAC/BxC,KAAKkzB,MAAM2E,QAAU73B,KAAK0zB,UAE1B1zB,KAAKyzB,cAAgBzzB,KAAKyzB,aAAajxB,SACvCxC,KAAKkzB,MAAM5P,YAActjB,KAAKyzB,cAE9BzzB,KAAKwzB,YAAcxzB,KAAKwzB,WAAWhxB,SACnCxC,KAAKkzB,MAAM/L,UAAYnnB,KAAKwzB,YAE5BxzB,KAAKuzB,aAAevzB,KAAKuzB,YAAY/wB,SACrCxC,KAAKkzB,MAAM3L,WAAavnB,KAAKuzB,aAE7BvzB,KAAKyP,YAAczP,KAAKyP,WAAWjN,SACnCxC,KAAKkzB,MAAMlxB,UAAYhC,KAAKyP,YAE5BzP,KAAK2W,WAAa3W,KAAK2W,UAAUnU,SACjCxC,KAAKkzB,MAAMxjB,SAAW1P,KAAK2W,WAE3B3W,KAAK8Z,WAAa9Z,KAAK8Z,UAAUtX,SACjCxC,KAAKkzB,MAAMrZ,SAAW7Z,KAAK8Z,WAE3B9Z,KAAK8zB,QAAU9zB,KAAK8zB,OAAOtxB,SAC3BxC,KAAKkzB,MAAM4E,MAAQ93B,KAAK8zB,QAExB9zB,KAAK6Y,SAAW7Y,KAAK6Y,QAAQrW,SAC7BxC,KAAKkzB,MAAMta,OAAS5Y,KAAK6Y,SAGxB7Y,KAAK8Y,gBACNxO,EAAOkP,IAAMie,EAAW,QAGrBC,EAAcK,KAAKC,UAAUh4B,KAAKkzB,MAAO,KAAM,GAAK6E,KAAKC,UAAUh4B,KAAKkzB,MACnF,EAEa,YAAA+E,kBAAb,SAA+BC,G,4GACN,SAAMl4B,KAAKm4B,wB,OAchC,GAdMC,EAAe,SACrBp4B,KAAK42B,yBACCyB,EAAWr4B,KAAKu3B,cAAca,EAAartB,WAAYmtB,GAAY,GAEnEI,EAAM,IAAIjyB,KAAK,CAAC+xB,GAAe,CAAE9xB,KAAM,6BAEvCiyB,EAAeL,EAAa,QAC5BM,EAAcN,EAAa,QAE3BO,EAAY,IAAIC,GAEZxyB,MAAMqyB,GAAgBF,EAChCI,EAAUvyB,MAAMsyB,GAAeF,EAE3Bt4B,KAAK0Z,WACL,IAAWf,KAAS3Y,KAAK0Z,WACrB+e,EAAUvyB,MAAMyS,GAAS,IAAItS,KAAK,CAACrG,KAAK0Z,WAAWf,GAAOhO,MAAO,CAAErE,KAAMtG,KAAK0Z,WAAWf,GAAOnO,WAIxG,MAAO,CAAP,EAAOiuB,G,QAGG,YAAAN,qBAAd,W,0FACI,SAAMn4B,KAAK24B,qB,OACX,OADA,SACA,GAAM34B,KAAKu2B,qC,OACX,OADA,SACO,CAAP,EAAOv2B,KAAKgZ,eAAeqK,eAAerjB,KAAKyzB,e,QAQ3C,YAAAmF,YAAR,SAAoBC,GAChB,IAAMC,EAAYD,EAAM,EAGxB,OAF8B,IAAdC,EAAkBA,EAAY,EAAIA,CAGtD,EAEa,YAAAC,iBAAb,SAA8Bb,G,0HAEL,OADrBl4B,KAAK8Y,eAAgB,EACA,GAAM9Y,KAAKm4B,wB,OAgChC,GAhCMC,EAAe,SACrBp4B,KAAK42B,yBACCyB,EAAWr4B,KAAKu3B,cAAca,EAAartB,YAE3CiuB,EAAcd,EAAa,OAG7Be,EAAaZ,EAAS71B,OAGC,oBAAhB02B,cACDC,EAAU,IAAID,YACpBE,EAAkBD,EAAQE,OAAOhB,GACjCY,EAAaG,EAAgB52B,QAE3B82B,EAAct5B,KAAK44B,YAAYK,GAC/BM,EAAav5B,KAAK44B,YAAYR,EAAartB,YAE3CA,EAAayuB,GAAuCP,EAAaK,EAAclB,EAAartB,WAAawuB,GAEzG9V,EAAa,IAAIC,EAAW3Y,IAGvB4X,YAAY,YACvBc,EAAWd,YAAY,GACvBc,EAAWd,YAAY5X,GAGvB0Y,EAAWd,YAAYsW,EAAaK,GACpC7V,EAAWd,YAAY,YAGnByW,EAEA3V,EAAW1B,gBAAgBqX,QAG3B,IADMK,EAAgB,IAAIC,WAAW,GAC5Bz1B,EAAI,EAAGA,EAAIg1B,IAAch1B,GACxB01B,EAAWtB,EAASqB,WAAWz1B,KAErBo0B,EAASuB,YAAY31B,GACjCwf,EAAWpB,WAAWoX,GAEtBhW,EAAWpB,WAAWsX,GAMlC,IAAS11B,EAAI,EAAGA,EAAIq1B,IAAer1B,EAC/Bwf,EAAWpB,WAAW,IAW1B,IAPAoB,EAAWd,YAAYyV,EAAartB,WAAawuB,GACjD9V,EAAWd,YAAY,SAGvBc,EAAW1B,gBAAgBqW,GAGlBn0B,EAAI,EAAGA,EAAIs1B,IAAct1B,EAC9Bwf,EAAWpB,WAAW,GAM1B,OAHMoW,EAAY,IAAIC,GACZxyB,MAAM8yB,GAAe,IAAI3yB,KAAK,CAACod,EAAWrB,iBAAkB,CAAE9b,KAAM,6BAEvE,CAAP,EAAOmyB,G,QAGH,YAAAoB,uBAAR,SAA+Bvf,EAAayK,EAAqC2E,G,MAK7E,GAJK3E,EAAqB+U,gBAAgBxqB,kBAAkBuL,EAAoB,EAAAnR,UAC5E,EAAA3E,MAAMC,KAAK,0DAGV+f,EAAqB4I,SAASre,kBAAkBuL,EAAoB,EAAAnR,SAAU,CAC/E,IAAMqV,EAAc,EAAApE,WAAWV,QAAQ,GAAG8f,SAAShV,EAAqB4I,UACpEjE,GACA1L,EAA6Be,GAGjCzE,EAAKyE,YAAcA,EAAYxP,SACnC,CAEKwV,EAAqBnF,QAAQtQ,kBAAkByL,EAAc,EAAArR,WAC9D4Q,EAAKrO,MAAQ8Y,EAAqBnF,QAAQrQ,WAG9C,IAAMme,GACqC,QAAvC,EAAA3I,EAAqB2I,0BAAkB,eAAEsM,UACzC,EAAA9f,WAAW+f,gBAAgBlV,EAAqBtG,SAASX,EAAGiH,EAAqBtG,SAAStW,EAAG4c,EAAqBtG,SAASV,GAE1H2P,EAAmBpe,kBAAkBwL,EAAiB,EAAApR,WACnDggB,GACAzL,EAA6ByP,GAGjCpT,EAAKmE,SAAWiP,EAAmBT,YAAY1d,UAEvD,EAEQ,YAAA2qB,yBAAR,SAAiC5f,EAAa6f,EAA6BzQ,GACvE,IAAKyQ,EAAcxM,SAASre,kBAAkBuL,EAAoB,EAAAnR,SAAU,CACxE,IAAMqV,EAAc,EAAApE,WAAWV,QAAQ,GAAG8f,SAASI,EAAcxM,UAC7DjE,GACA1L,EAA6Be,GAEjCzE,EAAKyE,YAAcA,EAAYxP,SACnC,CAEA,IAAMme,EAAqByM,EAAczM,oBAAsB,EAAAxT,WAAW+f,gBAAgBE,EAAc1b,SAASX,EAAGqc,EAAc1b,SAAStW,EAAGgyB,EAAc1b,SAASV,GAEjK2L,GACAzL,EAA6ByP,GAM5B1tB,KAAK00B,cAAc1wB,sBACpBwa,EAAWkP,GAGVA,EAAmBpe,kBAAkBwL,EAAiB,EAAApR,WACvD4Q,EAAKmE,SAAWiP,EAAmBne,UAE3C,EAGQ,YAAA6qB,sBAAR,WACI,IAAqB,UAAAp6B,KAAK00B,cAAcmD,QAAnB,eAA4B,CAA5C,IAAMwC,EAAM,KACPC,EAAsB,CACxBh0B,KAAM+zB,EAAOE,OAAS,EAAA3V,OAAO4V,mBAAqB,cAAyB,gBAO/E,GAJIH,EAAO13B,OACP23B,EAAW33B,KAAO03B,EAAO13B,MAGL,gBAApB23B,EAAWh0B,KACXg0B,EAAWG,YAAc,CACrBC,YAAaL,EAAOtuB,YAAY4uB,eAAeN,GAC/CO,KAAMP,EAAOQ,UAAY,EAAAjW,OAAOkW,uBAAyBT,EAAOU,IAAMV,EAAOU,IAAMV,EAAOtuB,YAAY4uB,eAAeN,GACrHW,MAAOX,EAAOY,KACdC,KAAMb,EAAOc,WAEd,GAAwB,iBAApBb,EAAWh0B,KAAkC,CACpD,IAAM80B,EAAYf,EAAOgB,WAAahB,EAAOiB,WAAa,IAAOjB,EAAOiB,WAAajB,EAAOgB,WAAmD,GAAtChB,EAAOtuB,YAAYwvB,iBACtHC,EAAanB,EAAOoB,aAAepB,EAAOqB,SAAW,IAAOrB,EAAOqB,SAAWrB,EAAOoB,aAAsD,GAAvCpB,EAAOtuB,YAAY4vB,kBAC7HrB,EAAWsB,aAAe,CACtBC,KAAMT,EACNU,KAAMN,EACNR,MAAOX,EAAOY,KACdC,KAAMb,EAAOc,KAErB,CACAn7B,KAAKs0B,YAAYrc,IAAIoiB,EAAQC,EACjC,CACJ,EAGQ,YAAAyB,wBAAR,WAEI,IADA,IACyB,MADLzyB,MAAMJ,KAAKlJ,KAAKs0B,YAAY0H,UACvB,eAAa,CAAjC,IAAMC,EAAU,KACXC,EAAYl8B,KAAKu0B,gBAAgBxzB,IAAIk7B,GAC3C,QAAkB37B,IAAd47B,EAAyB,CACzBl8B,KAAK0zB,SAASpxB,KAAK25B,GACnB,IAAmB,UAAAC,EAAA,eAAJ,KACN7B,OAASr6B,KAAK0zB,SAASlxB,OAAS,CAE7C,CACJ,CACJ,EAGQ,YAAA25B,wBAAR,WACI,IAAuB,UAAAn8B,KAAK00B,cAAc0H,UAAnB,eAA8B,CAAhD,IAAMC,EAAQ,KACXA,EAASC,MAAM95B,QAAU,GAK7BxC,KAAKw0B,SAASvc,IAAIokB,EADE,CAAEE,OAAQ,IAElC,CACJ,EAEQ,YAAAC,0BAAR,SAAkCC,GAC9B,I,iBAAWJ,GACP,GAAIA,EAASC,MAAM95B,QAAU,E,iBAI7B,IAAMk6B,EAAO,EAAKlI,SAASzzB,IAAIs7B,GAC/B,GAAY/7B,MAARo8B,E,iBAQJ,IAFA,IAAMC,EAA0C,CAAC,EAC7CC,GAAgB,EACX34B,EAAI,EAAGA,EAAIo4B,EAASC,MAAM95B,SAAUyB,EAAG,CAC5C,IAAM44B,EAAOR,EAASC,MAAMr4B,IAET,KADb64B,EAA2B,QAAf,EAAAD,EAAKE,kBAAU,QAAI94B,KAEjC04B,EAAaG,GAAaD,EACtBC,EAAYF,IACZA,EAAeE,GAG3B,CAIA,IADA,ILnkBwC3d,EKmkBlC6d,EAAgC,GAC7BF,EAAY,EAAGA,GAAaF,IAAgBE,EAAW,CAC5D,IACMG,GADAJ,EAAOF,EAAaG,IACCI,mBACrBhS,EAAY+R,EAAgB,EAAK7I,SAASrzB,IAAIk8B,QAAiB38B,EACrE,QAAkBA,IAAd4qB,EAAJ,CAIAwR,EAAKH,OAAOj6B,KAAK4oB,GAEjB,IAAMiS,EAAaN,EAAKO,+BAA+BpD,QACnDyC,EAAc/X,IAAIuY,KL/kBc9d,EKglBIge,EL/kBpDpjB,EAAwB/W,YAAY,EAAA2X,WAAW5X,OAAO,IAAI2X,cAAcyE,EAAQA,GAAQzE,cAAcX,EAAyBoF,IKilBnH6d,EAAoB16B,KAAK66B,EAPzB,MAFI,EAAAp4B,MAAMC,KAAK,6EAUnB,CAGA,IAAMq4B,EAAe,EAAK5I,cAAc1zB,IAAI27B,GAG5C,GAAIA,EAAKH,OAAO/5B,OAAS,QAAsBlC,IAAjB+8B,EAA4B,CACtD,IAAM,EAA0B,IAAI5vB,aAA0C,GAA7BuvB,EAAoBx6B,QACrEw6B,EAAoBxZ,SAAQ,SAACtgB,EAAa6L,GACtC,EAAwBkJ,IAAI/U,EAAIiC,EAAW,GAAR4J,EACvC,IAEA,IAAMgK,EAAa,EAAKC,eAAeC,iBAAiB,GACxD,EAAKua,WAAWlxB,KAAK,EAAK0W,eAAegL,eAAejL,EAAY,OAAF,KAAkDikB,EAAoBx6B,SACxIk6B,EAAKM,oBAAsB,EAAKxJ,WAAWhxB,OAAS,EAEpD,EAAKsxB,OAAOxxB,KAAKo6B,GAEjB,IADA,IAAMY,EAAY,EAAKxJ,OAAOtxB,OAAS,EACb,MAAA66B,EAAA,eAAJ,KACNX,KAAOY,CAE3B,C,SA/DmB,MAAAt9B,KAAK00B,cAAc0H,UAAnB,e,EAAJ,KAiEvB,EAEc,YAAAzD,kBAAd,W,4IAoBI,IAnBMxrB,EAAgB,CAAE8Z,MAAO,IAG3BjnB,KAAK00B,cAAcI,WACbE,EAASh1B,KAAK20B,SAASE,iBAAiB70B,KAAK00B,cAAcI,aAE7D3nB,EAAM6nB,OAASA,GASjBuI,EAAc,IAAIj0B,MAClBk0B,EAAc,IAAIl0B,MAClBm0B,EAAkB,IAAIn0B,MAEvB,EAAL,EAAuB,EAAAtJ,KAAK00B,cAAcgJ,UAAnB,eAAZC,EAAQ,KACX39B,KAAK20B,SAASQ,sBAAwBn1B,KAAK20B,SAASS,wCAA0C/a,EAAWsjB,EAAU39B,KAAK00B,cAAc1wB,sBACtIy5B,EAAgBn7B,KAAI,MAApBm7B,EAAwBE,EAASne,eAC1Bxf,KAAK00B,cAAc1wB,qBAC1Bu5B,EAAYj7B,KAAKq7B,GAEjBH,EAAYl7B,KAAKq7B,GAQJ,OAJrB39B,KAAKo6B,wBACLp6B,KAAKm8B,0BAECyB,EAAU,IAAIC,IAAc,GAAM,G,GACxC,KAAA1wB,EAAM8Z,OAAM3kB,MAAI,M,MAAK,GAAMtC,KAAK89B,kBAAkBN,EAAaI,I,OAE1C,OAFrB,oBAAqB,YACfG,EAAU,IAAIF,IAAc,GAAO,G,GACzC,KAAA1wB,EAAM8Z,OAAM3kB,MAAI,M,MAAK,GAAMtC,KAAK89B,kBAAkBP,EAAaQ,I,OAE1C,OAFrB,oBAAqB,YACfC,EAAS,IAAIH,IAAc,GAAO,G,GACxC,KAAA1wB,EAAM8Z,OAAM3kB,MAAI,M,MAAK,GAAMtC,KAAK89B,kBAAkBL,EAAiBO,I,cAAnE,oBAAqB,YAEjB7wB,EAAM8Z,MAAMzkB,QACZxC,KAAK6zB,QAAQvxB,KAAK6K,GAGtBnN,KAAK+7B,0BACL/7B,KAAKw8B,0BAA0BoB,EAAQ9L,eAEnC9xB,KAAK00B,cAAc1L,gBAAgBxmB,QACnCijB,GAAemD,gDACX5oB,KAAK00B,cACL10B,KAAKuzB,YACLvzB,KAAKo0B,SACLp0B,KAAKgZ,eACLhZ,KAAKyzB,aACLzzB,KAAKwzB,WACLxzB,KAAKi+B,qBACLL,EAAQ9L,cACR9xB,KAAK20B,SAAStN,uB,YAKlB,YAAA6W,kBAAR,SAA0B5e,GACtB,IAAIzX,EAAS7H,KAAKm0B,qBAAqBpzB,IAAIue,GAO3C,YALehf,IAAXuH,IACAA,EAAS7H,KAAK20B,SAASC,iBAAiBtV,GACxCtf,KAAKm0B,qBAAqBlc,IAAIqH,EAAazX,IAGxCA,CACX,EAEc,YAAAi2B,kBAAd,SAAgCK,EAA0B5R,G,sGAChDtF,EAAQ,IAAI3d,MAElBtJ,KAAKo+B,eAAeD,EAAkB5R,G,IAEZ,EAAA4R,E,wBAAA,YAAf7e,EAAW,KAElB,GAAMtf,KAAKq+B,iBAAiB/e,EAAa2H,EAAOsF,KAFV,M,OAEtC,S,wBAFsB,I,aAK1B,MAAO,CAAP,EAAOtF,G,QAGH,YAAAqX,gBAAR,SACIhf,EACAif,EACAC,EACAC,EACAlS,GAEA,GAAIvsB,KAAKk+B,kBAAkB5e,IAAgBA,aAAuB,EAAA1E,cAAgB0E,EAAYjc,SAAU,CACpG,IAAMq7B,EAAgBpf,EAAYjc,SAASs7B,mBAC3C,GAAID,EACA,IAAK,IAAM5iB,KAAQ4iB,EACf,GAAKxiB,EAA0BJ,GAA/B,CAGA,IAAMX,EAAeujB,EAAc5iB,GACnCyQ,EAAM+F,uBAAuBnX,EAAcmE,EAAYsf,gBACvD,IAAMt0B,EAAS6Q,EAAa5Q,QACtBs0B,EAAoBN,EAAyBx9B,IAAIuJ,IAAW,GAClEi0B,EAAyBtmB,IAAI3N,EAAQu0B,IACY,IAA7CA,EAAkBhM,QAAQ1X,IAC1B0jB,EAAkBv8B,KAAK6Y,GAG3B,IAAMpZ,EAASy8B,EAAwBz9B,IAAIoa,IAAiB,GAC5DqjB,EAAwBvmB,IAAIkD,EAAcpZ,IACL,IAAjCA,EAAO8wB,QAAQvT,IACfvd,EAAOO,KAAKgd,EAbhB,CAkBR,IAAMwI,EAAqBxI,EAAYwI,mBAEvC,GAAIA,EACA,IAAK,IAAIgX,EAAa,EAAGA,EAAahX,EAAmBC,WAAY+W,IAAc,CAC/E,IAAM5U,EAAcpC,EAAmBE,UAAU8W,GAE3C/8B,EAAS08B,EAAwB19B,IAAImpB,IAAgB,GAC3DuU,EAAwBxmB,IAAIiS,EAAanoB,IACJ,IAAjCA,EAAO8wB,QAAQvT,IACfvd,EAAOO,KAAKgd,EAEpB,CAER,CAEA,IAA+B,UAAAA,EAAYE,cAAZ,eAA2B,CAArD,IAAMuf,EAAgB,KACvB/+B,KAAKs+B,gBAAgBS,EAAkBR,EAA0BC,EAAyBC,EAAyBlS,EACvH,CACJ,EAEQ,YAAA6R,eAAR,SAAuBD,EAA0B5R,GAK7C,IAJA,IAAMgS,EAA2B,IAAI1wB,IAC/B2wB,EAA0B,IAAI3wB,IAC9BmxB,EAAwB,IAAInxB,IAER,MAAAswB,EAAA,eAAkB,CAAvC,IAAM7e,EAAW,KAClBtf,KAAKs+B,gBAAgBhf,EAAaif,EAA0BC,EAAyBQ,EAAuBzS,EAChH,CAIA,IAFA,IAAMoL,EAAUruB,MAAMJ,KAAKq1B,EAAyB5a,Q,WAEzCrZ,GACP,IAAMK,EAAOL,EAAOma,UACpB,IAAK9Z,EACD,MAAM,IAAI+C,MAAM,gCAGpB,IAAMgxB,EAAgBH,EAAyBx9B,IAAIuJ,GAEnD,IAAKo0B,E,iBAIL,IAAMtjB,EAAasjB,EAAc,GAAGtjB,WACpC,GAAIsjB,EAAcnlB,MAAK,SAAC4B,GAAiB,OAAAA,EAAaC,aAAeA,CAA5B,IACrC,MAAM,IAAI1N,MAAM,6EAMpB,IAHA,IAAMuxB,ELznBX,SAA+Bt0B,GAClC,GAAIA,aAAgBrB,MAAO,CACvB,IAAM41B,EAAY,IAAIzxB,aAAa9C,GACnC,OAAO,IAAIyC,WAAW8xB,EAAU50B,OAAQ40B,EAAUp0B,WAAYo0B,EAAUn0B,WAC5E,CAEA,OAAOH,YAAYC,OAAOF,GAAQ,IAAIyC,WAAWzC,EAAKL,OAAQK,EAAKG,WAAYH,EAAKI,YAAc,IAAIqC,WAAWzC,EACrH,CKknB0Bw0B,CAAsBx0B,GAAMpB,Q,WAG/B4R,GACP,IAAMpZ,EAASy8B,EAAwBz9B,IAAIoa,GACrC,EAA4ED,EAAoBC,EAAcpZ,GAA5G+I,EAAU,aAAE,EAAU,aAAEwQ,EAAc,iBAAEhV,EAAI,OAAEuV,EAAK,QAAER,EAAU,aAEvE,OAF6E,QAIzE,KAAK,EAAAc,aAAaE,WAClB,KAAK,EAAAF,aAAaG,aACd,IAAA8iB,sBAAqBH,EAAOn0B,EAAY,EAAYwQ,EAAgBhV,EAAMuV,EAAOR,GAAY,SAAC2gB,GAC1F,IAAMx5B,EAASkJ,KAAKC,KAAKqwB,EAAO,GAAKA,EAAO,GAAKA,EAAO,GAAKA,EAAO,GAAKA,EAAO,GAAKA,EAAO,IAC5F,GAAIx5B,EAAS,EAAG,CACZ,IAAM68B,EAAY,EAAI78B,EACtBw5B,EAAO,IAAMqD,EACbrD,EAAO,IAAMqD,EACbrD,EAAO,IAAMqD,CACjB,CACJ,IACA,MAGJ,KAAK,EAAAljB,aAAaI,UACd,IAAM+iB,EAAmBv9B,EAAOw9B,QAAO,SAAC98B,GAAS,OAAAA,EAAKU,oBAAoB,EAAAq8B,kBAAqC,MAAjB/8B,EAAKU,QAAlD,IAAoEX,OACrH,GAAwB,GAApB88B,EACA,MAGJ,GAAIA,GAAoBv9B,EAAOS,OAAQ,CACnC,EAAAqd,OAAO7a,KAAK,qIACZ,KACJ,CACIsB,GAAQ,EAAA6V,aAAasjB,eACrB,EAAA5f,OAAO7a,KAAK,+EAGhB,IAAM,EAAc,IAAI,EAAA4E,OAClB,EAAc,IAAI,EAAA81B,OAClB,EAA0B,EAAKhL,cAAc3oB,YAAYC,yBAE/D,IAAAozB,sBAAqBH,EAAOn0B,EAAY,EAAYwQ,EAAgBhV,EAAMuV,EAAOR,GAAY,SAAC2gB,GAEpE,IAAlBA,EAAOx5B,QACP,EAAYm9B,UAAU3D,EAAQ,GAC9B,EAAY4D,mBAAmB,EAAa,GAC5C,EAAYvU,QAAQ2Q,EAAQ,KAE5B,EAAY2D,UAAU3D,EAAQ,GAC9B,EAAY4D,mBAAmB,EAAa,GAC5C,EAAYvU,QAAQ2Q,EAAQ,GAEpC,I,EAjDe,MAAA0C,EAAA,e,EAAhBvjB,EAAY,MAuDvB,GAAIoR,EAAM7C,qBAAsB,CAC5B,IAA2B,UAAAgV,EAAA,eAAe,CAArC,IAEK,EAA4ExjB,EAF3EC,EAAY,KACJqjB,EAAwBz9B,IAAIoa,IACnCrQ,EAAU,aAAE,EAAU,aAAEwQ,EAAc,iBAAEhV,EAAI,OAAEuV,EAAK,QAAER,EAAU,aAEvE,OAFyES,EAAI,QAGzE,KAAK,EAAAK,aAAaC,aAClB,KAAK,EAAAD,aAAaE,WAClB,KAAK,EAAAF,aAAaG,aACd,IAAA8iB,sBAAqBH,EAAOn0B,EAAY,EAAYwQ,EAAgBhV,EAAMuV,EAAOR,GAAY,SAAC2gB,GAC1FA,EAAO,IAAMA,EAAO,EACxB,IAGZ,CAGAzP,EAAM4E,8BAA8BlZ,IAAI3N,EAAQ20B,EACpD,CAGA,IAAMlmB,EAAa,EAAKC,eAAeC,iBAAiBgmB,EAAO7jB,GAC/DmR,EAAMyF,oBAAoB1nB,EAAQyO,GAKlC,IAHA,IAAM8mB,EAAuB,IAAIhyB,IAGN,MAAA6wB,EAAA,eAAe,CAArC,IAEK,EAA0BxjB,EAFzBC,EAAY,KACJqjB,EAAwBz9B,IAAIoa,IACnCW,EAAI,OAAEP,EAAa,gBAC3B,OAAQO,GACJ,KAAK,EAAAK,aAAaK,oBAClB,KAAK,EAAAL,aAAaM,yBACd,GAAItB,EAAa7U,MAAQ,EAAA6V,aAAa2jB,MAAO,CACzC,IAAMZ,EAAY/jB,EAAa4kB,aAAaxkB,GAC1B,OAAd2jB,GACAW,EAAqB5nB,IAAIkD,EAAc+jB,EAE/C,EAGZ,CAEkC,IAA9BW,EAAqBpnB,MACrB,EAAAoH,OAAO7a,KACH,0MAMR,IAFA,IAE2B,MAFKsE,MAAMJ,KAAK22B,EAAqBlc,QAErC,eAAyB,CAA/C,IAAMxI,EAAY,KACb4S,EAAQ8R,EAAqB9+B,IAAIoa,GAEvC,GAAK4S,EAAL,CAMA,IAFA,IAAMiS,EAAiCjS,EL3gCjCxU,MAAK,SAAC1X,GAAU,OAAAA,GAAS,GAAT,IK4gChBo+B,EAAW,IAAKD,EAAU9e,YAAc9T,YAAY2gB,EAAMvrB,QACvDuM,EAAQ,EAAGA,EAAQgf,EAAMvrB,OAAQuM,IACtCkxB,EAASlxB,GAASgf,EAAMhf,GAE5B,IAAM,EAAa,EAAKiK,eAAeC,iBAAiBgnB,EAAU,GAAKD,EAAU,EAAI,IACrFzT,EAAM0F,sBAAsB3nB,EAAQ6Q,EAAc,EARlD,CASJ,C,SA5IiB,MAAAwc,EAAA,e,EAAJ,MAkJjB,IAFA,IAE0B,MAFLruB,MAAMJ,KAAK81B,EAAsBrb,QAE5B,eAAc,CAAnC,IAAMuG,EAAW,KACZnoB,EAASi9B,EAAsBj+B,IAAImpB,GAEzC,GAAKnoB,EAML,IAFA,IAAMm+B,EAAkB5R,GAAwBpE,EAAanoB,EAAO,GAAI/B,KAAKgZ,eAAgBhZ,KAAKyzB,aAAczzB,KAAKwzB,WAAYjH,EAAM7C,sBAEpH,MAAA3nB,EAAA,eAAQ,CAAtB,IAAMU,EAAI,KACX8pB,EAAMmG,oBAAoBjwB,EAAMy9B,EACpC,CACJ,CACJ,EAOc,YAAA7B,iBAAd,SAA+B/e,EAAmB6gB,EAAmC5T,G,qHAEjF,YAAkBjsB,KADd4qB,EAAYlrB,KAAKo0B,SAASrzB,IAAIue,KAEzB6gB,EAAmBC,SAASlV,IAC7BiV,EAAmB79B,KAAK4oB,GAE5B,KAGS,GAAMlrB,KAAKqgC,iBAAiB/gB,EAAaiN,I,QAAhDjS,EAAO,YAGT4Q,EAAYlrB,KAAK4zB,OAAOpxB,OACxBxC,KAAK4zB,OAAOtxB,KAAKgY,GACjBta,KAAKo0B,SAASnc,IAAIqH,EAAa4L,GAC/BqB,EAAMsF,iBAAiBvS,GACvB6gB,EAAmB79B,KAAK4oB,GAGlBpE,EAAmC,CACrCnkB,KAAM,qBACN8kB,SAAU,GACV5N,SAAU,IAERkN,EAAmC,GAEpC/mB,KAAK00B,cAAc1L,gBAAgBxmB,SACpCijB,GAAemC,qDACXtI,EACAwH,EACAC,EACA/mB,KAAKo0B,SACLp0B,KAAK4zB,OACL5zB,KAAKgZ,eACLhZ,KAAKyzB,aACLzzB,KAAKwzB,WACLxzB,KAAKi+B,qBACL1R,EAAM7C,qBACN1pB,KAAK20B,SAAStN,uBAEd/H,EAAYiI,WAAW/kB,QACvBijB,GAAeoB,uCACXvH,EACAwH,EACAC,EACA/mB,KAAKo0B,SACLp0B,KAAK4zB,OACL5zB,KAAKgZ,eACLhZ,KAAKyzB,aACLzzB,KAAKwzB,WACLxzB,KAAKi+B,qBACL1R,EAAM7C,qBACN1pB,KAAK20B,SAAStN,wBAKtBP,EAAqBW,SAASjlB,QAAUskB,EAAqBjN,SAASrX,QACtExC,KAAKuzB,YAAYjxB,KAAKwkB,GAE1BC,EAAmBvD,SAAQ,SAAC8c,GACpBA,EAAkB7Y,SAASjlB,QAAU89B,EAAkBzmB,SAASrX,QAChE,EAAK+wB,YAAYjxB,KAAKg+B,EAE9B,KAIEC,EAAWjmB,EAAO,GAAK6lB,E,IACE,EAAA7gB,EAAYE,c,wBAAZ,YAApBuf,EAAgB,KAEvB,GAAM/+B,KAAKq+B,iBAAiBU,EAAkBwB,EAAUhU,KAFJ,M,OAEpD,S,wBAF2B,I,oBAK3BjS,GAAQimB,EAAS/9B,SACjB8X,EAAKimB,SAAWA,G,YAQV,YAAAF,iBAAd,SAA+B/gB,EAAmBiN,G,sHAC9C,OAAKvsB,KAAKk+B,kBAAkB5e,IAItBhF,EAAc,CAAC,EAEjBgF,EAAY3c,OACZ2X,EAAK3X,KAAO2c,EAAY3c,MAIxB2c,EAAYwV,WACNE,EAASh1B,KAAK20B,SAASE,iBAAiBvV,EAAYwV,aAEtDxa,EAAK0a,OAASA,GAIlB1V,aAAuB,EAAA/E,eACvBva,KAAK65B,uBAAuBvf,EAAMgF,EAAaiN,EAAM7C,sBAEjDpK,aAAuB,EAAA1E,cACjBkP,EAAcxK,aAAuB,EAAAkhB,cAAgBlhB,EAAYmhB,WAAcnhB,GACrEohB,WAAa5W,EAAY4W,UAAUl+B,OAAS,GACxD,EAAA8X,EAAY,GAAMta,KAAK2gC,iBAAiB7W,EAAayC,KADrD,MAFJ,OAHJ,OAjBO,CAAP,EAAO,M,OAuBC,EAAK9pB,KAAO,S,iBAGZ6c,EAAY+c,eAGC/7B,KAFPo8B,EAAO18B,KAAKw0B,SAASzzB,IAAIue,EAAY+c,kBAGF/7B,IAAjCN,KAAKy0B,cAAc1zB,IAAI27B,IACvB18B,KAAKy0B,cAAcxc,IAAIykB,EAAM,IAGL,QAA5B,EAAA18B,KAAKy0B,cAAc1zB,IAAI27B,UAAK,SAAEp6B,KAAKgY,I,iBAMnD,GAAIgF,aAAuB,EAAAK,eACjBsc,EAAaj8B,KAAKs0B,YAAYvzB,IAAIue,IAExB,CASZ,QAR6Chf,IAAzCN,KAAKu0B,gBAAgBxzB,IAAIk7B,IACzBj8B,KAAKu0B,gBAAgBtc,IAAIgkB,EAAY,IAGzCj8B,KAAKk6B,yBAAyB5f,EAAMgF,EAAaiN,EAAM7C,sBAI7B,QADpBnK,EAAoBD,EAAYG,SACJJ,EAAmBC,EAAaC,SAEtCjf,KADlBsgC,EAAkB5gC,KAAKo0B,SAASrzB,IAAIwe,IAKtC,OAHMX,EAAa5e,KAAK4zB,OAAOgN,GAC/BjiB,EAAwBrE,EAAMsE,GACM,QAApC,EAAA5e,KAAKu0B,gBAAgBxzB,IAAIk7B,UAAW,SAAE35B,KAAKsc,GACpC,CAAP,EAAO,MAIqB,QAApC,EAAA5e,KAAKu0B,gBAAgBxzB,IAAIk7B,UAAW,SAAE35B,KAAKgY,EAC/C,CAIkB,SAAMta,KAAK81B,+BAA+B,kBAAmBxb,EAAMgF,EAAatf,KAAKo0B,SAAU7H,EAAM7C,uB,OAC3H,OADsB,SAMf,CAAP,EAAOpP,IAJH,EAAAuF,OAAO7a,KAAK,6BAAsBsa,EAAY3c,OACvC,CAAP,EAAO,O,QAMP,YAAAk+B,eAAR,SACIp8B,EACAq8B,EACAzP,EACAxV,EACAhK,EACAsL,EACA4jB,EACAxU,EACA8J,GAEA,IAAI2K,EAAkBv8B,EAEtB4xB,EAAUkE,KAAOrd,EAAiBC,GAGlC,IAAMmU,EAAOyP,IAAoB,EAAA18B,SAAS48B,iCLjnC3C,SAA4B9jB,GAC/B,OAAQA,GACJ,KAAK,EAAA9Y,SAAS+Y,iBACd,KAAK,EAAA/Y,SAASgZ,sBACd,KAAK,EAAAhZ,SAASiZ,oBACV,OAAO,EAGf,OAAO,CACX,CKwmCqF4jB,CAAmB/jB,GAChG,GAAImU,EAAM,CACN,GAAInU,IAAa,EAAA9Y,SAASgZ,uBAAyBF,IAAa,EAAA9Y,SAASiZ,oBACrE,MAAM,IAAI5P,MAAM,mDAGpB2oB,EAAUkE,KAAOrd,EAAiBC,GAElC,IAAMgkB,EAAaL,EAAW,IAAIxf,YAAYzF,GAAS,IAAIqF,YAAYrF,GAEvE,GAAIpX,EACA,IAAK,IAAIR,EAAI,EAAGA,EAAI,EAAI4X,EAAO5X,GAAK,EAChCk9B,EAAWl9B,GAAKQ,EAAQ4sB,EAAQptB,GAAK4N,EACrCsvB,EAAWl9B,EAAI,GAAKQ,EAAQ4sB,EAAQptB,EAAI,GAAK4N,EAC7CsvB,EAAWl9B,EAAI,GAAKQ,EAAQ4sB,EAAQptB,EAAI,GAAK4N,OAGjD,IAAS5N,EAAI,EAAGA,EAAI,EAAI4X,EAAO5X,GAAK,EAChCk9B,EAAWl9B,GAAKA,EAChBk9B,EAAWl9B,EAAI,GAAKA,EAAI,EACxBk9B,EAAWl9B,EAAI,GAAKA,EAAI,EAIhC+8B,EAAkBG,CACtB,MAAO,GAAI18B,GAAsB,IAAXoN,EAAc,CAEhC,IADMsvB,EAAaL,EAAW,IAAIxf,YAAYzF,GAAS,IAAIqF,YAAYrF,GAC9D5X,EAAI,EAAGA,EAAI4X,EAAO5X,IACvBk9B,EAAWl9B,GAAKQ,EAAQ4sB,EAAQptB,GAAK4N,EAGzCmvB,EAAkBG,CACtB,CAEA,GAAIH,EAAiB,CACjB,IAAIxP,EAAgBjF,EAAM6E,mBAAmB3sB,EAAS4sB,EAAOxV,EAAOhK,EAAQyf,GAC5E,QAAsBhxB,IAAlBkxB,EAA6B,CAC7B,IAAMyN,ELl/Bf,SAAkCx6B,EAAuB4sB,EAAexV,EAAeilB,GAC1F,GAAIr8B,aAAmByc,aAAezc,aAAmB6c,YACrD,OAAO7c,EAIX,GAAIA,aAAmB2c,WACnB,OAAO,IAAIE,YAAY7c,EAAQ6F,OAAQ7F,EAAQqG,WAAYrG,EAAQjC,QAGvE,IAAM4+B,EAAW38B,EAAQ8E,MKw+B2C,ILx+BtBsS,GAC9C,OAAOilB,EAAW,IAAIxf,YAAY8f,GAAY,IAAIlgB,YAAYkgB,EAClE,CKs+B8BC,CAAyBL,EAAiB,EAAGnlB,EAAOilB,GAC5D/nB,EAAa/Y,KAAKgZ,eAAeC,iBAAiBgmB,GAElDhb,EAAgB6c,EAAW,KAAqC,KACtE9gC,KAAKwzB,WAAWlxB,KAAKtC,KAAKgZ,eAAegL,eAAejL,EAAY,SAAqBkL,EAAepI,EAAO,IAC/G2V,EAAgBxxB,KAAKwzB,WAAWhxB,OAAS,EACzC+pB,EAAMgF,mBAAmB9sB,EAAS4sB,EAAOxV,EAAOhK,EAAQyf,EAAME,EAClE,CAEA6E,EAAU5xB,QAAU+sB,CACxB,CACJ,EAEQ,YAAA8P,oBAAR,SAA4BnmB,EAA4BzO,EAA2B2kB,EAAexV,EAAe0Q,EAAsB8J,GACnI,IAAMva,EAAOX,EAAaY,UAE1B,GAAKG,EAA0BJ,MAI3BA,EAAKylB,WAAW,OAAUvhC,KAAK20B,SAASO,iBACnCxoB,GAAoB1M,KAAKgP,qBAAqB0V,IAAIhY,IAD3D,CAMA,IAAI8kB,EAAgBjF,EAAM4F,kBAAkBhX,EAAckW,EAAOxV,GAEjE,QAAsBvb,IAAlBkxB,EAA6B,CAE7B,IAAM7mB,EAAO4hB,EAAM4E,8BAA8BpwB,IAAIoa,EAAa5Q,UAAY4Q,EAAa5Q,QAAQka,UAC7FP,EAASpI,IAAS,EAAAK,aAAaC,aL1/B1C,SAAmBzR,EAAiBwQ,EAA4BkW,EAAexV,GAC1E,IAAA/Q,EAA6CqQ,EAAY,WAA7CC,EAAiCD,EAAY,WAAjC7U,EAAqB6U,EAAY,KAA3BE,EAAeF,EAAY,WAC3D1C,EAAO0C,EAAa5K,UACpB8T,EAAM,IAAI/a,MAAcmP,GAAM+oB,KAAKnT,KACnClc,EAAM,IAAI7I,MAAcmP,GAAM+oB,MAAK,KAQzC,OAPA,IAAApC,sBAAqBz0B,EAAMG,EAAaumB,EAAQjW,EAAYA,EAAY3C,EAAMnS,EAAMuV,EAAQpD,EAAM4C,GAAY,SAAC2gB,GAC3G,IAAK,IAAI/3B,EAAI,EAAGA,EAAIwU,EAAMxU,IACtBogB,EAAIpgB,GAAKyH,KAAK2Y,IAAIA,EAAIpgB,GAAI+3B,EAAO/3B,IACjCkO,EAAIlO,GAAKyH,KAAKyG,IAAIA,EAAIlO,GAAI+3B,EAAO/3B,GAEzC,IAEO,CAAEogB,IAAG,EAAElS,IAAG,EACrB,CK6+BgEsvB,CAAU92B,EAAMwQ,EAAckW,EAAOxV,QAASvb,EAG5FohC,GACD5lB,IAAS,EAAAK,aAAaK,qBAAuBV,IAAS,EAAAK,aAAaM,2BAA6BtB,EAAa7U,OAAS,EAAA6V,aAAa2jB,MAElI6B,EAAmBD,EAAyB,EAAAvlB,aAAasjB,cAAgBtkB,EAAa7U,KACtFs7B,EAAyBF,OAAyBphC,EAAY6a,EAAaE,WAC3EtC,EAAa2oB,EAAyBnV,EAAM2F,sBAAsB/W,EAAa5Q,QAAS4Q,GAAiBoR,EAAMwF,oBAAoB5W,EAAa5Q,SAEhJO,EAAaqQ,EAAarQ,WAAaumB,EAAQlW,EAAaC,WAClEpb,KAAKwzB,WAAWlxB,KACZtC,KAAKgZ,eAAegL,eAChBjL,ELtxCb,SAAyB+C,EAAcuW,GAC1C,GAAIvW,GAAQ,EAAAK,aAAaI,UACrB,OAAO8V,EAAsB,OAAoB,OAGrD,OAAQvW,GACJ,KAAK,EAAAK,aAAaC,aAClB,KAAK,EAAAD,aAAaE,WACd,MAAO,OACX,KAAK,EAAAF,aAAaG,YAClB,KAAK,EAAAH,aAAaK,oBAClB,KAAK,EAAAL,aAAaM,yBAClB,KAAK,EAAAN,aAAaO,oBAClB,KAAK,EAAAP,aAAaQ,yBACd,MAAO,OACX,KAAK,EAAAR,aAAaS,OAClB,KAAK,EAAAT,aAAaU,QAClB,KAAK,EAAAV,aAAaW,QAClB,KAAK,EAAAX,aAAaY,QAClB,KAAK,EAAAZ,aAAaa,QAClB,KAAK,EAAAb,aAAac,QACd,MAAO,OAGf,MAAM,IAAIvP,MAAM,uBAAgBoO,GACpC,CK8vCoB+lB,CAAgB/lB,EAAMyQ,EAAM8F,oBAAoBlX,IAChDwmB,EACA9lB,EACA/Q,EACAoZ,EACA0d,IAGRpQ,EAAgBxxB,KAAKwzB,WAAWhxB,OAAS,EACzC+pB,EAAM6F,kBAAkBjX,EAAckW,EAAOxV,EAAO2V,EACxD,CAEA6E,EAAU9H,WLxwCX,SAA0BzS,GAC7B,OAAQA,GACJ,KAAK,EAAAK,aAAaC,aACd,MAAO,WACX,KAAK,EAAAD,aAAaE,WACd,MAAO,SACX,KAAK,EAAAF,aAAaG,YACd,MAAO,UACX,KAAK,EAAAH,aAAaI,UACd,MAAO,UACX,KAAK,EAAAJ,aAAaS,OACd,MAAO,aACX,KAAK,EAAAT,aAAaU,QACd,MAAO,aACX,KAAK,EAAAV,aAAaW,QACd,MAAO,aACX,KAAK,EAAAX,aAAaY,QACd,MAAO,aACX,KAAK,EAAAZ,aAAaa,QACd,MAAO,aACX,KAAK,EAAAb,aAAac,QACd,MAAO,aACX,KAAK,EAAAd,aAAaK,oBACd,MAAO,WACX,KAAK,EAAAL,aAAaM,yBACd,MAAO,WACX,KAAK,EAAAN,aAAaO,oBACd,MAAO,YACX,KAAK,EAAAP,aAAaQ,yBACd,MAAO,YAGf,MAAM,IAAIjP,MAAM,wBAAiBoO,GACrC,CKuuC6BgmB,CAAiBhmB,IAAS0V,CAjC/C,CAkCJ,EAEc,YAAAuQ,qBAAd,SAAmCr1B,EAA2BgyB,EAAiDsD,EAAkB3L,G,8GAEvG/1B,KADlB2hC,EAAgBjiC,KAAKq0B,aAAatzB,IAAI2L,IACtC,OACMuB,EAASywB,GAAiB99B,OAAO+iB,KAAK+a,GAAenlB,MAAK,SAACuC,GAAS,OAAAA,EAAKylB,WAAW,KAAhB,KAC1E70B,EAAkBA,aAA2B,EAAAw1B,cAAgBx1B,EAAgBy1B,aAAaH,EAAQC,eAAkBv1B,aACrF,EAAA01B,gBACX,GAAMpiC,KAAK+zB,kBAAkB/c,uBAAuBtK,EAAiBuB,IADrF,O,cACAg0B,EAAgB,S,oBACTv1B,aAA2B,EAAA8yB,iBAClB,GAAMx/B,KAAK+zB,kBAAkB/lB,4BAA4BtB,EAAiBuB,IADnF,M,cACPg0B,EAAgB,S,aAGhB,OADA,EAAApiB,OAAO7a,KAAK,gCAAyB0H,EAAgB/J,KAAI,uBAAe+J,EAAgB21B,iBACxF,I,OAGJriC,KAAKq0B,aAAapc,IAAIvL,EAAiBu1B,G,wBAG3C5L,EAAUlzB,SAAW8+B,E,YAGX,YAAAtB,iBAAd,SAA+B7W,EAAmByC,G,kKAE9C,QAAkBjsB,KADdmyB,EAAYlG,EAAMgG,QAAQzI,IAE1B,MAAO,CAAP,EAAO2I,G,GAGLhwB,EAAc,CAAE6/B,WAAY,IAClC7P,EAAYzyB,KAAK2zB,QAAQnxB,OACzBxC,KAAK2zB,QAAQrxB,KAAKG,GAClB8pB,EAAMiG,QAAQ1I,EAAa2I,GAErBhuB,EAAUqlB,EAAYyY,YAAc,KAAOzY,EAAYnmB,aACvD+6B,EAAoC,QAApB,EAAA5U,EAAYzmB,gBAAQ,eAAEs7B,mBACtC/L,EAAerG,EAAMuG,wBAAwBhJ,GAE7C0Y,EAAc1Y,aAAuB,EAAA2Y,UACrCC,EAAoB5Y,aAAuB,EAAA6Y,oBAE3CjC,EAAY5W,EAAY4W,YAC1BhC,GAAiBgC,GAAaA,EAAUl+B,OAAS,GAAjD,Y,IACsB,EAAAk+B,E,wBAAA,YAAXsB,EAAO,KACR3L,EAA4B,CAAE9H,WAAY,CAAC,GAE3C7hB,EAAkBs1B,EAAQY,eAAiB5iC,KAAK00B,cAAcvwB,gBAEhEu+B,GACMv/B,EAAsB,CACxBR,KAAM+J,EAAgB/J,MAGpBkgC,EAAmB/Y,EAEnBgZ,EAAa,EAAAl5B,OAAOE,QACpBxE,EAAwC,QAAhC,EAAyB,QAAzB,EAAAu9B,EAAiB1/B,gBAAQ,eAAEmC,aAAK,QAAI,KAC5CmO,EAAmD,QAA3C,EAAoC,QAApC,EAAAovB,EAAiBE,2BAAmB,eAAEtvB,aAAK,QAAIqvB,GAClDxzB,kBAAkBwzB,EAAY,EAAAp5B,UAAYpE,EAAQ,KACzDnC,EAAS+K,qBAAuB,CAC5B7B,gBAAiB,OAAIoH,EAAMlE,WAAW,GAAF,CAAEjK,IAAK,KAInDtF,KAAKyP,WAAWnN,KAAKa,GACrBkzB,EAAUlzB,SAAWnD,KAAKyP,WAAWjN,OAAS,E,OAjB9C,OALuB,M,cAuBhBggC,GAEDr/B,EAAsB,CACxBR,KAAM+J,EAAgB/J,SAGpBkgC,EAAmB/Y,GAEHrW,MAAMnE,kBAAkB,EAAA1F,OAAOE,QAAS,EAAAJ,UAAYm5B,EAAiBv9B,MAAQ,KAC/FnC,EAAS+K,qBAAuB,CAC5B7B,gBAAiB,OAAIw2B,EAAiBpvB,MAAMlE,WAAW,GAAF,CAAEszB,EAAiBv9B,QAAK,KAIrFtF,KAAKyP,WAAWnN,KAAKa,GACrBkzB,EAAUlzB,SAAWnD,KAAKyP,WAAWjN,OAAS,E,OAfvC,M,OAmBP,SAAMxC,KAAK+hC,qBAAqBr1B,EAAiBgyB,EAAesD,EAAS3L,I,OAAzE,S,iBAyBJ,IArBMlZ,EAAWqlB,GAAeE,EAAoB,EAAAr+B,SAASqZ,iBAAyD,QAArC,EAAAoM,EAAYkZ,iCAAyB,QAAIt2B,EAAgByQ,SAEtI4jB,EAAkBr0B,EAAgBtI,yBAAyB0lB,GAC3DyC,EAAMmE,qBAAuB5G,EAAY/lB,WAAWC,uBAEpD+8B,EAAkBA,IAAoB,EAAA18B,SAASC,yBAA2B,EAAAD,SAAS48B,gCAAkC,EAAA58B,SAASC,0BAGlItE,KAAK6gC,eACDp8B,EACAA,GAAU,IAAAw+B,kBAAiBx+B,EAASu9B,EAAQkB,WAAYlB,EAAQmB,WAAYnB,EAAQoB,eAAiBpB,EAAQqB,cAAgB,MAC7H5+B,EAAUu9B,EAAQmB,WAAanB,EAAQoB,cACvC3+B,EAAUu9B,EAAQkB,WAAalB,EAAQqB,eACtCrB,EAAQoB,cACTjmB,EACA4jB,EACAxU,EACA8J,GAIC,EAAL,EAA2B,EAAAz1B,OAAOo7B,OAAO0C,GAAd,eAAhBvjB,EAAY,KACnBnb,KAAKshC,oBAAoBnmB,EAAczO,EAAiBs1B,EAAQoB,cAAepB,EAAQqB,cAAe9W,EAAO8J,GAGjH,GAAIzD,EAEA,IADAyD,EAAUiN,QAAU,GACf,EAAL,EAA8B,EAAA1Q,EAAA,eAAnB2Q,EAAe,KACtBlN,EAAUiN,QAAQhhC,KAAKihC,EAAgBhV,YAI/C9rB,EAAK6/B,WAAWhgC,KAAK+zB,GACrBr2B,KAAKo2B,mCAAmCC,G,wBA/EtB,I,aAmF1B,GAAIzD,EAQA,IAPAnwB,EAAK+gC,QAAU,GAEV/gC,EAAKuyB,SACNvyB,EAAKuyB,OAAS,CAAC,GAEnBvyB,EAAKuyB,OAAOyO,YAAc,GAErB,EAAL,EAA8B,EAAA7Q,EAAA,eAAnB2Q,EAAe,KACtB9gC,EAAK+gC,QAAQlhC,KAAKihC,EAAgBjZ,WAClC7nB,EAAKuyB,OAAOyO,YAAYnhC,KAAKihC,EAAgB5gC,MAIrD,MAAO,CAAP,EAAO8vB,G,QAjvCa,EAAAoD,gBAAkB,IAAIvsB,MACtB,EAAA4tB,oBAAgG,CAAC,EAkvC7H,C,CAtyCA,GCzJA,2BAsCA,QA9BwB,EAAAwM,UAApB,SAA8Bv2B,EAAcsqB,EAAkB1E,G,yGACrDA,GAAYA,EAAQkC,6BAArB,MACA,GAAM9nB,EAAMw2B,kB,OAAZ,S,iBAIS,UADPC,EAAW,IAAIhO,GAAazoB,EAAO4lB,IACbkF,kBAAkBR,EAASre,QAAQ,YAAa,M,OAG5E,OAHMzO,EAAO,SACbi5B,EAASzM,UAEF,CAAP,EAAOxsB,G,QAUS,EAAAk5B,SAApB,SAA6B12B,EAAcsqB,EAAkB1E,G,yGACpDA,GAAYA,EAAQkC,6BAArB,MACA,GAAM9nB,EAAMw2B,kB,OAAZ,S,iBAIS,UADPC,EAAW,IAAIhO,GAAazoB,EAAO4lB,IACbgG,iBAAiBtB,EAASre,QAAQ,YAAa,M,OAG3E,OAHMzO,EAAO,SACbi5B,EAASzM,UAEF,CAAP,EAAOxsB,G,QAEf,EAtCA,GC5DMm5B,GAAO,0BAMb,cAcI,WAAYF,GAZI,KAAAjhC,KAAOmhC,GAGhB,KAAAnN,SAAU,EAGV,KAAAI,UAAW,EAIV,KAAAgN,UAAW,EAGf/jC,KAAK2N,UAAYi2B,CACrB,CA8GJ,OA5GW,YAAAzM,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCAYa,YAAA/N,oBAAb,SACID,EACAzb,EACAgF,EACA0H,EACA0C,EACAxC,G,qGAEO,SAAM,IAAI5f,SAAQ,SAACC,GACtB,GAAI+S,GAAQgF,aAAuB,EAAAuI,MAC3BvI,EAAY0kB,kBAAoB,EAAKr2B,UAAW,CAChD,EAAKo2B,UAAW,EAuBhB,IArBA,IAAME,EAAgB,EAAAhqB,QAAQG,OACxB8pB,EAAa,EAAAhqB,WAAWC,WACxBgqB,EAAU,EAAAlqB,QAAQe,MAGlBmE,EAASG,EAAY8kB,+BAErBC,EAAM,EAAA1pB,WAAWV,QAAQ,GACzBqqB,EAAM,EAAA3pB,WAAWT,WAAW,GAC5BqqB,EAAM,EAAA5pB,WAAWV,QAAQ,GAE3BuqB,GAAiC,EACjCC,GAA8B,EAC9BC,GAA2B,EAGzBC,EAAoB,IAAIl3B,aAA6C,EAAhC6R,EAAYslB,mBACjDC,EAAiB,IAAIp3B,aAA6C,EAAhC6R,EAAYslB,mBAC9CE,EAAc,IAAIr3B,aAA6C,EAAhC6R,EAAYslB,mBAE7C3gC,EAAI,EACQ,MAAAkb,EAAA,eAAJ,KACNC,UAAUmlB,EAAKD,EAAKD,GAElB3a,IACA1L,EAA6BqmB,GAC7BpmB,EAA6BqmB,IAIjCK,EAAkB1sB,IAAIosB,EAAI90B,UAAe,EAAJtL,GACrC4gC,EAAe5sB,IAAIqsB,EAAIrX,YAAY1d,UAAe,EAAJtL,GAC9C6gC,EAAY7sB,IAAIssB,EAAIh1B,UAAe,EAAJtL,GAG/BugC,EAAiCA,IAAmCH,EAAI/0B,kBAAkB20B,GAC1FQ,EAA8BA,IAAgCH,EAAIh1B,kBAAkB40B,GACpFQ,EAA2BA,IAA6BH,EAAIj1B,kBAAkB60B,GAE9ElgC,IAGJ,IAAMoV,EAAmC,CACrCkV,WAAY,CAAC,GAIbiW,IACAnrB,EAAUkV,WAAwB,YAAI,EAAKwW,eAAeJ,EAAmB,OAAmBrlB,EAAYslB,kBAAmB1d,IAG/Hud,IAEAprB,EAAUkV,WAAqB,SAAI,EAAKwW,eAAeF,EAAgB,OAAmBvlB,EAAYslB,kBAAmB1d,IAGzHwd,IACArrB,EAAUkV,WAAkB,MAAI,EAAKwW,eAAeD,EAAa,OAAmBxlB,EAAYslB,kBAAmB1d,IAIvH5M,EAAK5C,WAAa4C,EAAK5C,YAAc,CAAC,EACtC4C,EAAK5C,WAAWosB,IAAQzqB,CAC5B,CAEJ9R,EAAQ+S,EACZ,K,OAvEA,MAAO,CAAP,EAAO,U,QA0EH,YAAAyqB,eAAR,SAAuBz6B,EAAsBhE,EAAoBuV,EAAeqL,GAE5E,IAAM3C,EAAK2C,EAAcjO,iBAAiB3O,GAGpC8Z,EAAW8C,EAAclD,eAAeO,EAAIje,EAAM,KAA6BuV,GAErF,OADA7b,KAAK2N,UAAU6lB,WAAWlxB,KAAK8hB,GACxBpkB,KAAK2N,UAAU6lB,WAAWhxB,OAAS,CAC9C,EACJ,EA9HA,GAiIAozB,GAAawB,kBAAkB0M,IAAM,SAACF,GAAa,WAAIoB,GAAwBpB,EAA5B,ICvInD,IAAM,GAAO,6BAmBb,cA2BI,WAAYA,GAzBI,KAAAjhC,KAAO,GAMhB,KAAAo0B,UAAW,EAGV,KAAAkO,iBAAqC,IAAI5b,IAGzC,KAAA6b,eAAiC,IAAI7b,IAGrC,KAAA8b,gBAAmC,GAEnC,KAAApB,UAAW,EASf/jC,KAAK22B,QAAqD,UAA3CiN,EAAS7Q,QAAQsC,uBAAqC,EAAA+P,aAAaC,gBACtF,CAsHJ,OA7HI,sBAAW,sBAAO,C,IAAlB,WACI,OAAOrlC,KAAK+jC,QAChB,E,gCAQO,YAAA5M,QAAP,WAAkB,EAGX,YAAAb,wBAAP,SAA+BD,EAA2BnP,EAA8BC,GAAxF,WACI,GAAKnnB,KAAK22B,QAIV,GAAuB,IAAnBN,EAAUkE,MAA2D,IAAnBlE,EAAUkE,KAAhE,CAMA,IAAM+K,EAAsC,GACtCC,EAAkC,GAGpC9gC,EAA+C,KACnD,QAA0BnE,IAAtB+1B,EAAU5xB,QAAuB,CACjC,IAAM2f,EAAW+C,EAAUkP,EAAU5xB,SAC/BsU,EAAamO,EAAc1C,cAAcJ,GAE/C3f,EAAUyiB,EAAczC,QAAQ1L,GAAYxP,QAE5C+7B,EAAqBhjC,KAAKyW,GAC1BwsB,EAAmBjjC,KAAK8hB,EAC5B,CAIA,IADA,IA/EuBohB,EA+EjBjX,EAAoC,GACN,MAAA3tB,OAAOqf,QAAQoW,EAAU9H,YAAzB,eAAsC,CAA/D,WAAC,EAAI,KAIN9V,GAHA2L,EAAW+C,EADU,MAErBpO,EAAamO,EAAc1C,cAAcJ,GAElCpI,EAAwBoI,EAAS9d,OACxCqE,GAAO,IAAA86B,mBACTve,EAAczC,QAAQ1L,GACtBN,EACA2L,EAASH,cACTG,EAAStZ,YAAc,EACvBiO,EAAWqC,aAAc,IAAAsqB,mBAAkBthB,EAASH,eAAiBxL,EACrE2L,EAAS/I,aAAc,EACvB+I,EAASvI,OACT,GAGJ0S,EAAWjsB,KAAK,CAAEwZ,KAAM,EAAM6pB,WAhGXH,EAgG4C,EA/FtD,aAAbA,EACO,WACa,WAAbA,EACA,SACAA,EAASjE,WAAW,SACpB,QACAiE,EAASjE,WAAW,YACpB,YAEJ,WAsFuE9oB,KAAMuD,EAAwBoI,EAAS9d,MAAOqE,KAAMA,IAE1H26B,EAAqBhjC,KAAKyW,GAC1BwsB,EAAmBjjC,KAAK8hB,EAC5B,CAGA,IAAM2O,EAAgC,CAClC6S,OAAQvP,EAAUiN,QAAU,2BAA6B,6BAGvDuC,EAAU,EAAAT,aAAaU,QAAQC,aAAaxX,EAAY9pB,EAASsuB,GAElEhrB,MAAK,SAACi+B,GACH,GAAKA,EAAL,CAKA,IAAMC,EAAsC,CACxCltB,YAAa,EACbwV,WAAYyX,EAAYE,cAEtBntB,EAAamO,EAAcjO,iBAAiB+sB,EAAYr7B,MAC9Duc,EAAchO,cAAc+sB,EAAWltB,GAEvC,IAAyB,UAAAusB,EAAA,eAAsB,CAA1C,IAAM,EAAU,KACjB,EAAKL,iBAAiBh2B,IAAI,EAC9B,CACA,IAAuB,UAAAs2B,EAAA,eAAoB,CAAtC,IAAMnhB,EAAQ,KACf,EAAK8gB,eAAej2B,IAAImV,EAC5B,CAEAiS,EAAU3e,aAAV2e,EAAU3e,WAAe,CAAC,GAC1B2e,EAAU3e,WAAW,IAAQuuB,CAjB7B,MAFI,EAAApmB,OAAOnS,MAAM,uCAoBrB,IAECy4B,OAAM,SAACC,GACJ,EAAAvmB,OAAOnS,MAAM,wCAA0C04B,EAC3D,IAEJpmC,KAAKmlC,gBAAgB7iC,KAAKujC,GAE1B7lC,KAAK+jC,UAAW,CA/EhB,MAFI,EAAAlkB,OAAO7a,KAAK,uCAAyCqxB,EAAUkE,KAAO,IAkF9E,EAGa,YAAA/D,uBAAb,SAAoCtP,G,qGAChC,OAAKlnB,KAAK22B,QAIV,GAAMrvB,QAAQ4H,IAAIlP,KAAKmlC,kBAHnB,I,cAGJ,SAGAnlC,KAAKilC,iBAAiBzhB,SAAQ,SAACzK,GACRmO,EAAcpD,4BAA4B/K,GACdwH,OAAM,SAACR,GAClD,OAAO,EAAKmlB,eAAexgB,IAAI3E,EACnC,KAEImH,EAAc5C,iBAAiBvL,EAEvC,IAEA/Y,KAAKilC,iBAAiBoB,QACtBrmC,KAAKklC,eAAemB,Q,YAE5B,EAnJA,GAqJAzQ,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAI0C,GAA2B1C,EAA/B,ICvKnD,IAAM,GAAO,sBACP2C,GAAmD,CACrD5jC,KAAM,GACN8Q,MAAO,CAAC,EAAG,EAAG,GACd+yB,UAAW,EACXC,MAAO9qB,OAAOC,WAEZ8qB,GAA8D,CAChEC,eAAgB,EAChBC,eAAgBl7B,KAAKm7B,GAAK,GAExBC,GAAiB,EAAA7sB,QAAQ8sB,WAM/B,cAkBI,WAAYnD,GAhBI,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAWd/2B,KAAK2N,UAAYi2B,CACrB,CA6HJ,OA1HW,YAAAzM,QAAP,WACKn3B,KAAKgnC,QAAkB,IAC5B,EAGA,sBAAW,sBAAO,C,IAAlB,WACI,QAAShnC,KAAKgnC,OAClB,E,gCAGO,YAAA/P,YAAP,WACIj3B,KAAK2N,UAAUulB,MAAMxb,WAAY,IAAQ1X,KAAKgnC,OAClD,EAUa,YAAAhR,oBAAb,SAAiCD,EAAiBzb,EAAagF,EAAmB0H,EAA4B0C,G,qGACnG,SAAM,IAAIpiB,SAAQ,SAACC,GACtB,GAAM+X,aAAuB,EAAAuF,MAA7B,CAKA,IAAMoiB,EACF3nB,EAAY4nB,aAAe,EAAAriB,MAAMsiB,uBAC3B,QACA7nB,EAAY4nB,aAAe,EAAAriB,MAAMuiB,6BAC/B,cACA9nB,EAAY4nB,aAAe,EAAAriB,MAAMwiB,sBAC/B,OACA,KACd,KAAKJ,GAAe3nB,aAAuB,EAAAgoB,aAGvC,OAFA,EAAAznB,OAAO7a,KAAK,UAAG+wB,EAAO,mBAAWzW,EAAY3c,KAAI,gCAAwB,UACzE4E,EAAQ+S,GASZ,GALIgF,EAAYioB,cAAgB,EAAA1iB,MAAM2iB,cAClC,EAAA3nB,OAAO7a,KAAK,UAAG+wB,EAAO,+BAAuBzW,EAAY3c,KAAI,+BAAuB,GAAI,qBAIvF2c,EAAYqO,SAAS8Z,eAAe,EAAG,EAAG,GAAI,CAC/C,IAAM1oB,EAAc,EAAApE,WAAWV,QAAQ,GAAG8f,SAASza,EAAYqO,UAC3DjE,GACA1L,EAA6Be,GAEjCzE,EAAKyE,YAAcA,EAAYxP,SACnC,CAIA,GAAkB,UAAd03B,EAAiD,CACjD,IAAMS,EAAYpoB,EAAYooB,UAAUC,eAAe,EAAAhtB,WAAWV,QAAQ,IACtEyP,GACA1L,EAA6B0pB,GAGjC,IAAME,EAA0B,EAAA1tB,WAAW2tB,qBAAqBf,GAAgBY,EAAW,EAAA/sB,WAAWT,WAAW,IAC5G,EAAAA,WAAW4tB,WAAWF,KACvBttB,EAAKmE,SAAWmpB,EAAwBr4B,UAEhD,CAEA,IAAMw4B,EAAkC,CACpCzhC,KAAM2gC,EACNtkC,KAAM2c,EAAY3c,KAClB8Q,MAAO6L,EAAYlU,QAAQmE,UAC3Bi3B,UAAWlnB,EAAYknB,UACvBC,MAAOnnB,EAAYmnB,OAKvB,GAHA3mB,EAAkBioB,EAAOxB,IAGP,SAAdU,EAAgD,CAChD,IAAMe,EAAmB1oB,EACzByoB,EAAME,KAAO,CACTtB,eAAgBqB,EAAiBE,WAAa,EAC9CtB,eAAgBoB,EAAiBG,MAAQ,GAE7CroB,EAAkBioB,EAAME,KAAMvB,GAClC,CAEA,EAAKM,UAAL,EAAKA,QAAY,CACboB,OAAQ,KAEZ,EAAKpB,QAAQoB,OAAO9lC,KAAKylC,GAEzB,IAAMM,EAAoD,CACtDN,MAAO,EAAKf,QAAQoB,OAAO5lC,OAAS,GAKlC+c,EAAoBD,EAAYG,OAEtC,GAAIF,GAAqBF,EAAmBC,EAAaC,GAAoB,CACzE,IAAMqhB,EAAkB5Z,EAAQjmB,IAAIwe,GACpC,GAAIqhB,EAAiB,CAEjB,IAAMhiB,EAAa,EAAKjR,UAAUimB,OAAOgN,GAOzC,OANAjiB,EAAwBrE,EAAMsE,GAC9BA,EAAWlH,aAAXkH,EAAWlH,WAAe,CAAC,GAC3BkH,EAAWlH,WAAW,IAAQ2wB,OAG9B9gC,EAAQ,KAEZ,CACJ,CAEA+S,EAAK5C,aAAL4C,EAAK5C,WAAe,CAAC,GACrB4C,EAAK5C,WAAW,IAAQ2wB,EACxB9gC,EAAQ+S,EA5FR,MAFI/S,EAAQ+S,EA+FhB,K,OAjGA,MAAO,CAAP,EAAO,U,QAmGf,EAjJA,GAmJAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAI0E,GAAoB1E,EAAxB,IC1KnD,IAAM,GAAO,2BAMb,cAcI,WAAYA,GAZI,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAIV,KAAAgN,UAAW,EAGf/jC,KAAK2N,UAAYi2B,CACrB,CAqDJ,OAnDW,YAAAzM,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCAEO,YAAA7N,qCAAP,SAA6CH,EAAiBzb,EAAiB5N,GAC3E,IAAM67B,EAAoC,GAC1C,OAAI77B,aAA2B,EAAA01B,iBACvB11B,EAAgB87B,WAAWC,YAAc/7B,EAAgB87B,WAAWE,QAChEh8B,EAAgB87B,WAAW54B,SAC3B24B,EAAmBjmC,KAAKoK,EAAgB87B,WAAW54B,SAEhD24B,GAIR,EACX,EAGO,YAAAtS,wBAAP,SAAgCF,EAAiBzb,EAAiB5N,GAAlE,WACI,OAAO,IAAIpF,SAAQ,SAACC,GAChB,GAAImF,aAA2B,EAAA01B,gBAAiB,CAC5C,IAAK11B,EAAgB87B,WAAWC,WAAa/7B,EAAgB87B,WAAWE,OAEpE,YADAnhC,EAAQ+S,GAIZ,EAAKypB,UAAW,EAEhBzpB,EAAK5C,WAAa4C,EAAK5C,YAAc,CAAC,EAEtC,IAAMixB,EAAwB,EAAKh7B,UAAUomB,kBAAkBhmB,eAAerB,EAAgB87B,WAAW54B,SAEnGg5B,EAA0C,CAC5CC,mBAAoBn8B,EAAgB87B,WAAWhC,UAC/CsC,mBAAoBp8B,EAAgB87B,WAAWL,MAC/CY,kBAAmBJ,QAAAA,OAAyBroC,GAGP,OAArCsoC,EAAeG,mBACf,EAAKp7B,UAAUqB,qBAAqBC,IAAIvC,GAG5C4N,EAAK5C,WAAW,IAAQkxB,CAC5B,CACArhC,EAAQ+S,EACZ,GACJ,EACJ,EArEA,GAuEAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAIoF,GAAyBpF,EAA7B,IC3EnD,IAAM,GAAO,0BAMb,cAcI,WAAYA,GAZI,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAIV,KAAAgN,UAAW,EAGf/jC,KAAK2N,UAAYi2B,CACrB,CA6EJ,OA3EW,YAAAzM,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCAEO,YAAA7N,qCAAP,SAA6CH,EAAiBzb,EAAiB5N,GAC3E,IAAM67B,EAAoC,GAC1C,OAAI77B,aAA2B,EAAA01B,iBACvB11B,EAAgBu8B,UAAUR,WACtB/7B,EAAgBu8B,UAAUr5B,SAC1B24B,EAAmBjmC,KAAKoK,EAAgBu8B,UAAUr5B,UAEjDlD,EAAgBu8B,UAAUC,6BAA+Bx8B,EAAgBu8B,UAAUE,kBACpFZ,EAAmBjmC,KAAKoK,EAAgBu8B,UAAUE,kBAElDz8B,EAAgBu8B,UAAUljC,aAC1BwiC,EAAmBjmC,KAAKoK,EAAgBu8B,UAAUljC,aAE/CwiC,GAIR,EACX,EAGO,YAAAtS,wBAAP,SAAgCF,EAAiBzb,EAAiB5N,GAAlE,WACI,OAAO,IAAIpF,SAAQ,SAACC,GAChB,GAAImF,aAA2B,EAAA01B,gBAAiB,CAC5C,IAAK11B,EAAgBu8B,UAAUR,UAE3B,YADAlhC,EAAQ+S,GAIZ,EAAKypB,UAAW,EAEhBzpB,EAAK5C,WAAa4C,EAAK5C,YAAc,CAAC,EAEtC,IACI0xB,EADEC,EAAuB,EAAK17B,UAAUomB,kBAAkBhmB,eAAerB,EAAgBu8B,UAAUr5B,SAGnGw5B,EADA18B,EAAgBu8B,UAAUC,4BACM,EAAKv7B,UAAUomB,kBAAkBhmB,eAAerB,EAAgBu8B,UAAUr5B,SAE1E,EAAKjC,UAAUomB,kBAAkBhmB,eAAerB,EAAgBu8B,UAAUE,kBAG1Gz8B,EAAgBu8B,UAAUK,eAC1B,EAAAvkC,MAAMC,KAAK,2EAAoE0H,EAAgB/J,OAG/F+J,EAAgBu8B,UAAUM,0BAC1B,EAAAxkC,MAAMC,KAAK,mFAA4E0H,EAAgB/J,OAG3G,IAAM6mC,EAA6B,EAAK77B,UAAUomB,kBAAkBhmB,eAAerB,EAAgBu8B,UAAUljC,aAEvG0jC,EAAwC,CAC1CC,gBAAiBh9B,EAAgBu8B,UAAUzC,UAC3CmD,iBAAkBN,QAAAA,OAAwB/oC,EAC1CspC,yBAA0Bl9B,EAAgBu8B,UAAU98B,UACpD09B,0BAA2BT,QAAAA,OAAiC9oC,EAC5DwpC,uBAAwBN,QAAAA,OAA8BlpC,GAGnB,OAAnCmpC,EAAcE,kBAAyE,OAA5CF,EAAcI,2BAAkF,OAA5CJ,EAAcI,2BAC7G,EAAKl8B,UAAUqB,qBAAqBC,IAAIvC,GAG5C4N,EAAK5C,WAAW,IAAQ+xB,CAC5B,CACAliC,EAAQ+S,EACZ,GACJ,EACJ,EA7FA,GA+FAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAImG,GAAwBnG,EAA5B,ICrGnD,IAAM,GAAO,qCAMb,SAASoG,GAAgCjU,EAAiBrpB,GACtD,IAAMu9B,EAAOv9B,EAAgBw9B,WACzBt6B,EAAU,KASd,OANIq6B,EAAKE,6BACLv6B,EAAUq6B,EAAKE,6BACRF,EAAKG,kBAAoBH,EAAKI,8BACrCz6B,EAAUq6B,EAAKG,kBAGfx6B,IAAYq6B,EAAKK,sBACjB,EAAAzqB,OAAO7a,KAAK,UAAG+wB,EAAO,8GAAsGrpB,EAAgB/J,MAAQ,GAC7I,MAGJiN,CACX,CAOA,kBAcI,WAAYg0B,GAZI,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAIV,KAAAgN,UAAW,EAGf/jC,KAAK2N,UAAYi2B,CACrB,CA2FJ,OAzFW,YAAAzM,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCASO,YAAA7N,qCAAP,SAA6CH,EAAiBzb,EAAiB5N,GAC3E,IAAM67B,EAAoC,GAE1C,GAAI77B,aAA2B,EAAA69B,aAAevqC,KAAKwqC,oBAAoB99B,GAAkB,CACrF,IAAMy9B,EAA+BH,GAAgCjU,EAASrpB,GAO9E,OANIy9B,GACA5B,EAAmBjmC,KAAK6nC,GAExBz9B,EAAgBw9B,WAAWO,0BAC3BlC,EAAmBjmC,KAAKoK,EAAgBw9B,WAAWO,0BAEhDlC,CACX,CAEA,OAAOA,CACX,EAEQ,YAAAiC,oBAAR,SAA4BtnC,GAExB,GAAIA,EAAIwnC,MACJ,OAAO,EAEX,IAAMT,EAAO/mC,EAAIgnC,WACjB,QAAKD,EAAKU,wBAKLznC,EAAIwnC,QACJT,EAAKW,6BACNX,EAAKK,sBAC4B,IAAjCL,EAAKY,yBACqB,IAA1BZ,EAAKa,kBACqB,IAA1Bb,EAAKc,gBAEb,EAUO,YAAA9U,wBAAP,SAAgCF,EAAiBzb,EAAiB5N,GAAlE,WACI,OAAO,IAAIpF,SAAQ,SAACC,G,QAChB,GAAImF,aAA2B,EAAA69B,aAAe,EAAKC,oBAAoB99B,GAAkB,CACrF,EAAKq3B,UAAW,EAEhB,IAAMkG,EAAOv9B,EAAgBw9B,WACvBC,EAA+BH,GAAgCjU,EAASrpB,GAExEs+B,EAA0D,GAA9Bf,EAAKgB,2BAA6B3qC,EAAY2pC,EAAKgB,sBAC/EC,EAA0G,QAA7E,IAAKv9B,UAAUomB,kBAAkBhmB,eAAeo8B,UAA6B,aAAI7pC,EAC9G6qC,GAAkClB,EAAKmB,mBAAqBnB,EAAKmB,kBAAkBC,aAAa,EAAK,EAAK,QAAO/qC,EAAY2pC,EAAKmB,kBAAkB77B,UACpJ+7B,EAAgH,QAA9E,IAAK39B,UAAUomB,kBAAkBhmB,eAAek8B,EAAKQ,iCAAyB,aAAInqC,EAEpHirC,EAA4D,CAC9DP,0BAAyB,EACzBE,2BAA0B,EAC1BC,+BAA8B,EAC9BG,gCAA+B,IAG/BJ,GAA8BI,IAC9B,EAAK39B,UAAUqB,qBAAqBC,IAAIvC,GAG5C4N,EAAK5C,WAAa4C,EAAK5C,YAAc,CAAC,EACtC4C,EAAK5C,WAAW,IAAQ6zB,CAC5B,CACAhkC,EAAQ+S,EACZ,GACJ,EACJ,EA3GA,GA6GAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAI4H,GAAmC5H,EAAvC,IC9InD,IAAM,GAAO,2BAOb,cAaI,aAXgB,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAEV,KAAAgN,UAAW,CAGJ,CAgDnB,OA7CW,YAAA5M,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCAEQ,YAAAyG,oBAAR,SAA4BtnC,GAExB,GAAIA,EAAIwnC,MACJ,OAAO,EAEX,IAAMT,EAAO/mC,EAAIgnC,WAEjB,SAAKD,EAAKwB,sBAAwBxB,EAAKyB,oBAI3C,EAUO,YAAAzV,wBAAP,SAAgCF,EAAiBzb,EAAiB5N,GAAlE,WACI,OAAO,IAAIpF,SAAQ,SAACC,GAChB,GAAImF,aAA2B,EAAA69B,aAAe,EAAKC,oBAAoB99B,GAAkB,CACrF,EAAKq3B,UAAW,EAEhB,IAGM4H,EAA0C,CAC5CC,WAJSl/B,EAAgBw9B,WACL0B,YAKxBtxB,EAAK5C,WAAa4C,EAAK5C,YAAc,CAAC,EACtC4C,EAAK5C,WAAW,IAAQi0B,CAC5B,CACApkC,EAAQ+S,EACZ,GACJ,EACJ,EA7DA,GA+DAsb,GAAawB,kBAAkB,IAAM,WAAM,WAAIyU,EAAJ,ICtE3C,IAAM,GAAO,kCAMb,2BAEoB,KAAAlpC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAEV,KAAAgN,UAAW,CA6CvB,QA1CW,YAAA5M,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCASa,YAAA9N,wBAAb,SAAqCF,EAAiBzb,EAAiB5N,G,qGAC5D,SAAM,IAAIpF,SAAQ,SAACC,GACtB,KAAMmF,aAA2B,EAAA69B,aAC7B,OAAOhjC,EAAQ+S,GAGnB,IAAM3U,EAAgB+G,EAAgB/G,cAAc4J,UAC9Cu8B,EAAuBpgC,KAAKyG,IAAG,MAARzG,KAAY/F,GAEzC,GAAImmC,EAAuB,EAAG,CAC1B,EAAK/H,UAAW,EAEhBzpB,EAAK5C,aAAL4C,EAAK5C,WAAe,CAAC,GAErB,IAAMq0B,EAAsD,CACxDC,iBAAkBF,GAIhBG,EAAoBv/B,EAAgB/G,cAAcsG,MAAM,EAAI8/B,EAAqBC,kBAEvF1xB,EAAKzL,eAAiBo9B,EAAkB18B,UACxC+K,EAAK5C,WAAW,IAAQq0B,CAC5B,CAEA,OAAOxkC,EAAQ+S,EACnB,K,OAzBA,MAAO,CAAP,EAAO,U,QA2Bf,EAvDA,GAyDAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAIsI,EAAJ,IC/DnD,IAAM,GAAO,oBAMb,cAYI,aAVgB,KAAAvpC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAEV,KAAAgN,UAAW,CAEJ,CAwCnB,OArCW,YAAA5M,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCAEQ,YAAAyG,oBAAR,SAA4BtnC,GAExB,OAAIA,EAAIwnC,OAGwBpqC,MAAzB4C,EAAIipC,mBAA2D,KAAzBjpC,EAAIipC,iBACrD,EAUO,YAAAlW,wBAAP,SAAgCF,EAAiBzb,EAAiB5N,GAAlE,WACI,OAAO,IAAIpF,SAAQ,SAACC,GAChB,GAAImF,aAA2B,EAAA69B,aAAe,EAAKC,oBAAoB99B,GAAkB,CACrF,EAAKq3B,UAAW,EAEhB,IAAMqI,EAA4B,CAC9BC,IAAK3/B,EAAgBy/B,mBAEzB7xB,EAAK5C,WAAa4C,EAAK5C,YAAc,CAAC,EACtC4C,EAAK5C,WAAW,IAAQ00B,CAC5B,CACA7kC,EAAQ+S,EACZ,GACJ,EACJ,EApDA,GAuDAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAI0I,EAAJ,IC5DnD,IAAM,GAAO,4BAMb,cAcI,WAAY1I,GAZI,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAIV,KAAAgN,UAAW,EAGf/jC,KAAK2N,UAAYi2B,CACrB,CA6DJ,OA3DW,YAAAzM,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCAEO,YAAA7N,qCAAP,SAA6CH,EAAiBzb,EAAiB5N,GAC3E,IAAM67B,EAAoC,GAC1C,OAAI77B,aAA2B,EAAA01B,iBACvB11B,EAAgB6/B,YAAY9D,WACxB/7B,EAAgB6/B,YAAY38B,SAC5B24B,EAAmBjmC,KAAKoK,EAAgB6/B,YAAY38B,SAEpDlD,EAAgB6/B,YAAYnC,kBAAoB19B,EAAgB6/B,YAAYnC,mBAAqB19B,EAAgB6/B,YAAY38B,SAC7H24B,EAAmBjmC,KAAKoK,EAAgB6/B,YAAYnC,kBAEjD7B,GAIR,EACX,EAGO,YAAAtS,wBAAP,SAAgCF,EAAiBzb,EAAiB5N,GAAlE,WACI,OAAO,IAAIpF,SAAQ,SAACC,GAChB,GAAImF,aAA2B,EAAA01B,gBAAiB,CAC5C,IAAK11B,EAAgB6/B,YAAY9D,UAE7B,YADAlhC,EAAQ+S,GAIZ,EAAKypB,UAAW,EAEhBzpB,EAAK5C,WAAa4C,EAAK5C,YAAc,CAAC,EAEtC,IAAM80B,EAAyB,EAAK7+B,UAAUomB,kBAAkBhmB,eAAerB,EAAgB6/B,YAAY38B,SACrG68B,EAAkC,EAAK9+B,UAAUomB,kBAAkBhmB,eAAerB,EAAgB6/B,YAAYnC,kBAE9GsC,EAA4C,CAC9CC,kBAAmBjgC,EAAgB6/B,YAAY/F,UAC/CoG,eAAgBlgC,EAAgB6/B,YAAYJ,kBAC5CU,4BAA6BngC,EAAgB6/B,YAAYzB,iBACzDgC,4BAA6BpgC,EAAgB6/B,YAAYxB,iBAEzDgC,mBAAoBP,QAAAA,OAA0BlsC,EAC9C0sC,4BAA6BP,QAAAA,OAAmCnsC,GAGzB,OAAvCosC,EAAgBK,oBAA+E,OAAhDL,EAAgBM,6BAC/D,EAAKr/B,UAAUqB,qBAAqBC,IAAIvC,GAG5C4N,EAAK5C,WAAW,IAAQg1B,CAC5B,CACAnlC,EAAQ+S,EACZ,GACJ,EACJ,EA7EA,GA+EAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAIqJ,GAA0BrJ,EAA9B,ICrFnD,IAAM,GAAO,sBAMb,cAcI,WAAYA,GAZI,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAEV,KAAAgN,UAAW,EAKf/jC,KAAK2N,UAAYi2B,CACrB,CAwDJ,OAtDW,YAAAzM,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCAEO,YAAA7N,qCAAP,SAA4CH,EAAiBzb,EAAiB5N,GAC1E,OAAIA,aAA2B,EAAA69B,aACvB79B,EAAgBwgC,MAAMzE,WAAa/7B,EAAgBwgC,MAAMt9B,QAClD,CAAClD,EAAgBwgC,MAAMt9B,SAI/B,EACX,EAEa,YAAAqmB,wBAAb,SAAqCF,EAAiBzb,EAAiB5N,G,qGAC5D,SAAM,IAAIpF,SAAQ,SAACC,G,YACtB,GAAImF,aAA2B,EAAA69B,YAAa,CACxC,IAAK79B,EAAgBwgC,MAAMzE,UAEvB,YADAlhC,EAAQ+S,GAIZ,EAAKypB,UAAW,EAEO,MAAnBzpB,EAAK5C,aACL4C,EAAK5C,WAAa,CAAC,GAEvB,IAAMy1B,EAAgC,CAClCC,iBAAkB1gC,EAAgBwgC,MAAMz5B,MAAMlE,UAC9C89B,qBAAqD,QAA/B,EAAA3gC,EAAgBwgC,MAAM/gC,iBAAS,QAAI,GAGzB,OAAhCghC,EAAUG,mBAAkE,OAApCH,EAAUI,uBAClD,EAAK5/B,UAAUqB,qBAAqBC,IAAIvC,GAGxCA,EAAgBwgC,MAAMt9B,UACtBu9B,EAAUG,kBAAkG,QAA9E,IAAK3/B,UAAUomB,kBAAkBhmB,eAAerB,EAAgBwgC,MAAMt9B,gBAAQ,aAAItP,GAGhHoM,EAAgBwgC,MAAM/D,mBAAqBz8B,EAAgBwgC,MAAMhE,4BACjEiE,EAAUI,sBAA+G,QAAvF,IAAK5/B,UAAUomB,kBAAkBhmB,eAAerB,EAAgBwgC,MAAM/D,yBAAiB,aAAI7oC,EACtHoM,EAAgBwgC,MAAMt9B,SAAWlD,EAAgBwgC,MAAMhE,8BAC9DiE,EAAUI,sBAAsG,QAA9E,IAAK5/B,UAAUomB,kBAAkBhmB,eAAerB,EAAgBwgC,MAAMt9B,gBAAQ,aAAItP,GAGxHga,EAAK5C,WAAW,IAAQy1B,CAC5B,CACA5lC,EAAQ+S,EACZ,K,OAlCA,MAAO,CAAP,EAAO,U,QAoCf,EAxEA,GA0EAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAI4J,GAAoB5J,EAAxB,IChFnD,IAAM,GAAO,yBAMb,cAcI,WAAYA,GAZI,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAIV,KAAAgN,UAAW,EAGf/jC,KAAK2N,UAAYi2B,CACrB,CAyFJ,OAtFW,YAAAzM,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCASO,YAAA7N,qCAAP,SAA6CH,EAAiBzb,EAAiB5N,GAC3E,IAAM67B,EAAoC,GAE1C,OAAI77B,aAA2B,EAAA69B,aACvBvqC,KAAKwqC,oBAAoB99B,IACrBA,EAAgB+gC,4BAChBlF,EAAmBjmC,KAAKoK,EAAgB+gC,4BAExC/gC,EAAgBghC,oBAChBnF,EAAmBjmC,KAAKoK,EAAgBghC,oBAErCnF,GAIRA,CACX,EAEQ,YAAAiC,oBAAR,SAA4BtnC,GAExB,OAAIA,EAAIwnC,QAIqBpqC,MAAxB4C,EAAIyqC,kBAAyD,GAAxBzqC,EAAIyqC,kBACTrtC,MAAhC4C,EAAI0qC,2BAA0C1qC,EAAI0qC,yBAAyBvC,aAAa,EAAK,EAAK,IACnGrrC,KAAK6tC,sBAAsB3qC,GAEnC,EAEQ,YAAA2qC,sBAAR,SAA8B3qC,GAC1B,OAAyC,MAAlCA,EAAIuqC,4BAAgE,MAA1BvqC,EAAIwqC,kBACzD,EAUO,YAAAzX,wBAAP,SAAgCF,EAAiBzb,EAAiB5N,GAAlE,WACI,OAAO,IAAIpF,SAAQ,SAACC,G,QAChB,GAAImF,aAA2B,EAAA69B,aAAe,EAAKC,oBAAoB99B,GAAkB,CACrF,EAAKq3B,UAAW,EAEhBzpB,EAAK5C,WAAa4C,EAAK5C,YAAc,CAAC,EAEtC,IAAM+1B,EAAwH,QAA3F,IAAK9/B,UAAUomB,kBAAkBhmB,eAAerB,EAAgB+gC,mCAA2B,aAAIntC,EAC5HotC,EAAwG,QAAnF,IAAK//B,UAAUomB,kBAAkBhmB,eAAerB,EAAgBghC,2BAAmB,aAAIptC,EAM5GwtC,EAAsC,CACxCC,eANyD,GAApCrhC,EAAgBihC,sBAA0BrtC,EAAYoM,EAAgBihC,iBAO3F7nC,gBAAiB2nC,EACjBO,oBAP6BthC,EAAgBkhC,yBAAyBvC,aAAa,EAAK,EAAK,QAC3F/qC,EACAoM,EAAgBkhC,yBAAyBr+B,UAM3C0+B,qBAAsBP,GAGtB,EAAKG,sBAAsBnhC,IAC3B,EAAKiB,UAAUqB,qBAAqBC,IAAIvC,GAG5C4N,EAAK5C,WAAW,IAAQo2B,CAC5B,CACAvmC,EAAQ+S,EACZ,GACJ,EACJ,EAzGA,GA2GAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAIsK,GAAuBtK,EAA3B,IChHnD,IAAM,GAAO,6BAMb,cAcI,WAAYA,GAZI,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAIV,KAAAgN,UAAW,EAGf/jC,KAAK2N,UAAYi2B,CACrB,CAoFJ,OAjFW,YAAAzM,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCASO,YAAA7N,qCAAP,SAA6CH,EAAiBzb,EAAiB5N,GAC3E,IAAM67B,EAAoC,GAE1C,OAAI77B,aAA2B,EAAA69B,aACvBvqC,KAAKwqC,oBAAoB99B,IACrBA,EAAgBw9B,WAAWE,kBAC3B7B,EAAmBjmC,KAAKoK,EAAgBw9B,WAAWE,kBAEhD7B,GAIRA,CACX,EAEQ,YAAAiC,oBAAR,SAA4BtnC,GAExB,GAAIA,EAAIwnC,MACJ,OAAO,EAEX,IAAMT,EAAO/mC,EAAIgnC,WACjB,OAAQD,EAAKwB,qBAAmDnrC,MAA5B2pC,EAAKkE,qBAAgE,GAA5BlE,EAAKkE,qBAA6BnuC,KAAK6tC,sBAAsB3qC,EAC9I,EAEQ,YAAA2qC,sBAAR,SAA8B3qC,GAC1B,OAAoD,MAA7CA,EAAIgnC,WAAWkE,0BAC1B,EASa,YAAAnY,wBAAb,SAAsCF,EAAiBzb,EAAiB5N,G,6GAChEA,aAA2B,EAAA69B,aAAevqC,KAAKwqC,oBAAoB99B,IACnE1M,KAAK+jC,UAAW,EAEVmG,EAAax9B,EAAgBw9B,WAC7BmE,EAAwD,IAAnCnE,EAAWiE,yBAA4B7tC,EAAY4pC,EAAWiE,oBAEnFG,EAAwC,CAC1CD,mBAAoBA,GAGpBruC,KAAK6tC,sBAAsBnhC,IAC3B1M,KAAK2N,UAAUqB,qBAAqBC,IAAIvC,GAGxCw9B,EAAWkE,2BACPlE,EAAWI,qBACiB,GAAMtqC,KAAK2N,UAAUomB,kBAAkBxlB,mBAAmB27B,EAAWkE,6BADjG,MADJ,OAdJ,M,cAgBcG,EAAsB,YAExBD,EAAWC,oBAAsBA,G,aAGrC,EAAA1uB,OAAO7a,KAAK,UAAG+wB,EAAO,0G,iBAI9Bzb,EAAK5C,aAAL4C,EAAK5C,WAAe,CAAC,GACrB4C,EAAK5C,WAAW,IAAQ42B,E,iBAG5B,MAAO,CAAP,EAAOh0B,G,QAEf,EApGA,GAsGAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAI4K,GAA2B5K,EAA/B,IC7GnD,IAAM,GAAO,sBAMb,cAYI,aAVgB,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAEV,KAAAgN,UAAW,CAEJ,CAiCnB,OA9BI,sBAAW,sBAAO,C,IAAlB,WACI,OAAO/jC,KAAK+jC,QAChB,E,gCAEO,YAAA5M,QAAP,WAAkB,EAGX,YAAAlB,wBAAP,SAAgCF,EAAiBzb,EAAiB5N,GAAlE,WACI,OAAO,IAAIpF,SAAQ,SAACC,GAChB,IAAIknC,GAAgB,EAEhB/hC,aAA2B,EAAA69B,YAC3BkE,EAAgB/hC,EAAgBg+B,MACzBh+B,aAA2B,EAAA8yB,mBAClCiP,EAAgB/hC,EAAgBgiC,iBAGhCD,IACA,EAAK1K,UAAW,EAEO,MAAnBzpB,EAAK5C,aACL4C,EAAK5C,WAAa,CAAC,GAGvB4C,EAAK5C,WAAW,IAAQ,CAAC,GAG7BnQ,EAAQ+S,EACZ,GACJ,EACJ,EA7CA,GA+CAsb,GAAawB,kBAAkB,IAAM,WAAM,WAAIuX,EAAJ,ICpD3C,IAAM,GAAO,uBAMb,cAcI,WAAY/K,GAZI,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAIV,KAAAgN,UAAW,EAGf/jC,KAAK2N,UAAYi2B,CACrB,CAyFJ,OAvFW,YAAAzM,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCASO,YAAA7N,qCAAP,SAA6CH,EAAiBzb,EAAiB5N,GAC3E,IAAM67B,EAAoC,GAE1C,OAAI77B,aAA2B,EAAA69B,aACvBvqC,KAAKwqC,oBAAoB99B,IACrBA,EAAgBw9B,WAAWE,kBAC3B7B,EAAmBjmC,KAAKoK,EAAgBw9B,WAAWE,kBAEhD7B,GAIRA,CACX,EAEQ,YAAAiC,oBAAR,SAA4BtnC,GAExB,GAAIA,EAAIwnC,MACJ,OAAO,EAEX,IAAMT,EAAO/mC,EAAIgnC,WAEjB,SAAKD,EAAKwB,sBAAwBxB,EAAKU,yBAITrqC,MAAzB2pC,EAAKc,kBAA0D,GAAzBd,EAAKc,kBACfzqC,MAA5B2pC,EAAK2E,qBAAoC3E,EAAK2E,qBAAuBjzB,OAAOkzB,mBAC1DvuC,MAAlB2pC,EAAK6E,WAA0B7E,EAAK6E,WAAa,EAAAllC,OAAOE,SACzD9J,KAAK6tC,sBAAsB3qC,GAEnC,EAEQ,YAAA2qC,sBAAR,SAA8B3qC,GAC1B,OAA0C,MAAnCA,EAAIgnC,WAAWE,gBAC1B,EAUO,YAAAnU,wBAAP,SAAgCF,EAAiBzb,EAAiB5N,GAAlE,WACI,OAAO,IAAIpF,SAAQ,SAACC,G,MAChB,GAAImF,aAA2B,EAAA69B,aAAe,EAAKC,oBAAoB99B,GAAkB,CACrF,EAAKq3B,UAAW,EAEhB,IAAMkG,EAAOv9B,EAAgBw9B,WAMvBoE,EAAkC,CACpCS,gBAN6C,GAAzB9E,EAAKc,sBAAwBzqC,EAAY2pC,EAAKc,iBAOlEX,iBAN2F,QAAtE,IAAKz8B,UAAUomB,kBAAkBhmB,eAAek8B,EAAKG,yBAAiB,aAAI9pC,EAO/F0uC,oBANwB/E,EAAK2E,qBAAuBjzB,OAAOkzB,uBAAoBvuC,EAAY2pC,EAAK2E,oBAOhGK,iBANqBhF,EAAK6E,UAAUzD,aAAa,EAAK,EAAK,QAAO/qC,EAAY2pC,EAAK6E,UAAUv/B,WAS7F,EAAKs+B,sBAAsBnhC,IAC3B,EAAKiB,UAAUqB,qBAAqBC,IAAIvC,GAG5C4N,EAAK5C,WAAa4C,EAAK5C,YAAc,CAAC,EACtC4C,EAAK5C,WAAW,IAAQ42B,CAC5B,CACA/mC,EAAQ+S,EACZ,GACJ,EACJ,EAzGA,GA2GAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAIsL,GAAqBtL,EAAzB,IClHnD,IAAM,GAAO,kCAMb,cAcI,WAAYA,GAZI,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAIV,KAAAgN,UAAW,EAGf/jC,KAAK2N,UAAYi2B,CACrB,CAoDJ,OAlDW,YAAAzM,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCAEO,YAAA7N,qCAAP,SAA6CH,EAAiBzb,EAAiB5N,GAC3E,IAAM67B,EAAoC,GAC1C,OAAI77B,aAA2B,EAAA01B,iBACvB11B,EAAgByiC,uBACZziC,EAAgB0iC,8BAChB7G,EAAmBjmC,KAAKoK,EAAgB0iC,8BAErC7G,GAIR,EACX,EAGO,YAAAtS,wBAAP,SAAgCF,EAAiBzb,EAAiB5N,GAAlE,WACI,OAAO,IAAIpF,SAAQ,SAACC,GAChB,GAAImF,aAA2B,EAAA01B,gBAAiB,CAC5C,IAAK11B,EAAgByiC,sBAEjB,YADA5nC,EAAQ+S,GAIZ,EAAKypB,UAAW,EAEhBzpB,EAAK5C,WAAa4C,EAAK5C,YAAc,CAAC,EAEtC,IAAM23B,EAA8B,EAAK1hC,UAAUomB,kBAAkBhmB,eAAerB,EAAgB0iC,8BAE9FE,EAAsD,CACxDC,uBAAwB7iC,EAAgByiC,sBACxCK,wBAAyBH,QAAAA,OAA+B/uC,GAGP,OAAjDgvC,EAAqBE,yBACrB,EAAK7hC,UAAUqB,qBAAqBC,IAAIvC,GAG5C4N,EAAK5C,WAAW,IAAQ43B,CAC5B,CACA/nC,EAAQ+S,EACZ,GACJ,EACJ,EApEA,GAsEAsb,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAI6L,GAAgC7L,EAApC,IC7EnD,IAAM,GAAO,wBAqBb,cAaI,aAXgB,KAAAjhC,KAAO,GAGhB,KAAAg0B,SAAU,EAGV,KAAAI,UAAW,EAGV,KAAAgN,UAAW,CAEJ,CAwEnB,OAtEW,YAAA5M,QAAP,WAAkB,EAGlB,sBAAW,sBAAO,C,IAAlB,WACI,OAAOn3B,KAAK+jC,QAChB,E,gCAEO,YAAA5N,kBAAP,SAA0BJ,EAAiBvnB,EAA2BvE,GAUlE,GATcA,EAAelG,YAEzB,EAAAgB,MAAMC,KAAK,UAAG+wB,EAAO,wDAAgD9rB,EAAetH,KAAI,MAOhE,IAAxBsH,EAAeylC,MAAsC,IAAxBzlC,EAAe0lC,OAC5C,EAAA5qC,MAAMC,KAAK,UAAG+wB,EAAO,qBAAa9rB,EAAetH,KAAI,gEAGd,IAAnCsH,EAAe2lC,iBAA4D,IAAnC3lC,EAAe4lC,iBAJ/D,CASA,IAAMC,EAAyC,CAAC,EAC5CC,GAAsB,EAY1B,GAV+B,IAA3B9lC,EAAe+lC,SAA4C,IAA3B/lC,EAAegmC,UAC/CH,EAAiBj+B,OAAS,CAAC5H,EAAe+lC,QAAS/lC,EAAegmC,SAClEF,GAAsB,GAGI,IAA1B9lC,EAAeimC,QAA0C,IAA1BjmC,EAAekmC,SAC9CL,EAAiB7jC,MAAQ,CAAChC,EAAeimC,OAAQjmC,EAAekmC,QAChEJ,GAAsB,GAGE,IAAxB9lC,EAAemmC,KAAY,CAC3B,GAAuC,IAAnCnmC,EAAe2lC,iBAA4D,IAAnC3lC,EAAe4lC,gBAAuB,CAE9E,GAAI5lC,EAAeomC,kCAAoCpmC,EAAeimC,SAAWjmC,EAAekmC,OAI5F,YAHA,EAAAprC,MAAMC,KACF,UAAG+wB,EAAO,qBAAa9rB,EAAetH,KAAI,qHAA6G,GAAI,MAInK,EAAAoC,MAAMC,KAAK,UAAG+wB,EAAO,qBAAa9rB,EAAetH,KAAI,2FAAmF,GAAI,MAC5ImtC,EAAiBj+B,OA/EjC,SAAuC5H,GAC3B,IAAA+lC,EAA6E/lC,EAAc,QAAlFgmC,EAAoEhmC,EAAc,QAAzE2lC,EAA2D3lC,EAAc,gBAAxD4lC,EAA0C5lC,EAAc,gBAAvCimC,EAAyBjmC,EAAc,OAA/BkmC,EAAiBlmC,EAAc,OAAvBmmC,EAASnmC,EAAc,KAC7FqmC,EAAW5kC,KAAK6kC,IAAIH,GACpBI,EAAW9kC,KAAK+kC,IAAIL,GACpBM,EAAwBd,EAAkBM,EAC1CS,EAAwBd,EAAkBM,EAGhD,MAAO,CAACH,GAFOU,GAAyB,EAAIJ,GAAYK,EAAwBH,GAEtDP,GADXU,GAAyB,EAAIL,GAAYI,EAAwBF,GAEpF,CAsE0CI,CAA8B3mC,EAC5D,CACA6lC,EAAiBrxB,UAAYxU,EAAemmC,KAC5CL,GAAsB,CAC1B,CAEwC,IAApC9lC,EAAe8M,mBACf+4B,EAAiBr4B,SAAWxN,EAAe8M,iBAC3Cg5B,GAAsB,GAGrBA,IAIL/vC,KAAK+jC,UAAW,EACXv1B,EAAYkJ,aACblJ,EAAYkJ,WAAa,CAAC,GAE9BlJ,EAAYkJ,WAAW,IAAQo4B,EA5C/B,CA6CJ,EACJ,EArFA,GAuFAla,GAAawB,kBAAkB,IAAM,WAAM,WAAIyZ,EAAJ,IC3G3C,IAAM,GAAO,qBAMb,cAeI,WAAYjN,GAdI,KAAAjhC,KAAO,GAEhB,KAAAg0B,SAAU,EAEV,KAAAI,UAAW,EAEV,KAAAgN,UAAW,EASf/jC,KAAK2N,UAAYi2B,CACrB,CAyBJ,OAjCI,sBAAW,sBAAO,C,IAAlB,WACI,OAAO5jC,KAAK+jC,QAChB,E,gCAQO,YAAA5M,QAAP,WAAkB,EAEX,YAAAhB,kBAAP,SAAyB/tB,EAAWoG,GAChC,IAAMoB,EAAU5P,KAAK2N,UAAUgJ,UAAUnI,EAAYO,OAC/C6H,EAAahH,EAAQxF,OAC3B,QAAmB9J,IAAfsW,EAAJ,CAIA,IAAM+B,EAAQ3Y,KAAK2N,UAAUkL,QAAQjC,GAEd,gBADA+B,EAAMnO,WAAY,IAAAjE,aAAYoS,EAAMa,QAK3D5J,EAAQxF,YAAS9J,EACjBsP,EAAQ8H,aAAR9H,EAAQ8H,WAAe,CAAC,GACxB9H,EAAQ8H,WAAW,IAAQ,CACvBtN,OAAQwM,GAGZ5W,KAAK+jC,UAAW,EAdhB,CAeJ,EACJ,EA1CA,GA4CAnO,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAIkN,GAAmBlN,EAAvB,IClDnD,IAAM,GAAO,mBAMb,cAeI,WAAYA,GAdI,KAAAjhC,KAAO,GAEhB,KAAAg0B,SAAU,EAEV,KAAAI,UAAW,EAEV,KAAAgN,UAAW,EASf/jC,KAAK2N,UAAYi2B,CACrB,CAyBJ,OAjCI,sBAAW,sBAAO,C,IAAlB,WACI,OAAO5jC,KAAK+jC,QAChB,E,gCAQO,YAAA5M,QAAP,WAAkB,EAEX,YAAAhB,kBAAP,SAAyB/tB,EAAWoG,GAChC,IAAMoB,EAAU5P,KAAK2N,UAAUgJ,UAAUnI,EAAYO,OAC/C6H,EAAahH,EAAQxF,OAC3B,QAAmB9J,IAAfsW,EAAJ,CAIA,IAAM+B,EAAQ3Y,KAAK2N,UAAUkL,QAAQjC,GAEd,gBADA+B,EAAMnO,WAAY,IAAAjE,aAAYoS,EAAMa,QAK3D5J,EAAQxF,YAAS9J,EACjBsP,EAAQ8H,aAAR9H,EAAQ8H,WAAe,CAAC,GACxB9H,EAAQ8H,WAAW,IAAQ,CACvBtN,OAAQwM,GAGZ5W,KAAK+jC,UAAW,EAdhB,CAeJ,EACJ,EA1CA,GA4CAnO,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAImN,GAAiBnN,EAArB,IClDnD,IAAM,GAAO,mBAOb,cAeI,WAAYA,GAdI,KAAAjhC,KAAO,GAEhB,KAAAg0B,SAAU,EAEV,KAAAI,UAAW,EAEV,KAAAgN,UAAW,EASf/jC,KAAK2N,UAAYi2B,CACrB,CAyBJ,OAjCI,sBAAW,sBAAO,C,IAAlB,WACI,OAAO5jC,KAAK+jC,QAChB,E,gCAQO,YAAA5M,QAAP,WAAkB,EAEX,YAAAhB,kBAAP,SAAyB/tB,EAAWoG,GAChC,IAAMoB,EAAU5P,KAAK2N,UAAUgJ,UAAUnI,EAAYO,OAC/C6H,EAAahH,EAAQxF,OAC3B,QAAmB9J,IAAfsW,EAAJ,CAIA,IAAM+B,EAAQ3Y,KAAK2N,UAAUkL,QAAQjC,GAEd,gBADA+B,EAAMnO,WAAY,IAAAjE,aAAYoS,EAAMa,QAK3D5J,EAAQxF,YAAS9J,EACjBsP,EAAQ8H,aAAR9H,EAAQ8H,WAAe,CAAC,GACxB9H,EAAQ8H,WAAW,IAAQ,CACvBtN,OAAQwM,GAGZ5W,KAAK+jC,UAAW,EAdhB,CAeJ,EACJ,EA1CA,GA4CAnO,GAAawB,kBAAkB,IAAM,SAACwM,GAAa,WAAIoN,GAAiBpN,EAArB,IClDnD,+BAqJA,QAxIkB,EAAAqN,UAAd,SACIlvC,EACAmvC,EACAzZ,EACA0Z,EACAC,EACAC,EACAC,EACAC,QANA,IAAAL,IAAAA,GAAA,QACA,IAAAzZ,IAAAA,EAAA,gBACA,IAAA0Z,IAAAA,GAAA,QACA,IAAAC,IAAAA,GAAA,QACA,IAAAC,IAAAA,GAAA,QACA,IAAAC,IAAAA,GAAA,QACA,IAAAC,IAAAA,GAAA,GAIA,IAAMC,EAAc,SAAU/sC,EAAcgtC,EAAextC,GACvD,IAAMb,EAAK,CAAc,EAAbqB,EAAQR,GAAyB,EAAjBQ,EAAQR,EAAI,GAAyB,EAAjBQ,EAAQR,EAAI,IACtD7B,EAAI,CACN,IAAI,EAAA6X,QAAQw3B,EAASruC,EAAG,IAAKquC,EAASruC,EAAG,GAAK,GAAIquC,EAASruC,EAAG,GAAK,IACnE,IAAI,EAAA6W,QAAQw3B,EAASruC,EAAG,IAAKquC,EAASruC,EAAG,GAAK,GAAIquC,EAASruC,EAAG,GAAK,IACnE,IAAI,EAAA6W,QAAQw3B,EAASruC,EAAG,IAAKquC,EAASruC,EAAG,GAAK,GAAIquC,EAASruC,EAAG,GAAK,KAEjEsuC,EAAOtvC,EAAE,GAAGkR,SAASlR,EAAE,IACvBuvC,EAAOvvC,EAAE,GAAGkR,SAASlR,EAAE,IAG7B,MAAO,CAAEA,EAAC,EAAEyE,EAFF,EAAAoT,QAAQ23B,MAAMD,EAAMD,GAAMzkB,YAGxC,EAEM4kB,EAAc,SAAUC,EAAejgC,EAAgBkgC,EAAiBX,GAG1E,OAFAv/B,EAASmgC,EAAWF,EAAUjgC,EAAQkgC,EAAOj0B,EAAGszB,GAChDv/B,EAASmgC,EAAWF,EAAUjgC,EAAQkgC,EAAO5pC,EAAGipC,GACzCY,EAAWF,EAAUjgC,EAAQkgC,EAAOh0B,EAAGqzB,EAClD,EAEMY,EAAa,SAAUF,EAAejgC,EAAgBhQ,EAAeuvC,GAEvE,OADAU,EAAStwB,WAAW3P,EAAQhQ,EAAOuvC,GAC5Bv/B,EAAS,CACpB,EAEMtO,EAAkB,SAAUd,GAC9B,GAAI6uC,EAAwB,CACxB,IAAI7Q,EAAah+B,EACbA,aAAgB,EAAA+9B,gBAChBC,EAAah+B,EAAKg+B,YAEtB,IAAM,EAAOA,EAAWl9B,gBAAgB,EAAA4Y,aAAaC,cAAc,GAAM,GACzE,IAAK,EACD,MAAO,GAEX,IAAM61B,EAAO,EAAAh4B,QAAQG,OACjBrL,OAAK,EACT,IAAKA,EAAQ,EAAGA,EAAQ,EAAKvM,OAAQuM,GAAS,EAC1C,EAAAkL,QAAQi4B,oCAAoC,EAAKnjC,GAAQ,EAAKA,EAAQ,GAAI,EAAKA,EAAQ,GAAItM,EAAKK,oBAAmB,GAAOmvC,GAAM5mB,QAAQ,EAAMtc,GAElJ,OAAO,CACX,CACI,OAAOtM,EAAKc,gBAAgB,EAAA4Y,aAAaC,eAAiB,EAElE,EAEIk1B,IACAD,GAAqB,GAGzB,IAAI1mC,EAA0B,GAE1BwnC,EAAY,EACZtgC,EAAS,EAEb,GAAIs/B,EAAQ,CACR,IAAK,IAAIltC,EAAI,EAAGA,EAAIlC,EAAOS,OAAQyB,IAG/BkuC,IADM1tC,GADAhC,EAAOV,EAAOkC,IACCN,cACEc,EAAQjC,OAAS,EAAI,EAGhD,IACM8H,EAAS,IAAIM,YADA,GAAK,GAAKunC,GAI7BtgC,GAAU,IAFVlH,EAAO,IAAIkX,SAASvX,IAGfiX,UAAU1P,EAAQsgC,EAAWf,GAClCv/B,GAAU,CACd,MACS0/B,IACD5mC,EAAO,qBAIf,IAAS1G,EAAI,EAAGA,EAAIlC,EAAOS,OAAQyB,IAAK,CACpC,IAAMxB,EAAOV,EAAOkC,IACfktC,GAAUI,IACX5mC,GAAQ,SAAWlI,EAAKE,KAAO,SAE9B0uC,GAAsB5uC,aAAgB,EAAAolB,MACvCplB,EAAK2vC,mCAKT,IAHA,IAAMX,EAAWluC,EAAgBd,GAC3BgC,EAAUhC,EAAKkB,cAAgB,GAE5B,EAAI,EAAG,EAAIc,EAAQjC,OAAQ,GAAK,EAAG,CACxC,IAAM6vC,EAAKb,EAAY/sC,EAASgtC,EAAU,GAEtCN,GACAt/B,EAASggC,EAAYlnC,EAAMkH,EAAQwgC,EAAGxrC,EAAGuqC,GACzCv/B,EAASggC,EAAYlnC,EAAMkH,EAAQwgC,EAAGjwC,EAAE,GAAIgvC,GAC5Cv/B,EAASggC,EAAYlnC,EAAMkH,EAAQwgC,EAAGjwC,EAAE,GAAIgvC,GAC5Cv/B,EAASggC,EAAYlnC,EAAMkH,EAAQwgC,EAAGjwC,EAAE,GAAIgvC,GAC5Cv/B,GAAU,IAEVlH,GAAQ,kBAAoB0nC,EAAGxrC,EAAEiX,EAAI,IAAMu0B,EAAGxrC,EAAEsB,EAAI,IAAMkqC,EAAGxrC,EAAEkX,EAAI,OACnEpT,GAAQ,qBACRA,GAAQ,gBAAkB0nC,EAAGjwC,EAAE,GAAG0b,EAAI,IAAMu0B,EAAGjwC,EAAE,GAAG+F,EAAI,IAAMkqC,EAAGjwC,EAAE,GAAG2b,EAAI,OAC1EpT,GAAQ,gBAAkB0nC,EAAGjwC,EAAE,GAAG0b,EAAI,IAAMu0B,EAAGjwC,EAAE,GAAG+F,EAAI,IAAMkqC,EAAGjwC,EAAE,GAAG2b,EAAI,OAC1EpT,GAAQ,gBAAkB0nC,EAAGjwC,EAAE,GAAG0b,EAAI,IAAMu0B,EAAGjwC,EAAE,GAAG+F,EAAI,IAAMkqC,EAAGjwC,EAAE,GAAG2b,EAAI,OAC1EpT,GAAQ,kBACRA,GAAQ,iBAEhB,EACKwmC,GAAUI,IACX5mC,GAAQ,YAAchI,KAAO,OAErC,CAMA,GAJKwuC,GAAWI,IACZ5mC,GAAQ,oBAGRumC,EAAU,CACV,IAAM3lC,EAAI+mC,SAASC,cAAc,KAC3BnsC,EAAO,IAAIC,KAAK,CAACsE,GAAO,CAAErE,KAAM,6BACtCiF,EAAEinC,KAAOpxC,OAAOqxC,IAAIC,gBAAgBtsC,GACpCmF,EAAE2lC,SAAWzZ,EAAW,OACxBlsB,EAAEonC,OACN,CAEA,OAAOhoC,CACX,EACJ,EArJA,GCmIA,SAASioC,GAAkBC,EAAuB9f,EAA6B+f,EAAYppB,QAAZ,IAAAopB,IAAAA,EAAA,QAAY,IAAAppB,IAAAA,GAAA,GAGvF,IAFA,IAAMqE,EAAkB,GAEf9pB,EAAI,EAAGA,EAAI4uC,EAAUrwC,OAASswC,EAAQ7uC,IAAK,CAChD,IAAM6Z,EAAI+0B,EAAU5uC,EAAI6uC,IAAWppB,GAAwB,EAAI,GACzDvhB,EAAI0qC,EAAU5uC,EAAI6uC,EAAS,GAC3B/0B,EAAI80B,EAAU5uC,EAAI6uC,EAAS,GAEjC/kB,EAAMzrB,KAAK,WAAIwb,EAAEi1B,YAAYhgB,EAAQigB,WAAU,aAAK7qC,EAAE4qC,YAAYhgB,EAAQigB,WAAU,aAAKj1B,EAAEg1B,YAAYhgB,EAAQigB,WAAU,KAC7H,CAEA,OAAOjlB,EAAM9oB,KAAK,KACtB,CAEA,SAASguC,GAAkBJ,EAAuB9f,GAG9C,IAFA,IAAMhF,EAAkB,GAEf9pB,EAAI,EAAGA,EAAI4uC,EAAUrwC,OAAS,EAAGyB,IAAK,CAC3C,IAAM6Z,EAAI+0B,EAAc,EAAJ5uC,GACdkE,EAAI0qC,EAAc,EAAJ5uC,EAAQ,GAE5B8pB,EAAMzrB,KAAK,WAAIwb,EAAEi1B,YAAYhgB,EAAQigB,WAAU,cAAM,EAAI7qC,GAAG4qC,YAAYhgB,EAAQigB,WAAU,KAC9F,CAEA,OAAOjlB,EAAM9oB,KAAK,KACtB,CAwDA,SAASiuC,GAAgB7vC,EAAoB0vB,EAA6BogB,EAAsBzpB,GAC5F,IAAM0pB,EA1BV,SAAmB/vC,EAAoB0vB,EAA6BogB,EAAsBzpB,GACtF,IACMiE,EAAWtqB,EAASE,gBAAgB,EAAA4Y,aAAaC,cACjDi3B,EAAShwC,EAASE,gBAAgB,EAAA4Y,aAAaE,YAErD,GAAKsR,GAAa0lB,EAIlB,MAAO,wBARM,WASA,wDAEsBF,EAAY,4CA9FnD,SAA8B9vC,G,MACpBwY,GAA6B,QAArB,EAAAxY,EAASM,oBAAY,eAAEnB,QAASa,EAASiwC,kBAAoBjwC,EAASqY,mBAEpF,OAAOpS,MAAMuS,EAAQ,GAChB2lB,KAAK,GACLv8B,KAAK,KACd,CAyF8BsuC,CAAqBlwC,GAAS,6CAvF5D,SAAgCA,G,MACtBoB,EAAUpB,EAASM,aACnBkY,EAAuB,QAAf,EAAApX,aAAO,EAAPA,EAASjC,cAAM,QAAIa,EAASqY,mBAEpCqS,EAAkB,GACxB,GAAgB,OAAZtpB,EACA,IAAK,IAAIR,EAAI,EAAGA,EAAI4X,EAAO5X,IACvB8pB,EAAMzrB,KAAKmC,EAAQR,SAGvB,IAASA,EAAI,EAAGA,EAAI4X,EAAO5X,IACvB8pB,EAAMzrB,KAAK2B,GAInB,OAAO8pB,EAAM9oB,KAAK,KACtB,CAwE+BuuC,CAAuBnwC,GAAS,wCACrCuvC,GAAkBS,EAAQtgB,OAASzyB,EAAWopB,GAAqB,+EAGrEkpB,GAAkBjlB,EAAUoF,OAASzyB,EAAWopB,GAAqB,sBA/C7F,SAAmCrmB,EAAoB0vB,GAGnD,IAFA,IAAI0gB,EAAS,GAEJxvC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,IAAMb,EAAKa,EAAI,EAAIA,EAAI,GACjByvC,EAAcrwC,EAASE,gBAAgB,EAAA4Y,aAAaS,QAAUxZ,EAAKA,EAAK,EAAI,KAE9EswC,IACAD,GAAU,wCACMrwC,EAAE,eAAO6vC,GAAkBS,EAAa3gB,GAAQ,8CAIxE,CAIA,IAAM4gB,EAAiBtwC,EAASE,gBAAgB,EAAA4Y,aAAaI,WAS7D,OAPIo3B,IACAF,GAAU,iDACoBb,GAAkBe,EAAgB5gB,EAAS4gB,EAAenxC,OAASa,EAASqY,oBAAmB,6CAK1H+3B,CACX,CAqBUG,CAA0BvwC,EAAU0vB,GAAQ,wDAItD,CAGuB8gB,CAAUxwC,EAAU0vB,EAASogB,EAAczpB,GAC9D,MAAO,uDAGD0pB,EAAU,wBAGpB,CAEA,SAASU,GAAqBC,GAC1B,IAAI5xC,EApKG,4MAsKP,OADAA,GAAU4xC,EACHC,OAAOC,QAAQ9xC,EAC1B,CAEA,SAAS+xC,GAAY/0B,GACjB,IAAM4O,EAAQ5O,EAAOha,EAErB,MAAO,YAAKgvC,GAAepmB,EAAO,GAAE,aAAKomB,GAAepmB,EAAO,GAAE,aAAKomB,GAAepmB,EAAO,GAAE,aAAKomB,GAAepmB,EAAO,IAAG,KAChI,CAEA,SAASomB,GAAepmB,EAAiBlc,GACrC,MAAO,WAAIkc,EAAMlc,EAAS,GAAE,aAAKkc,EAAMlc,EAAS,GAAE,aAAKkc,EAAMlc,EAAS,GAAE,aAAKkc,EAAMlc,EAAS,GAAE,IAClG,CAEA,SAASuiC,GAAW3xC,EAAY0c,GAC5B,IAAMxc,EAAO,UAAYF,EAAK6V,SACxBzV,EAAYqxC,GAAY/0B,GAE9B,MAAO,qBAAcxc,EAAI,8DACkBF,EAAKY,SAAUiV,SAAQ,kHAItCzV,EAAS,8HAGcJ,EAAKU,SAAUmV,SAAQ,WAI9E,CAoBA,SAAS+7B,GAAcC,GACnB,OAAQA,GACJ,KAAK,EAAAnlC,UAAUolC,0BACX,MAAO,QACX,KAAK,EAAAplC,UAAUqlC,2BACX,MAAO,SACX,KAAK,EAAArlC,UAAUslC,yBACf,QACI,MAAO,SAEnB,CAMA,SAASC,GAAa3C,GAClB,MAAO,WAAIA,EAAOj0B,EAAC,aAAKi0B,EAAO5pC,EAAC,IACpC,CAEA,SAASwsC,GAAWlhC,GAChB,MAAO,WAAIA,EAAM/R,EAAC,aAAK+R,EAAMzS,EAAC,aAAKyS,EAAMjO,EAAC,IAC9C,CAEA,SAASovC,GACLhlC,EACAzM,EACA0xC,EACAphC,EACAqhC,EACA/hB,GAEA,IAAM3vB,EAAKwM,EAAQzF,qBAAsBmO,SAAW,IAAM1I,EAAQvF,QAElEyqC,EAAiB1xC,GAAMwM,EAEvB,IAAMmlC,EAAKnlC,EAAQmH,iBAAmB,EAAI,KAAOnH,EAAQmH,iBAAmB,KACtEi+B,EAAS,IAAI,EAAAC,QAAQrlC,EAAQsgC,OAAQtgC,EAAQugC,QAC7Ct+B,EAAS,IAAI,EAAAojC,QAAQrlC,EAAQogC,QAASpgC,EAAQqgC,SAC9CxxB,EAAW7O,EAAQwgC,KAGnB8E,EAAkBxpC,KAAK+kC,IAAIhyB,GAC3B02B,EAAkBzpC,KAAK6kC,IAAI9xB,GAQjC,OALA5M,EAAO1J,EAAI,EAAI0J,EAAO1J,EAAI6sC,EAAO7sC,EAEjC0J,EAAOiM,GAAKo3B,EAAkBF,EAAOl3B,EACrCjM,EAAO1J,IAAM,EAAIgtC,GAAmBH,EAAO7sC,EAEpC,0CACqB0sC,EAAO,6JAILE,EAAE,kFAINF,EAAO,mIAGyB1xC,EAASmV,SAAQ,0BAAkBu8B,EAAO,8DACrEp2B,GAAY,IAAM/S,KAAKm7B,KAAKxhC,QAAQ0tB,EAAQigB,WAAU,2CACzD0B,GAAaM,GAAO,iDACdN,GAAa7iC,GAAO,6EAIhCjC,EAAQ0I,SAAQ,YAAIu8B,EAAO,mHAGLzxC,EAAE,+EACaD,EAASmV,SAAQ,wBAAgBu8B,EAAO,qCAC7FphC,EAAQ,yBA/DlB,SAAqBA,GACjB,MAAO,WAAIA,EAAM/R,EAAC,aAAK+R,EAAMzS,EAAC,aAAKyS,EAAMjO,EAAC,SAC9C,CA6D6C4vC,CAAY3hC,GAAS,GAAE,sDACzB7D,EAAQylC,WAAa,OAAS,MAAK,4CAC9ChB,GAAczkC,EAAQ8E,OAAM,4CAC5B2/B,GAAczkC,EAAQgF,OAAM,6HAKlDzR,EAASwJ,qBAAuBxJ,EAAS0J,mBAAqB,kBAAoB,GAAE,UAE9F,CAsEA,SAASyoC,GAAcnyC,EAAoB2xC,EAAkD/hB,GAGzF,IAAMwiB,EAAM,SACNnwB,EAAS,GACTvL,EAAW,GAEX,EA3EV,SAAoC1W,G,QAC1BqyC,EAAW,CACbC,WAAY,KACZrqC,QAAS,KACT2B,YAAa,EACb2oC,YAAa,KACbC,SAAU,KACVC,UAAW,KACXC,aAAc,KACdC,iBAAkB,IAClB3pC,UAAW,EACX4pC,aAAc,KACdC,iBAAkB,IAClBC,UAAW,EACXC,MAAO,KACPC,aAAc,MACdC,eAAgB,EAChBC,SAAU,KACVhK,IAAK,EACLiK,kBAAkB,EAClBrN,UAAW,EACXsN,aAAc,KACdC,mBAAoB,EACpBC,sBAAuB,MAG3B,OAAItzC,aAAoB,EAAAq8B,iBACb,OACAgW,GAAQ,CACXC,WAAYtyC,EAAS0C,eACrBuF,QAASjI,EAASsC,aAClBsH,YAAa5J,EAAS4J,YACtB2oC,YAAavyC,EAASyL,gBACtB+mC,SAAUxyC,EAASwC,cACnBwG,UAAW,EACXkqC,SAAUlzC,EAAS6C,iBAGvB7C,aAAoB,EAAAi/B,gBACb,OACAoT,GAAQ,CACXC,WAAYtyC,EAAS8Q,eACrB7I,QAASjI,EAAS0Q,aAClB9G,YAAa5J,EAASuzC,aACtBhB,YAAavyC,EAAS2U,iBACtB69B,SAAUxyC,EAAS4U,eACnB69B,UAAWzyC,EAASoU,aACpBs+B,aAAc1yC,EAASiR,iBACvB0hC,iBAAkB3yC,EAASwzC,sCAAwC,IAAM,IACzExqC,UAA8B,QAAnB,EAAAhJ,EAAS4Q,kBAAU,QAAI,EAClCgiC,aAAc5yC,EAASiR,iBACvB4hC,iBAAkB7yC,EAASyzC,sCAAwC,IAAM,IACzEX,UAA6B,QAAlB,EAAA9yC,EAAS2Q,iBAAS,QAAI,EACjCoiC,MAAO/yC,EAASqU,gBAChB2+B,aAAchzC,EAAS0zC,uBAAyB,IAAM,MACtDT,eAAgBjzC,EAASyU,wBACzBy+B,SAAUlzC,EAAS2zC,gBACnBzK,IAAKlpC,EAAS+mC,WAAWiC,kBACzBmK,iBAAkBnzC,EAAS8lC,UAAUR,UACrCQ,UAAW9lC,EAAS8lC,UAAUzC,UAC9B+P,aAAcpzC,EAAS8lC,UAAUr5B,QACjC4mC,mBAAoBrzC,EAAS8lC,UAAU98B,UACvCsqC,sBAAuBtzC,EAAS8lC,UAAUC,4BAA8B/lC,EAAS8lC,UAAUr5B,QAAUzM,EAAS8lC,UAAUE,mBAGzHqM,CACX,CAgCQuB,CAA2B5zC,GAtB3BsyC,EAAU,aACVrqC,EAAO,UACP2B,EAAW,cACX2oC,EAAW,cACXC,EAAQ,WACRC,EAAS,YACTC,EAAY,eACZC,EAAgB,mBAChB3pC,EAAS,YACT4pC,EAAY,eACZC,EAAgB,mBAChBC,EAAS,YACTC,EAAK,QACLC,EAAY,eACZC,EAAc,iBACdC,EAAQ,WACRhK,EAAG,MACHiK,EAAgB,mBAChBrN,EAAS,YACTsN,EAAY,eACZC,EAAkB,qBAClBC,EAAqB,wBA8FzB,OA3FmB,OAAfhB,GACArwB,EAAO9iB,KAAK,UAAGizC,EAAG,2EAAmEpyC,EAASmV,SAAQ,oBAAYm9B,EAAWn9B,SAAQ,0BAEjInV,EAASwJ,oBACTyY,EAAO9iB,KAAK,UAAGizC,EAAG,oEAA4DpyC,EAASmV,SAAQ,oBAAYm9B,EAAWn9B,SAAQ,wBACvHnV,EAAS0J,qBAChBuY,EAAO9iB,KAAK,UAAGizC,EAAG,oEAA4DpyC,EAASmV,SAAQ,oBAAYm9B,EAAWn9B,SAAQ,wBAC9H8M,EAAO9iB,KAAK,UAAGizC,EAAG,2CAAmCxoC,KAGzD8M,EAASvX,KAAKsyC,GAAaa,EAAuBtyC,EAAU,UAAWiI,EAAS0pC,EAAkB/hB,KAElG3N,EAAO9iB,KAAK,UAAGizC,EAAG,yCAAiCZ,GAAWvpC,GAAW,EAAAxB,OAAOE,WAGhE,OAAhB4rC,GACAtwB,EAAO9iB,KAAK,UAAGizC,EAAG,4EAAoEpyC,EAASmV,SAAQ,oBAAYo9B,EAAYp9B,SAAQ,2BAEvIuB,EAASvX,KAAKsyC,GAAac,EAAwBvyC,EAAU,WAAYwyC,EAAUb,EAAkB/hB,KAC9F4iB,GAAYA,EAASqB,cAAgB,GAC5C5xB,EAAO9iB,KAAK,UAAGizC,EAAG,0CAAkCZ,GAAWgB,KAGjD,OAAdC,IACAxwB,EAAO9iB,KAAK,UAAGizC,EAAG,sEAA8DpyC,EAASmV,SAAQ,oBAAYs9B,EAAUt9B,SAAQ,yBAE/HuB,EAASvX,KAAKsyC,GAAagB,EAAsBzyC,EAAU,SAAU,KAAM2xC,EAAkB/hB,KAGnF,OAAVmjB,IACA9wB,EAAO9iB,KAAK,UAAGizC,EAAG,sEAA8DpyC,EAASmV,SAAQ,oBAAY49B,EAAM59B,SAAQ,8BAAsB69B,EAAY,MAE7Jt8B,EAASvX,KAAKsyC,GAAasB,EAAkB/yC,EAAU,YAAa,IAAI,EAAAyG,OAAOwsC,EAAgBA,EAAgBA,GAAiBtB,EAAkB/hB,KAGjI,OAAjB8iB,GACAzwB,EAAO9iB,KACH,UAAGizC,EAAG,sEAA8DpyC,EAASmV,SAAQ,oBAAYu9B,EAAav9B,SAAQ,8BAAsBw9B,EAAgB,MAGhKj8B,EAASvX,KAAKsyC,GAAaiB,EAAyB1yC,EAAU,YAAa,IAAI,EAAAyG,OAAOuC,EAAWA,EAAWA,GAAY2oC,EAAkB/hB,KAE1I3N,EAAO9iB,KAAK,UAAGizC,EAAG,oCAA4BppC,IAG7B,OAAjB4pC,GACA3wB,EAAO9iB,KAAK,UAAGizC,EAAG,qEAA6DpyC,EAASmV,SAAQ,oBAAYy9B,EAAaz9B,SAAQ,6BAAqB09B,EAAgB,MAEtKn8B,EAASvX,KAAKsyC,GAAamB,EAAyB5yC,EAAU,WAAY,IAAI,EAAAyG,OAAOqsC,EAAWA,EAAWA,GAAYnB,EAAkB/hB,KAEzI3N,EAAO9iB,KAAK,UAAGizC,EAAG,mCAA2BU,IAGhC,OAAbI,GACAjxB,EAAO9iB,KAAK,UAAGizC,EAAG,oEAA4DpyC,EAASmV,SAAQ,oBAAY+9B,EAAS/9B,SAAQ,wBAC5H8M,EAAO9iB,KAAK,UAAGizC,EAAG,2CAElB17B,EAASvX,KAAKsyC,GAAayB,EAAqBlzC,EAAU,UAAW,KAAM2xC,EAAkB/hB,KAE7F3N,EAAO9iB,KAAK,UAAGizC,EAAG,kCAA0BpyC,EAASmC,QAGrDgxC,IACqB,OAAjBC,GACAnxB,EAAO9iB,KAAK,UAAGizC,EAAG,sEAA8DpyC,EAASmV,SAAQ,oBAAYi+B,EAAaj+B,SAAQ,0BAClIuB,EAASvX,KAAKsyC,GAAa2B,EAAyBpzC,EAAU,YAAa,IAAI,EAAAyG,OAAOq/B,EAAWA,EAAWA,GAAY6L,EAAkB/hB,KAE1I3N,EAAO9iB,KAAK,UAAGizC,EAAG,oCAA4BtM,IAGpB,OAA1BwN,GACArxB,EAAO9iB,KACH,UAAGizC,EAAG,+EAAuEpyC,EAASmV,SAAQ,oBAAYm+B,EAAsBn+B,SAAQ,mCAE5IuB,EAASvX,KACLsyC,GACI6B,EACAtzC,EACA,qBACA,IAAI,EAAAyG,OAAO4sC,EAAoBA,EAAoBA,GACnD1B,EACA/hB,KAIR3N,EAAO9iB,KAAK,UAAGizC,EAAG,6CAAqCiB,KAI/DpxB,EAAO9iB,KAAK,UAAGizC,EAAG,8BAAsBlJ,IAEjC,qCACelpC,EAASmV,SAAQ,8GAKzC8M,EAAOngB,KAAK,MAAK,2JAK2C9B,EAASmV,SAAQ,+CAE7EuB,EAAS5U,KAAK,MAAK,YAIrB,CAyCA,SAASgyC,GAAwBx0C,G,QAC7BA,EAAKK,oBAAmB,GAQxB,IAPA,IAAMqc,EAAS1c,EAAK+X,iBAAiBwf,QAC/Bkd,EAAqBz0C,EAAKsB,WAAWC,qBACvC+8B,EAA+D,QAA7C,EAAa,QAAb,EAAAt+B,EAAKU,gBAAQ,eAAEiB,yBAAyB3B,UAAK,QAAIA,EAAKs+B,gBACxErX,GAAwBwtB,EAGxBz7B,EAAUhZ,EAAKgd,OACZhE,GAAS,CACZ,GAAIpB,EAAWoB,EAASy7B,IAA0C,OAAnBz7B,EAAQgE,OAAiB,CAC/Dy3B,IAED/3B,EAAOzE,cAAce,EAAQjB,iBAAiB28B,SAAUh4B,GACxD4hB,EAAkBA,IAAoB,EAAA18B,SAASC,yBAA2B,EAAAD,SAAS48B,gCAAkC,EAAA58B,SAASC,0BAElIolB,GAAuB,EACvB,KACJ,CACAjO,EAAUA,EAAQgE,MACtB,CAOA,OALIN,EAAOi4B,cAAgB,GAEvB,EAAAryC,MAAMC,KAAK,eAAQvC,EAAKE,KAAI,oFAGzB,CACHwc,OAAM,EACNg0B,aAAcpS,IAAoB,EAAA18B,SAASC,yBAA2B,aAAe,cACrFolB,qBAAoB,EAE5B,CAYO,SAAe2tB,GAAgBlqC,EAAc4lB,EAAsCukB,G,qKAChFC,EAAe,GACjBC,UAAW,iCACXC,4BAA4B,EAC5BC,cAAe,QACfC,wBAAyB,aACzBC,cAAe,aACf5E,UAAW,EACX6E,cAAc,EACdC,kBAAmB,IAChB/kB,GAIe,oBAAXihB,OAAP,MACA,GAAM,EAAAjvC,MAAMgzC,gBAAgBR,EAAaC,Y,OAAzC,S,iBAeJ,KAXMtxC,EAAgC,CAAC,GAGjCqxC,EAAaK,eAAiB,KAEhCz1C,EA3mBG,4MA4mBPA,GAjmBJ,SAAgC4wB,GAC5B,IAAMilB,GACqC,IAAvCjlB,EAAQ0kB,2BACF,oDAC0B1kB,EAAQ2kB,cAAa,gEACX3kB,EAAQ4kB,wBAAuB,KACnE,GACV,MAAO,iYAaIK,EAAS,iBAExB,CA2kBcC,CAAuBV,GAE3BW,EAAiD,CAAC,EAGnD,EAAL,EAA2B,EAAA/qC,EAAMpL,OAAN,eACiB,KADjCo2C,EAAY,MACFz8B,qBAIXrY,GADAZ,EAAO01C,GACS90C,UAChBF,EAAWV,EAAKU,WAEJE,KAAai0C,GAAkBA,EAAc70C,OAMF,IAFlC,CAAC,mBAAoB,cAAe,gCAExCowB,QAAQ1vB,EAASk/B,iBAC9B+V,EAAmB,uBAAyB/0C,EAASiV,SAAW,QAChE,EAAiD2+B,GAAwBx0C,GAAvE0c,EAAM,SAAEg0B,EAAY,eAAEzpB,EAAoB,uBAE5C0uB,KAAoBlyC,IAChBktC,EAAaF,GAAgB7vC,EAAUk0C,EAAcpE,EAAczpB,GACzExjB,EAAMkyC,GAAoBtE,GAAqBV,IAG7CjwC,EAASmV,YAAY4/B,IACvBA,EAAkB/0C,EAASmV,UAAYnV,GAG3ChB,GAAUiyC,GAAW3xC,EAAM0c,IAE3B,EAAApa,MAAMC,KAAK,wDAA0D7B,EAASk/B,kB,SAKlFl1B,EAAMkrC,cAAgBd,EAAaM,eACnC11C,GApJR,SAAqBk4B,EAAgBtH,GACjC,IAAMpwB,EAAO,UAAY03B,EAAO/hB,SAG1BzV,EAAYqxC,GAFH,EAAAnxC,OAAOu1C,UAAU5sC,KAAKm7B,IAAI/0B,SAASuoB,EAAO7f,mBAIzD,GAAI6f,EAAOE,OAAS,EAAAprB,UAAUopC,oBAC1B,MAAO,sBAAe51C,EAAI,wDAEAE,EAAS,yGAGdw3B,EAAOY,KAAK8X,YAAYhgB,EAAQigB,WAAU,aAAK3Y,EAAOc,KAAK4X,YAAYhgB,EAAQigB,WAAU,gDACd,IAAtEtnC,KAAKyS,IAAIkc,EAAOgB,WAAa,GAAK3vB,KAAKyS,IAAIkc,EAAOiB,YAAc,KAAUyX,YAAYhgB,EAAQigB,WAAU,6CACpC,IAAtEtnC,KAAKyS,IAAIkc,EAAOqB,UAAY,GAAKhwB,KAAKyS,IAAIkc,EAAOoB,aAAe,KAAUsX,YAAYhgB,EAAQigB,WAAU,4DAMhI,IAAMwF,EAASne,EAAOtuB,YAAY4uB,eAAeN,GAC3Coe,EAAc1lB,EAAQ+kB,mBAAqB,GAEjD,MAAO,sBAAen1C,EAAI,wDAEAE,EAAS,yGAGdw3B,EAAOY,KAAK8X,YAAYhgB,EAAQigB,WAAU,aAAK3Y,EAAOc,KAAK4X,YAAYhgB,EAAQigB,WAAU,yCAC5FyF,GAAe,EAAI/sC,KAAKgtC,IAAiB,GAAbre,EAAOU,OAAagY,YAAYhgB,EAAQigB,WAAU,6FAEvEyF,EAAcD,GAAQzF,YAAYhgB,EAAQigB,WAAU,6CACtDyF,EAAcD,GAAQzF,YAAYhgB,EAAQigB,WAAU,8BAKnF,CA+GkB2F,CAAYxrC,EAAMkrC,aAAcd,IAI9Cp1C,GApnBO,6BAwnBPA,GAvdJ,SAAwBH,EAAwC8yC,EAAkD/hB,GAC9G,IAAMhF,EAAkB,GAExB,IAAK,IAAM6qB,KAAQ52C,EAAW,CAC1B,IAAMmB,EAAWnB,EAAU42C,GAE3B7qB,EAAMzrB,KAAKgzC,GAAcnyC,EAAU2xC,EAAkB/hB,GACzD,CAEA,MAAO,oCAGThF,EAAM9oB,KAAK,IAAG,UAIhB,CAucc4zC,CAAeX,EADnBpD,EAAmD,CAAC,EACIyC,GAG9Dp1C,GArnBO,UAwnBP+D,EAAMqxC,EAAaK,eAAiB5D,OAAOC,QAAQ9xC,G,OAGlC2yC,E,+DACPllC,EAAUklC,E,KAEVr8B,EAAO7I,EAAQW,UAED,IAAM,IAAAmI,qBAAoB9I,K,mBAG1B,OAHdkpC,EAAc,SAGA,GAAM,EAAA/oC,UAAUC,cAAcyI,EAAKxL,MAAOwL,EAAKvL,OAAQ4rC,EAAa,iBAAax4C,GAAW,GAAO,I,OAAjHy4C,EAAc,SAEpB7yC,EAAM,2BAAoB9C,EAAE,SAAU,IAAIgK,WAAW2rC,GAA4BxvC,Q,yCAQrF,IAAWyvC,KAFPnnC,EAAS,EAEU3L,GACb+yC,EAAO/yC,EAAM8yC,MAIbE,EAAa,GAAKF,EAASx2C,OAMb,IAFd22C,EAAuB,IAF7BtnC,GAAUqnC,MAMAE,EAAU,IAAIhsC,WADF,GAAK+rC,GAIvBjzC,EAAM8yC,GAAY,CAACC,EAAM,CAAEI,MAAO,CAAE,MAAOD,MAG/CvnC,EAASonC,EAAKz2C,QAGlB,MAAO,CAAP,EAAOwxC,OAAOsF,QAAQpzC,EAAO,CAAEyI,MAAO,K,OCrwB1C,IAAM4qC,QAAiC,IAAX,EAAAv4C,EAAyB,EAAAA,EAA2B,oBAAXI,OAAyBA,YAASd,EACvG,QAA4B,IAAjBi5C,GAA8B,CAC/BA,GAAcC,QAAgBD,GAAcC,SAAW,CAAC,EAC9D,IAAM,GAAgBD,GAAcC,QACpC,GAAQC,MAAQ,GAAQA,OAAS,CAAC,EAClC,GAAQA,MAAMC,SAAW,GAAQD,MAAMC,UAAY,CAAC,EACpD,GAAQD,MAAMC,SAASC,WAAa,GAAQF,MAAMC,SAASC,YAAc,CAAC,EAE1E,IAAMh2B,GAAO,GACb,IAAK,IAAMjjB,MAAO,EACd,GAAQA,IAAa,EAAWA,IAChCijB,GAAKrhB,KAAK5B,IAEd,IAAK,IAAMA,MAAO,EACd,GAAQA,IAAa,EAAOA,IAC5BijB,GAAKrhB,KAAK5B,IAEd,IAAK,IAAMA,MAAO,EACd,GAAQA,IAAa,EAAaA,IAClCijB,GAAKrhB,KAAK5B,IAGd,IAAK,IAAMA,MAAO,EACd,GAAQ+4C,MAAMC,SAASC,WAAWj5C,IAAa,EAAYA,IAC3DijB,GAAKrhB,KAAK5B,IAGd,IAAK,IAAMA,MAAO,EAEVijB,GAAKkP,QAAQnyB,KAAQ,IAIzB,GAAQ+4C,MAAMC,SAASh5C,IAAa,EAAOA,IAEnD,CCvCA,IAAM,QAAiC,IAAX,EAAAM,EAAyB,EAAAA,EAA2B,oBAAXI,OAAyBA,YAASd,EACvG,QAA4B,IAAjB,GACP,IAAK,IAAMs5C,MAAc,EACf,GAAcJ,QAAQI,IAAoB,EAAaA,ICHrE,IAAM,QAAiC,IAAX,EAAA54C,EAAyB,EAAAA,EAA2B,oBAAXI,OAAyBA,YAASd,EACvG,QAA4B,IAAjB,GACP,IAAK,IAAM,MAAc,EACf,GAAck5C,QAAQ,IAAoB,EAAa,ICHrE,IAAM,QAAiC,IAAX,EAAAx4C,EAAyB,EAAAA,EAA2B,oBAAXI,OAAyBA,YAASd,EACvG,QAA4B,IAAjB,GACP,IAAK,IAAM,MAAc,EACf,GAAck5C,QAAQ,IAAoB,EAAa,ICRrE,W","sources":["webpack://SERIALIZERS/webpack/universalModuleDefinition","webpack://SERIALIZERS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://SERIALIZERS/webpack/bootstrap","webpack://SERIALIZERS/webpack/runtime/define property getters","webpack://SERIALIZERS/webpack/runtime/global","webpack://SERIALIZERS/webpack/runtime/hasOwnProperty shorthand","webpack://SERIALIZERS/webpack/runtime/make namespace object","webpack://SERIALIZERS/../../../dev/serializers/src/OBJ/objSerializer.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/glTFFileExporter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFData.ts","webpack://SERIALIZERS/../../../../node_modules/tslib/tslib.es6.mjs","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFMaterialExporter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/exportUtils.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFUtilities.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/dataWriter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/bufferManager.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFAnimation.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFMorphTargetsUtilities.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFExporter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFSerializer.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_lights_punctual.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_ior.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_sheen.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_specular.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_transmission.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_unlit.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_volume.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/EXT_materials_diffuse_roughness.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_texture_basisu.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/EXT_texture_webp.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/EXT_texture_avif.ts","webpack://SERIALIZERS/../../../dev/serializers/src/stl/stlSerializer.ts","webpack://SERIALIZERS/../../../dev/serializers/src/USDZ/usdzExporter.ts","webpack://SERIALIZERS/../../../lts/serializers/src/legacy/legacy-glTF2Serializer.ts","webpack://SERIALIZERS/../../../lts/serializers/src/legacy/legacy-objSerializer.ts","webpack://SERIALIZERS/../../../lts/serializers/src/legacy/legacy-stlSerializer.ts","webpack://SERIALIZERS/../../../lts/serializers/src/legacy/legacy-usdzSerializer.ts","webpack://SERIALIZERS/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-serializers\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-serializers\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"SERIALIZERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__597__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__597__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { Nullable } from \"core/types\";\r\nimport { Matrix } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { Geometry } from \"core/Meshes/geometry\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Material } from \"core/Materials/material\";\r\n\r\n/**\r\n * Class for generating OBJ data from a Babylon scene.\r\n */\r\nexport class OBJExport {\r\n    /**\r\n     * Exports the geometry of a Mesh array in .OBJ file format (text)\r\n     * @param meshes defines the list of meshes to serialize\r\n     * @param materials defines if materials should be exported\r\n     * @param matlibname defines the name of the associated mtl file\r\n     * @param globalposition defines if the exported positions are globals or local to the exported mesh\r\n     * @returns the OBJ content\r\n     */\r\n    public static OBJ(meshes: Mesh[], materials?: boolean, matlibname?: string, globalposition?: boolean): string {\r\n        const output: string[] = [];\r\n        let v = 1;\r\n        // keep track of uv index in case mixed meshes are passed in\r\n        let textureV = 1;\r\n\r\n        if (materials) {\r\n            if (!matlibname) {\r\n                matlibname = \"mat\";\r\n            }\r\n            output.push(\"mtllib \" + matlibname + \".mtl\");\r\n        }\r\n        for (let j = 0; j < meshes.length; j++) {\r\n            const mesh = meshes[j];\r\n            const objectName = mesh.name || `mesh${j}}`;\r\n            output.push(`o ${objectName}`);\r\n\r\n            //Uses the position of the item in the scene, to the file (this back to normal in the end)\r\n            let inverseTransform: Nullable<Matrix> = null;\r\n            if (globalposition) {\r\n                const transform = mesh.computeWorldMatrix(true);\r\n                inverseTransform = new Matrix();\r\n                transform.invertToRef(inverseTransform);\r\n\r\n                mesh.bakeTransformIntoVertices(transform);\r\n            }\r\n\r\n            //TODO: submeshes (groups)\r\n            //TODO: smoothing groups (s 1, s off);\r\n            if (materials) {\r\n                const mat = mesh.material;\r\n\r\n                if (mat) {\r\n                    output.push(\"usemtl \" + mat.id);\r\n                }\r\n            }\r\n            const g: Nullable<Geometry> = mesh.geometry;\r\n\r\n            if (!g) {\r\n                Tools.Warn(\"No geometry is present on the mesh\");\r\n                continue;\r\n            }\r\n\r\n            const trunkVerts = g.getVerticesData(\"position\");\r\n            const trunkNormals = g.getVerticesData(\"normal\");\r\n            const trunkUV = g.getVerticesData(\"uv\");\r\n            const trunkFaces = g.getIndices();\r\n            let currentV = 0;\r\n            let currentTextureV = 0;\r\n\r\n            if (!trunkVerts || !trunkFaces) {\r\n                Tools.Warn(\"There are no position vertices or indices on the mesh!\");\r\n                continue;\r\n            }\r\n\r\n            const useRightHandedSystem = meshes[0].getScene().useRightHandedSystem;\r\n            const handednessSign = useRightHandedSystem ? 1 : -1;\r\n\r\n            for (let i = 0; i < trunkVerts.length; i += 3) {\r\n                output.push(\"v \" + trunkVerts[i] * handednessSign + \" \" + trunkVerts[i + 1] + \" \" + trunkVerts[i + 2]);\r\n                currentV++;\r\n            }\r\n\r\n            if (trunkNormals != null) {\r\n                for (let i = 0; i < trunkNormals.length; i += 3) {\r\n                    output.push(\"vn \" + trunkNormals[i] * handednessSign + \" \" + trunkNormals[i + 1] + \" \" + trunkNormals[i + 2]);\r\n                }\r\n            }\r\n            if (trunkUV != null) {\r\n                for (let i = 0; i < trunkUV.length; i += 2) {\r\n                    output.push(\"vt \" + trunkUV[i] + \" \" + trunkUV[i + 1]);\r\n                    currentTextureV++;\r\n                }\r\n            }\r\n\r\n            const blanks: string[] = [\"\", \"\", \"\"];\r\n            const material = mesh.material || mesh.getScene().defaultMaterial;\r\n\r\n            const sideOrientation = material._getEffectiveOrientation(mesh);\r\n            const [offset1, offset2] = sideOrientation === Material.ClockWiseSideOrientation ? [2, 1] : [1, 2];\r\n\r\n            for (let i = 0; i < trunkFaces.length; i += 3) {\r\n                const indices = [String(trunkFaces[i] + v), String(trunkFaces[i + offset1] + v), String(trunkFaces[i + offset2] + v)];\r\n                const textureIndices = [String(trunkFaces[i] + textureV), String(trunkFaces[i + offset1] + textureV), String(trunkFaces[i + offset2] + textureV)];\r\n\r\n                const facePositions = indices;\r\n                const faceUVs = trunkUV != null ? textureIndices : blanks;\r\n                const faceNormals = trunkNormals != null ? indices : blanks;\r\n\r\n                output.push(\r\n                    \"f \" +\r\n                        facePositions[0] +\r\n                        \"/\" +\r\n                        faceUVs[0] +\r\n                        \"/\" +\r\n                        faceNormals[0] +\r\n                        \" \" +\r\n                        facePositions[1] +\r\n                        \"/\" +\r\n                        faceUVs[1] +\r\n                        \"/\" +\r\n                        faceNormals[1] +\r\n                        \" \" +\r\n                        facePositions[2] +\r\n                        \"/\" +\r\n                        faceUVs[2] +\r\n                        \"/\" +\r\n                        faceNormals[2]\r\n                );\r\n            }\r\n            //back de previous matrix, to not change the original mesh in the scene\r\n            if (globalposition && inverseTransform) {\r\n                mesh.bakeTransformIntoVertices(inverseTransform);\r\n            }\r\n            v += currentV;\r\n            textureV += currentTextureV;\r\n        }\r\n        const text: string = output.join(\"\\n\");\r\n        return text;\r\n    }\r\n\r\n    /**\r\n     * Exports the material(s) of a mesh in .MTL file format (text)\r\n     * @param mesh defines the mesh to extract the material from\r\n     * @returns the mtl content\r\n     */\r\n    //TODO: Export the materials of mesh array\r\n    public static MTL(mesh: Mesh): string {\r\n        const output = [];\r\n        const m = <StandardMaterial>mesh.material;\r\n        output.push(\"newmtl mat1\");\r\n        output.push(\"  Ns \" + m.specularPower.toFixed(4));\r\n        output.push(\"  Ni 1.5000\");\r\n        output.push(\"  d \" + m.alpha.toFixed(4));\r\n        output.push(\"  Tr 0.0000\");\r\n        output.push(\"  Tf 1.0000 1.0000 1.0000\");\r\n        output.push(\"  illum 2\");\r\n        output.push(\"  Ka \" + m.ambientColor.r.toFixed(4) + \" \" + m.ambientColor.g.toFixed(4) + \" \" + m.ambientColor.b.toFixed(4));\r\n        output.push(\"  Kd \" + m.diffuseColor.r.toFixed(4) + \" \" + m.diffuseColor.g.toFixed(4) + \" \" + m.diffuseColor.b.toFixed(4));\r\n        output.push(\"  Ks \" + m.specularColor.r.toFixed(4) + \" \" + m.specularColor.g.toFixed(4) + \" \" + m.specularColor.b.toFixed(4));\r\n        output.push(\"  Ke \" + m.emissiveColor.r.toFixed(4) + \" \" + m.emissiveColor.g.toFixed(4) + \" \" + m.emissiveColor.b.toFixed(4));\r\n\r\n        //TODO: uv scale, offset, wrap\r\n        //TODO: UV mirrored in Blender? second UV channel? lightMap? reflection textures?\r\n        const uvscale = \"\";\r\n\r\n        if (m.ambientTexture) {\r\n            output.push(\"  map_Ka \" + uvscale + m.ambientTexture.name);\r\n        }\r\n\r\n        if (m.diffuseTexture) {\r\n            output.push(\"  map_Kd \" + uvscale + m.diffuseTexture.name);\r\n            //TODO: alpha testing, opacity in diffuse texture alpha channel (diffuseTexture.hasAlpha -> map_d)\r\n        }\r\n\r\n        if (m.specularTexture) {\r\n            output.push(\"  map_Ks \" + uvscale + m.specularTexture.name);\r\n            /* TODO: glossiness = specular highlight component is in alpha channel of specularTexture. (???)\r\n            if (m.useGlossinessFromSpecularMapAlpha)  {\r\n                output.push(\"  map_Ns \"+uvscale + m.specularTexture.name);\r\n            }\r\n            */\r\n        }\r\n\r\n        /* TODO: emissive texture not in .MAT format (???)\r\n        if (m.emissiveTexture) {\r\n            output.push(\"  map_d \"+uvscale+m.emissiveTexture.name);\r\n        }\r\n        */\r\n\r\n        if (m.bumpTexture) {\r\n            output.push(\"  map_bump -imfchan z \" + uvscale + m.bumpTexture.name);\r\n        }\r\n\r\n        if (m.opacityTexture) {\r\n            output.push(\"  map_d \" + uvscale + m.opacityTexture.name);\r\n        }\r\n\r\n        const text = output.join(\"\\n\");\r\n        return text;\r\n    }\r\n}\r\n","/** @internal */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var __IGLTFExporterExtension = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for extending the exporter\r\n * @internal\r\n */\r\nexport interface IGLTFExporterExtension {\r\n    /**\r\n     * The name of this extension\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Defines whether this extension is enabled\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether this extension is required\r\n     */\r\n    required: boolean;\r\n}\r\n","import { GetMimeType } from \"core/Misc/fileTools\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Class for holding and downloading glTF file data\r\n */\r\nexport class GLTFData {\r\n    /**\r\n     * Object which contains the file name as the key and its data as the value\r\n     */\r\n    public readonly files: { [fileName: string]: string | Blob } = {};\r\n\r\n    /**\r\n     * @deprecated Use files instead\r\n     */\r\n    public get glTFFiles() {\r\n        return this.files;\r\n    }\r\n\r\n    /**\r\n     * Downloads the glTF data as files based on their names and data\r\n     */\r\n    public downloadFiles(): void {\r\n        for (const key in this.files) {\r\n            const value = this.files[key];\r\n            const blob = new Blob([value], { type: GetMimeType(key) });\r\n            Tools.Download(blob, key);\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */\r\n/* eslint-disable github/no-then */\r\n/* eslint-disable babylonjs/available */\r\n\r\nimport type { ITextureInfo, IMaterial, IMaterialPbrMetallicRoughness, IMaterialOcclusionTextureInfo, ISampler, IImage } from \"babylonjs-gltf2interface\";\r\nimport { ImageMimeType, MaterialAlphaMode, TextureMagFilter, TextureMinFilter, TextureWrapMode } from \"babylonjs-gltf2interface\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { GetTextureDataAsync, TextureTools } from \"core/Misc/textureTools\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport type { GLTFExporter } from \"./glTFExporter\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { DumpTools } from \"core/Misc/dumpTools\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport { SpecularPowerToRoughness } from \"core/Helpers/materialConversionHelper\";\r\nimport { InternalTextureSource } from \"core/Materials/Textures/internalTexture\";\r\nimport { GetMimeType } from \"core/Misc/fileTools\";\r\n\r\nconst Epsilon = 1e-6;\r\nconst DielectricSpecular = new Color3(0.04, 0.04, 0.04);\r\nconst MaxSpecularPower = 1024;\r\nconst White = Color3.White();\r\nconst Black = Color3.Black();\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @internal\r\n */\r\ninterface IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n     */\r\n    diffuseColor: Color3;\r\n    specularColor: Color3;\r\n    glossiness: number;\r\n}\r\n\r\ninterface IPBRMetallicRoughness {\r\n    baseColor: Color3;\r\n    metallic: Nullable<number>;\r\n    roughness: Nullable<number>;\r\n    metallicRoughnessTextureData?: Nullable<ArrayBuffer>;\r\n    baseColorTextureData?: Nullable<ArrayBuffer>;\r\n}\r\n\r\nfunction GetFileExtensionFromMimeType(mimeType: ImageMimeType): string {\r\n    switch (mimeType) {\r\n        case ImageMimeType.JPEG:\r\n            return \".jpg\";\r\n        case ImageMimeType.PNG:\r\n            return \".png\";\r\n        case ImageMimeType.WEBP:\r\n            return \".webp\";\r\n        case ImageMimeType.AVIF:\r\n            return \".avif\";\r\n        case ImageMimeType.KTX2:\r\n            return \".ktx2\";\r\n    }\r\n}\r\n\r\n/**\r\n * Gets cached image from a texture, if available.\r\n * @param babylonTexture texture to check for cached image\r\n * @returns image data if found and directly usable; null otherwise\r\n */\r\nasync function GetCachedImageAsync(babylonTexture: BaseTexture): Promise<Nullable<{ data: ArrayBuffer; mimeType: string }>> {\r\n    const internalTexture = babylonTexture.getInternalTexture();\r\n    if (!internalTexture || internalTexture.source !== InternalTextureSource.Url) {\r\n        return null;\r\n    }\r\n    if (internalTexture.invertY) {\r\n        return null;\r\n    }\r\n\r\n    const buffer = internalTexture._buffer;\r\n\r\n    let data;\r\n    let mimeType = (babylonTexture as Texture).mimeType;\r\n\r\n    if (!buffer) {\r\n        data = await Tools.LoadFileAsync(internalTexture.url);\r\n        mimeType = GetMimeType(internalTexture.url) || mimeType;\r\n    } else if (ArrayBuffer.isView(buffer)) {\r\n        data = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength) as ArrayBuffer;\r\n    } else if (buffer instanceof ArrayBuffer) {\r\n        data = buffer;\r\n    } else if (buffer instanceof Blob) {\r\n        data = await buffer.arrayBuffer();\r\n        mimeType = buffer.type || mimeType;\r\n    } else if (typeof buffer === \"string\") {\r\n        data = await Tools.LoadFileAsync(buffer);\r\n        mimeType = GetMimeType(buffer) || mimeType;\r\n    } else if (typeof HTMLImageElement !== \"undefined\" && buffer instanceof HTMLImageElement) {\r\n        data = await Tools.LoadFileAsync(buffer.src);\r\n        mimeType = GetMimeType(buffer.src) || mimeType;\r\n    }\r\n\r\n    if (data && mimeType) {\r\n        return { data, mimeType };\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Computes the metallic factor from specular glossiness values.\r\n * @param diffuse diffused value\r\n * @param specular specular value\r\n * @param oneMinusSpecularStrength one minus the specular strength\r\n * @returns metallic value\r\n * @internal\r\n */\r\nexport function _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n    if (specular < DielectricSpecular.r) {\r\n        DielectricSpecular;\r\n        return 0;\r\n    }\r\n\r\n    const a = DielectricSpecular.r;\r\n    const b = (diffuse * oneMinusSpecularStrength) / (1.0 - DielectricSpecular.r) + specular - 2.0 * DielectricSpecular.r;\r\n    const c = DielectricSpecular.r - specular;\r\n    const d = b * b - 4.0 * a * c;\r\n    return Scalar.Clamp((-b + Math.sqrt(d)) / (2.0 * a), 0, 1);\r\n}\r\n\r\n/**\r\n * Computes the metallic/roughness factors from a Standard Material.\r\n * @internal\r\n */\r\nexport function _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n    const diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace(babylonStandardMaterial.getScene().getEngine().useExactSrgbConversions).scale(0.5);\r\n    const opacity = babylonStandardMaterial.alpha;\r\n    const specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, MaxSpecularPower);\r\n\r\n    const roughness = SpecularPowerToRoughness(specularPower);\r\n\r\n    const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n        baseColorFactor: [diffuse.r, diffuse.g, diffuse.b, opacity],\r\n        metallicFactor: 0,\r\n        roughnessFactor: roughness,\r\n    };\r\n\r\n    return glTFPbrMetallicRoughness;\r\n}\r\n\r\n/**\r\n * Sets the glTF alpha mode to a glTF material from the Babylon Material\r\n * @param glTFMaterial glTF material\r\n * @param babylonMaterial Babylon material\r\n */\r\nfunction SetAlphaMode(glTFMaterial: IMaterial, babylonMaterial: Material & { alphaCutOff?: number }): void {\r\n    if (babylonMaterial.needAlphaBlending()) {\r\n        glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n    } else if (babylonMaterial.needAlphaTesting()) {\r\n        glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n        glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\r\n    }\r\n}\r\n\r\nfunction CreateWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n    const data = new Uint8Array(width * height * 4);\r\n\r\n    for (let i = 0; i < data.length; i = i + 4) {\r\n        data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xff;\r\n    }\r\n\r\n    const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n    return rawTexture;\r\n}\r\n\r\nfunction ConvertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n    if (pixels instanceof Uint8Array) {\r\n        const length = pixels.length;\r\n        const buffer = new Float32Array(pixels.length);\r\n        for (let i = 0; i < length; ++i) {\r\n            buffer[i] = pixels[i] / 255;\r\n        }\r\n        return buffer;\r\n    } else if (pixels instanceof Float32Array) {\r\n        return pixels;\r\n    } else {\r\n        throw new Error(\"Unsupported pixel format!\");\r\n    }\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.\r\n * @internal\r\n */\r\nexport class GLTFMaterialExporter {\r\n    // Mapping to store textures\r\n    private _textureMap = new Map<BaseTexture, ITextureInfo>();\r\n\r\n    // Mapping of internal textures to images to avoid exporting duplicate images\r\n    private _internalTextureToImage: { [uniqueId: number]: { [mimeType: string]: Promise<number> } } = {};\r\n\r\n    constructor(private readonly _exporter: GLTFExporter) {}\r\n\r\n    public getTextureInfo(babylonTexture: Nullable<BaseTexture>): Nullable<ITextureInfo> {\r\n        return babylonTexture ? (this._textureMap.get(babylonTexture) ?? null) : null;\r\n    }\r\n\r\n    public async exportStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, hasUVs: boolean): Promise<number> {\r\n        const pbrMetallicRoughness = _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const material: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            material.doubleSided = true;\r\n        }\r\n\r\n        if (hasUVs) {\r\n            const promises: Promise<void>[] = [];\r\n\r\n            const diffuseTexture = babylonStandardMaterial.diffuseTexture;\r\n            if (diffuseTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(diffuseTexture).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            pbrMetallicRoughness.baseColorTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const bumpTexture = babylonStandardMaterial.bumpTexture;\r\n            if (bumpTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(bumpTexture).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.normalTexture = textureInfo;\r\n                            if (bumpTexture.level !== 1) {\r\n                                material.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const emissiveTexture = babylonStandardMaterial.emissiveTexture;\r\n            if (emissiveTexture) {\r\n                material.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(\r\n                    this.exportTextureAsync(emissiveTexture).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.emissiveTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const ambientTexture = babylonStandardMaterial.ambientTexture;\r\n            if (ambientTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(ambientTexture).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: textureInfo.index,\r\n                            };\r\n                            material.occlusionTexture = occlusionTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (promises.length > 0) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonStandardMaterial);\r\n                await Promise.all(promises);\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {\r\n                material.alphaMode = MaterialAlphaMode.BLEND;\r\n            } else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.emissiveColor && !babylonStandardMaterial.emissiveColor.equalsWithEpsilon(Black, Epsilon)) {\r\n            material.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        material.pbrMetallicRoughness = pbrMetallicRoughness;\r\n        SetAlphaMode(material, babylonStandardMaterial);\r\n\r\n        await this._finishMaterialAsync(material, babylonStandardMaterial);\r\n\r\n        const materials = this._exporter._materials;\r\n        materials.push(material);\r\n        return materials.length - 1;\r\n    }\r\n\r\n    private async _finishMaterialAsync(glTFMaterial: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const textures = this._exporter._extensionsPostExportMaterialAdditionalTextures(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n\r\n        const promises: Array<Promise<Nullable<ITextureInfo>>> = [];\r\n\r\n        for (const texture of textures) {\r\n            promises.push(this.exportTextureAsync(texture));\r\n        }\r\n\r\n        await Promise.all(promises);\r\n\r\n        await this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n    }\r\n\r\n    private async _getImageDataAsync(buffer: Uint8Array, width: number, height: number, mimeType: ImageMimeType): Promise<ArrayBuffer> {\r\n        return await DumpTools.DumpDataAsync(width, height, buffer, mimeType, undefined, false, true);\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: Nullable<BaseTexture>, texture2: Nullable<BaseTexture>, scene: Scene): { texture1: BaseTexture; texture2: BaseTexture } {\r\n        const texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        const texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1: BaseTexture;\r\n        let resizedTexture2: BaseTexture;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            } else {\r\n                resizedTexture1 = CreateWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2!;\r\n        } else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            } else {\r\n                resizedTexture2 = CreateWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1!;\r\n        } else {\r\n            resizedTexture1 = texture1!;\r\n            resizedTexture2 = texture2!;\r\n        }\r\n\r\n        return {\r\n            texture1: resizedTexture1!,\r\n            texture2: resizedTexture2!,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(\r\n        diffuseTexture: Nullable<BaseTexture>,\r\n        specularGlossinessTexture: Nullable<BaseTexture>,\r\n        factors: IPBRSpecularGlossiness,\r\n        mimeType: ImageMimeType\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const promises = new Array<Promise<void>>();\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return await Promise.reject(\"diffuse and specular glossiness textures are not defined!\");\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            const diffuseSize = resizedTextures.texture1?.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            const diffusePixels = await resizedTextures.texture1.readPixels();\r\n            const specularPixels = await resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = ConvertPixelArrayToFloat32(diffusePixels);\r\n            } else {\r\n                return await Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = ConvertPixelArrayToFloat32(specularPixels);\r\n            } else {\r\n                return await Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Black;\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.specularColor);\r\n                    const glossiness = specularGlossinessBuffer[offset + 3] * factors.glossiness;\r\n\r\n                    const specularGlossiness: IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness,\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness,\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(\r\n                        baseColorBuffer[destinationOffset],\r\n                        baseColorBuffer[destinationOffset + 1],\r\n                        baseColorBuffer[destinationOffset + 2]\r\n                    );\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace(scene.getEngine().useExactSrgbConversions);\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!sRGBBaseColorPixel.equalsWithEpsilon(White, Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness! > Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!metallicRoughnessPixel.equalsWithEpsilon(White, Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(metallicRoughnessBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.metallicRoughnessTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(baseColorBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.baseColorTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n\r\n            return await Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        } else {\r\n            return await Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: IPBRSpecularGlossiness): IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - DielectricSpecular.r) / Math.max(1 - metallic));\r\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness,\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private async _convertMetalRoughFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasUVs: boolean\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const promises: Promise<void>[] = [];\r\n\r\n        const metallicRoughness: IPBRMetallicRoughness = {\r\n            baseColor: babylonPBRMaterial._albedoColor,\r\n            metallic: babylonPBRMaterial._metallic,\r\n            roughness: babylonPBRMaterial._roughness,\r\n        };\r\n\r\n        if (hasUVs) {\r\n            const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n            if (albedoTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(albedoTexture).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            const metallicTexture = babylonPBRMaterial._metallicTexture;\r\n            if (metallicTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(metallicTexture).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (promises.length > 0) {\r\n            this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n            await Promise.all(promises);\r\n        }\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    private _getTextureSampler(texture: Nullable<BaseTexture>): ISampler {\r\n        const sampler: ISampler = {};\r\n        if (!texture || !(texture instanceof Texture)) {\r\n            return sampler;\r\n        }\r\n\r\n        const wrapS = this._getGLTFTextureWrapMode(texture.wrapU);\r\n        if (wrapS !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapS = wrapS;\r\n        }\r\n\r\n        const wrapT = this._getGLTFTextureWrapMode(texture.wrapV);\r\n        if (wrapT !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapT = wrapT;\r\n        }\r\n\r\n        switch (texture.samplingMode) {\r\n            case Texture.LINEAR_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param pbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private async _convertSpecGlossFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        pbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasUVs: boolean\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const mimeType = ImageMimeType.PNG;\r\n        const specGloss: IPBRSpecularGlossiness = {\r\n            diffuseColor: babylonPBRMaterial._albedoColor,\r\n            specularColor: babylonPBRMaterial._reflectivityColor,\r\n            glossiness: babylonPBRMaterial._microSurface,\r\n        };\r\n\r\n        const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n        const reflectivityTexture = babylonPBRMaterial._reflectivityTexture;\r\n        const useMicrosurfaceFromReflectivityMapAlpha = babylonPBRMaterial._useMicroSurfaceFromReflectivityMapAlpha;\r\n        if (reflectivityTexture && !useMicrosurfaceFromReflectivityMapAlpha) {\r\n            return await Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n        }\r\n\r\n        if ((albedoTexture || reflectivityTexture) && hasUVs) {\r\n            this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n\r\n            const samplerIndex = this._exportTextureSampler(albedoTexture || reflectivityTexture);\r\n            const metallicRoughnessFactors = await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(albedoTexture, reflectivityTexture, specGloss, mimeType);\r\n\r\n            const textures = this._exporter._textures;\r\n\r\n            if (metallicRoughnessFactors.baseColorTextureData) {\r\n                const imageIndex = this._exportImage(`baseColor${textures.length}`, mimeType, metallicRoughnessFactors.baseColorTextureData);\r\n                pbrMetallicRoughness.baseColorTexture = this._exportTextureInfo(imageIndex, samplerIndex, albedoTexture?.coordinatesIndex);\r\n            }\r\n\r\n            if (metallicRoughnessFactors.metallicRoughnessTextureData) {\r\n                const imageIndex = this._exportImage(`metallicRoughness${textures.length}`, mimeType, metallicRoughnessFactors.metallicRoughnessTextureData);\r\n                pbrMetallicRoughness.metallicRoughnessTexture = this._exportTextureInfo(imageIndex, samplerIndex, reflectivityTexture?.coordinatesIndex);\r\n            }\r\n\r\n            return metallicRoughnessFactors;\r\n        } else {\r\n            return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n        }\r\n    }\r\n\r\n    public async exportPBRMaterialAsync(babylonPBRMaterial: PBRBaseMaterial, hasUVs: boolean): Promise<number> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name,\r\n        };\r\n\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            const albedoColor = babylonPBRMaterial._albedoColor;\r\n            const alpha = babylonPBRMaterial.alpha;\r\n            if (albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];\r\n            }\r\n        }\r\n\r\n        const metallicRoughness = useMetallicRoughness\r\n            ? await this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs)\r\n            : await this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs);\r\n\r\n        await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs);\r\n        await this._finishMaterialAsync(glTFMaterial, babylonPBRMaterial);\r\n\r\n        const materials = this._exporter._materials;\r\n        materials.push(glTFMaterial);\r\n        return materials.length - 1;\r\n    }\r\n\r\n    private async _setMetallicRoughnessPbrMaterialAsync(\r\n        metallicRoughness: IPBRMetallicRoughness,\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        glTFMaterial: IMaterial,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasUVs: boolean\r\n    ): Promise<void> {\r\n        SetAlphaMode(glTFMaterial, babylonPBRMaterial);\r\n\r\n        if (!metallicRoughness.baseColor.equalsWithEpsilon(White, Epsilon) || !Scalar.WithinEpsilon(babylonPBRMaterial.alpha, 1, Epsilon)) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [metallicRoughness.baseColor.r, metallicRoughness.baseColor.g, metallicRoughness.baseColor.b, babylonPBRMaterial.alpha];\r\n        }\r\n\r\n        if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n            glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n        }\r\n        if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n            glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n        }\r\n\r\n        if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n            if (!babylonPBRMaterial._twoSidedLighting) {\r\n                Tools.Warn(babylonPBRMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n\r\n        if (hasUVs) {\r\n            const promises: Promise<void>[] = [];\r\n\r\n            const bumpTexture = babylonPBRMaterial._bumpTexture;\r\n            if (bumpTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(bumpTexture).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const ambientTexture = babylonPBRMaterial._ambientTexture;\r\n            if (ambientTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(ambientTexture).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                                texCoord: glTFTexture.texCoord,\r\n                                extensions: glTFTexture.extensions,\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n                            const ambientTextureStrength = babylonPBRMaterial._ambientTextureStrength;\r\n                            if (ambientTextureStrength) {\r\n                                occlusionTexture.strength = ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const emissiveTexture = babylonPBRMaterial._emissiveTexture;\r\n            if (emissiveTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(emissiveTexture).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (promises.length > 0) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n                await Promise.all(promises);\r\n            }\r\n        }\r\n\r\n        const emissiveColor = babylonPBRMaterial._emissiveColor;\r\n        if (!emissiveColor.equalsWithEpsilon(Black, Epsilon)) {\r\n            glTFMaterial.emissiveFactor = emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    public async exportTextureAsync(babylonTexture: BaseTexture): Promise<Nullable<ITextureInfo>> {\r\n        let textureInfo = this._textureMap.get(babylonTexture);\r\n        if (textureInfo) {\r\n            return textureInfo;\r\n        }\r\n\r\n        const samplerIndex = this._exportTextureSampler(babylonTexture);\r\n        const imageIndex = await this._exportTextureImageAsync(babylonTexture);\r\n\r\n        textureInfo = this._exportTextureInfo(imageIndex, samplerIndex, babylonTexture.coordinatesIndex);\r\n        this._textureMap.set(babylonTexture, textureInfo);\r\n\r\n        this._exporter._extensionsPostExportTextures(\"exporter\", textureInfo, babylonTexture);\r\n        return textureInfo;\r\n    }\r\n\r\n    private async _exportTextureImageAsync(babylonTexture: BaseTexture): Promise<number> {\r\n        const requestedMimeType = (babylonTexture as Texture).mimeType ?? \"none\";\r\n        // TODO: Add an official way for users to export using a different mime type\r\n        // than the one they loaded with (which is denoted by Texture.mimeType)\r\n\r\n        const internalTextureToImage = this._internalTextureToImage;\r\n        const internalTextureUniqueId = babylonTexture.getInternalTexture()!.uniqueId;\r\n        internalTextureToImage[internalTextureUniqueId] = internalTextureToImage[internalTextureUniqueId] || {};\r\n        let imageIndexPromise = internalTextureToImage[internalTextureUniqueId][requestedMimeType];\r\n\r\n        if (imageIndexPromise === undefined) {\r\n            imageIndexPromise = (async () => {\r\n                // Try to get the image from memory first, if applicable\r\n                const cache = await GetCachedImageAsync(babylonTexture);\r\n                if (cache && (requestedMimeType === \"none\" || cache.mimeType === requestedMimeType)) {\r\n                    return this._exportImage(babylonTexture.name, cache.mimeType as ImageMimeType, cache.data);\r\n                }\r\n\r\n                // Preserve texture mime type if defined\r\n                let mimeType = ImageMimeType.PNG;\r\n                if (requestedMimeType !== \"none\") {\r\n                    switch (requestedMimeType) {\r\n                        case ImageMimeType.JPEG:\r\n                        case ImageMimeType.PNG:\r\n                        case ImageMimeType.WEBP:\r\n                            mimeType = requestedMimeType;\r\n                            break;\r\n                        default:\r\n                            Tools.Warn(`Unsupported media type: ${requestedMimeType}. Exporting texture as PNG.`);\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                const size = babylonTexture.getSize();\r\n                const pixels = await GetTextureDataAsync(babylonTexture);\r\n                const data = await this._getImageDataAsync(pixels, size.width, size.height, mimeType);\r\n\r\n                return this._exportImage(babylonTexture.name, mimeType, data);\r\n            })();\r\n\r\n            internalTextureToImage[internalTextureUniqueId][requestedMimeType] = imageIndexPromise;\r\n        }\r\n\r\n        return await imageIndexPromise;\r\n    }\r\n\r\n    private _exportImage(name: string, mimeType: ImageMimeType, data: ArrayBuffer): number {\r\n        const images = this._exporter._images;\r\n\r\n        let image: IImage;\r\n        if (this._exporter._shouldUseGlb) {\r\n            image = {\r\n                name: name,\r\n                mimeType: mimeType,\r\n                bufferView: undefined, // Will be updated later by BufferManager\r\n            };\r\n            const bufferView = this._exporter._bufferManager.createBufferView(new Uint8Array(data));\r\n            this._exporter._bufferManager.setBufferView(image, bufferView);\r\n        } else {\r\n            // Build a unique URI\r\n            const baseName = name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\");\r\n            const extension = GetFileExtensionFromMimeType(mimeType);\r\n            let fileName = baseName + extension;\r\n            if (images.some((image) => image.uri === fileName)) {\r\n                fileName = `${baseName}_${Tools.RandomId()}${extension}`;\r\n            }\r\n\r\n            image = {\r\n                name: name,\r\n                uri: fileName,\r\n            };\r\n            this._exporter._imageData[fileName] = { data: data, mimeType: mimeType }; // Save image data to be written to file later\r\n        }\r\n\r\n        images.push(image);\r\n\r\n        return images.length - 1;\r\n    }\r\n\r\n    private _exportTextureInfo(imageIndex: number, samplerIndex: number, coordinatesIndex?: number): ITextureInfo {\r\n        const textures = this._exporter._textures;\r\n        let textureIndex = textures.findIndex((t) => t.sampler == samplerIndex && t.source === imageIndex);\r\n        if (textureIndex === -1) {\r\n            textureIndex = textures.length;\r\n            textures.push({\r\n                source: imageIndex,\r\n                sampler: samplerIndex,\r\n            });\r\n        }\r\n\r\n        const textureInfo: ITextureInfo = { index: textureIndex };\r\n        if (coordinatesIndex) {\r\n            textureInfo.texCoord = coordinatesIndex;\r\n        }\r\n        return textureInfo;\r\n    }\r\n\r\n    private _exportTextureSampler(texture: Nullable<BaseTexture>): number {\r\n        const sampler = this._getTextureSampler(texture);\r\n\r\n        // if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n        const samplers = this._exporter._samplers;\r\n        const samplerIndex = samplers.findIndex(\r\n            (s) => s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter && s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT\r\n        );\r\n        if (samplerIndex !== -1) {\r\n            return samplerIndex;\r\n        }\r\n\r\n        samplers.push(sampler);\r\n        return samplers.length - 1;\r\n    }\r\n}\r\n","import { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Node } from \"core/node\";\r\n\r\n/**\r\n * Matrix that converts handedness on the X-axis. Used to convert from LH to RH and vice versa.\r\n * @internal\r\n */\r\nexport const ConvertHandednessMatrix = Matrix.Compose(new Vector3(-1, 1, 1), Quaternion.Identity(), Vector3.Zero());\r\n\r\n/**\r\n * Checks if a node is a \"noop\" transform node, usually inserted by the glTF loader to correct handedness.\r\n * @internal\r\n */\r\nexport function IsNoopNode(node: Node, useRightHandedSystem: boolean): boolean {\r\n    if (!(node instanceof TransformNode)) {\r\n        return false;\r\n    }\r\n\r\n    // Transform\r\n    if (useRightHandedSystem) {\r\n        const matrix = node.getWorldMatrix();\r\n        if (!matrix.equalsWithEpsilon(Matrix.IdentityReadOnly, Epsilon)) {\r\n            return false;\r\n        }\r\n    } else {\r\n        const matrix = node.getWorldMatrix().multiplyToRef(ConvertHandednessMatrix, TmpVectors.Matrix[0]);\r\n        if (!matrix.equalsWithEpsilon(Matrix.IdentityReadOnly, Epsilon)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Geometry\r\n    if (node instanceof AbstractMesh && node.geometry) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n","/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { INode } from \"babylonjs-gltf2interface\";\r\nimport { AccessorType, MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\r\nimport type { FloatArray, DataArray, IndicesArray } from \"core/types\";\r\nimport type { Vector4 } from \"core/Maths/math.vector\";\r\nimport { Quaternion, TmpVectors, Matrix, Vector3 } from \"core/Maths/math.vector\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { EnumerateFloatValues } from \"core/Buffers/bufferUtils\";\r\nimport type { Node } from \"core/node\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { TargetCamera } from \"core/Cameras/targetCamera\";\r\nimport type { ShadowLight } from \"core/Lights/shadowLight\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\nimport { ConvertHandednessMatrix } from \"../../exportUtils\";\r\n\r\n// Default values for comparison.\r\nexport const DefaultTranslation = Vector3.Zero();\r\nexport const DefaultRotation = Quaternion.Identity();\r\nexport const DefaultScale = Vector3.One();\r\nconst DefaultLoaderCameraParentScaleLh = new Vector3(-1, 1, 1);\r\n\r\n/**\r\n * Get the information necessary for enumerating a vertex buffer.\r\n * @param vertexBuffer the vertex buffer to enumerate\r\n * @param meshes the meshes that use the vertex buffer\r\n * @returns the information necessary to enumerate the vertex buffer\r\n */\r\nexport function GetVertexBufferInfo(vertexBuffer: VertexBuffer, meshes: AbstractMesh[]) {\r\n    const { byteOffset, byteStride, type, normalized } = vertexBuffer;\r\n    const componentCount = vertexBuffer.getSize();\r\n    const totalVertices = meshes.reduce((max, current) => {\r\n        return current.getTotalVertices() > max ? current.getTotalVertices() : max;\r\n    }, -Number.MAX_VALUE); // Get the max total vertices count, to ensure we capture the full range of vertex data used by the meshes.\r\n    const count = totalVertices * componentCount;\r\n    const kind = vertexBuffer.getKind();\r\n\r\n    return { byteOffset, byteStride, componentCount, type, count, normalized, totalVertices, kind };\r\n}\r\n\r\nexport function GetAccessorElementCount(accessorType: AccessorType): number {\r\n    switch (accessorType) {\r\n        case AccessorType.MAT2:\r\n            return 4;\r\n        case AccessorType.MAT3:\r\n            return 9;\r\n        case AccessorType.MAT4:\r\n            return 16;\r\n        case AccessorType.SCALAR:\r\n            return 1;\r\n        case AccessorType.VEC2:\r\n            return 2;\r\n        case AccessorType.VEC3:\r\n            return 3;\r\n        case AccessorType.VEC4:\r\n            return 4;\r\n    }\r\n}\r\n\r\nexport function FloatsNeed16BitInteger(floatArray: FloatArray): boolean {\r\n    return floatArray.some((value) => value >= 256);\r\n}\r\n\r\nexport function IsStandardVertexAttribute(type: string): boolean {\r\n    switch (type) {\r\n        case VertexBuffer.PositionKind:\r\n        case VertexBuffer.NormalKind:\r\n        case VertexBuffer.TangentKind:\r\n        case VertexBuffer.ColorKind:\r\n        case VertexBuffer.MatricesIndicesKind:\r\n        case VertexBuffer.MatricesIndicesExtraKind:\r\n        case VertexBuffer.MatricesWeightsKind:\r\n        case VertexBuffer.MatricesWeightsExtraKind:\r\n        case VertexBuffer.UVKind:\r\n        case VertexBuffer.UV2Kind:\r\n        case VertexBuffer.UV3Kind:\r\n        case VertexBuffer.UV4Kind:\r\n        case VertexBuffer.UV5Kind:\r\n        case VertexBuffer.UV6Kind:\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function GetAccessorType(kind: string, hasVertexColorAlpha: boolean): AccessorType {\r\n    if (kind == VertexBuffer.ColorKind) {\r\n        return hasVertexColorAlpha ? AccessorType.VEC4 : AccessorType.VEC3;\r\n    }\r\n\r\n    switch (kind) {\r\n        case VertexBuffer.PositionKind:\r\n        case VertexBuffer.NormalKind:\r\n            return AccessorType.VEC3;\r\n        case VertexBuffer.TangentKind:\r\n        case VertexBuffer.MatricesIndicesKind:\r\n        case VertexBuffer.MatricesIndicesExtraKind:\r\n        case VertexBuffer.MatricesWeightsKind:\r\n        case VertexBuffer.MatricesWeightsExtraKind:\r\n            return AccessorType.VEC4;\r\n        case VertexBuffer.UVKind:\r\n        case VertexBuffer.UV2Kind:\r\n        case VertexBuffer.UV3Kind:\r\n        case VertexBuffer.UV4Kind:\r\n        case VertexBuffer.UV5Kind:\r\n        case VertexBuffer.UV6Kind:\r\n            return AccessorType.VEC2;\r\n    }\r\n\r\n    throw new Error(`Unknown kind ${kind}`);\r\n}\r\n\r\nexport function GetAttributeType(kind: string): string {\r\n    switch (kind) {\r\n        case VertexBuffer.PositionKind:\r\n            return \"POSITION\";\r\n        case VertexBuffer.NormalKind:\r\n            return \"NORMAL\";\r\n        case VertexBuffer.TangentKind:\r\n            return \"TANGENT\";\r\n        case VertexBuffer.ColorKind:\r\n            return \"COLOR_0\";\r\n        case VertexBuffer.UVKind:\r\n            return \"TEXCOORD_0\";\r\n        case VertexBuffer.UV2Kind:\r\n            return \"TEXCOORD_1\";\r\n        case VertexBuffer.UV3Kind:\r\n            return \"TEXCOORD_2\";\r\n        case VertexBuffer.UV4Kind:\r\n            return \"TEXCOORD_3\";\r\n        case VertexBuffer.UV5Kind:\r\n            return \"TEXCOORD_4\";\r\n        case VertexBuffer.UV6Kind:\r\n            return \"TEXCOORD_5\";\r\n        case VertexBuffer.MatricesIndicesKind:\r\n            return \"JOINTS_0\";\r\n        case VertexBuffer.MatricesIndicesExtraKind:\r\n            return \"JOINTS_1\";\r\n        case VertexBuffer.MatricesWeightsKind:\r\n            return \"WEIGHTS_0\";\r\n        case VertexBuffer.MatricesWeightsExtraKind:\r\n            return \"WEIGHTS_1\";\r\n    }\r\n\r\n    throw new Error(`Unknown kind: ${kind}`);\r\n}\r\n\r\nexport function GetPrimitiveMode(fillMode: number): MeshPrimitiveMode {\r\n    switch (fillMode) {\r\n        case Material.TriangleFillMode:\r\n            return MeshPrimitiveMode.TRIANGLES;\r\n        case Material.TriangleStripDrawMode:\r\n            return MeshPrimitiveMode.TRIANGLE_STRIP;\r\n        case Material.TriangleFanDrawMode:\r\n            return MeshPrimitiveMode.TRIANGLE_FAN;\r\n        case Material.PointListDrawMode:\r\n        case Material.PointFillMode:\r\n            return MeshPrimitiveMode.POINTS;\r\n        case Material.LineLoopDrawMode:\r\n            return MeshPrimitiveMode.LINE_LOOP;\r\n        case Material.LineListDrawMode:\r\n            return MeshPrimitiveMode.LINES;\r\n        case Material.LineStripDrawMode:\r\n            return MeshPrimitiveMode.LINE_STRIP;\r\n    }\r\n\r\n    throw new Error(`Unknown fill mode: ${fillMode}`);\r\n}\r\n\r\nexport function IsTriangleFillMode(fillMode: number): boolean {\r\n    switch (fillMode) {\r\n        case Material.TriangleFillMode:\r\n        case Material.TriangleStripDrawMode:\r\n        case Material.TriangleFanDrawMode:\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function NormalizeTangent(tangent: Vector4 | Vector3) {\r\n    const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);\r\n    if (length > 0) {\r\n        tangent.x /= length;\r\n        tangent.y /= length;\r\n        tangent.z /= length;\r\n    }\r\n}\r\n\r\nexport function ConvertToRightHandedPosition(value: Vector3): Vector3 {\r\n    value.x *= -1;\r\n    return value;\r\n}\r\n\r\n/** @internal */\r\nexport function ConvertToRightHandedTransformMatrix(matrix: Matrix): Matrix {\r\n    ConvertHandednessMatrix.invertToRef(TmpVectors.Matrix[0]).multiplyToRef(matrix, matrix).multiplyToRef(ConvertHandednessMatrix, matrix);\r\n    return matrix;\r\n}\r\n\r\n/**\r\n * Converts, in-place, a left-handed quaternion to a right-handed quaternion via a change of basis.\r\n * @param value the unit quaternion to convert\r\n * @returns the converted quaternion\r\n */\r\nexport function ConvertToRightHandedRotation(value: Quaternion): Quaternion {\r\n    /**\r\n     * This is the simplified version of the following equation:\r\n     *    q' = to_quaternion(M * to_matrix(q) * M^-1)\r\n     * where M is the conversion matrix `convertHandednessMatrix`,\r\n     * q is the input quaternion, and q' is the converted quaternion.\r\n     * Reference: https://d3cw3dd2w32x2b.cloudfront.net/wp-content/uploads/2015/01/matrix-to-quat.pdf\r\n     */\r\n    if (value.x * value.x + value.y * value.y > 0.5) {\r\n        const absX = Math.abs(value.x);\r\n        const absY = Math.abs(value.y);\r\n        if (absX > absY) {\r\n            const sign = Math.sign(value.x);\r\n            value.x = absX;\r\n            value.y *= -sign;\r\n            value.z *= -sign;\r\n            value.w *= sign;\r\n        } else {\r\n            const sign = Math.sign(value.y);\r\n            value.x *= -sign;\r\n            value.y = absY;\r\n            value.z *= sign;\r\n            value.w *= -sign;\r\n        }\r\n    } else {\r\n        const absZ = Math.abs(value.z);\r\n        const absW = Math.abs(value.w);\r\n        if (absZ > absW) {\r\n            const sign = Math.sign(value.z);\r\n            value.x *= -sign;\r\n            value.y *= sign;\r\n            value.z = absZ;\r\n            value.w *= -sign;\r\n        } else {\r\n            const sign = Math.sign(value.w);\r\n            value.x *= sign;\r\n            value.y *= -sign;\r\n            value.z *= -sign;\r\n            value.w = absW;\r\n        }\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Pre-multiplies a 180-degree Y rotation to the quaternion, in order to match glTF's flipped forward direction for cameras.\r\n * @param rotation Target camera rotation.\r\n */\r\nexport function Rotate180Y(rotation: Quaternion): void {\r\n    // Simplified from: rotation * (0, 1, 0, 0).\r\n    rotation.copyFromFloats(-rotation.z, rotation.w, rotation.x, -rotation.y);\r\n}\r\n\r\n/**\r\n * Collapses GLTF parent and node into a single node, ignoring scaling.\r\n * This is useful for removing nodes that were added by the GLTF importer.\r\n * @param node Original GLTF node (Light or Camera).\r\n * @param parentNode Target parent node.\r\n */\r\nexport function CollapseChildIntoParent(node: INode, parentNode: INode): void {\r\n    const parentTranslation = Vector3.FromArrayToRef(parentNode.translation || [0, 0, 0], 0, TmpVectors.Vector3[0]);\r\n    const parentRotation = Quaternion.FromArrayToRef(parentNode.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[0]);\r\n    const parentMatrix = Matrix.ComposeToRef(DefaultScale, parentRotation, parentTranslation, TmpVectors.Matrix[0]);\r\n\r\n    const translation = Vector3.FromArrayToRef(node.translation || [0, 0, 0], 0, TmpVectors.Vector3[2]);\r\n    const rotation = Quaternion.FromArrayToRef(node.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[1]);\r\n    const matrix = Matrix.ComposeToRef(DefaultScale, rotation, translation, TmpVectors.Matrix[1]);\r\n\r\n    parentMatrix.multiplyToRef(matrix, matrix);\r\n    matrix.decompose(undefined, parentRotation, parentTranslation);\r\n\r\n    if (parentTranslation.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n        delete parentNode.translation;\r\n    } else {\r\n        parentNode.translation = parentTranslation.asArray();\r\n    }\r\n\r\n    if (parentRotation.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n        delete parentNode.rotation;\r\n    } else {\r\n        parentNode.rotation = parentRotation.asArray();\r\n    }\r\n\r\n    if (parentNode.scale) {\r\n        delete parentNode.scale;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether a camera or light node is candidate for collapsing with its parent node.\r\n * This is useful for roundtrips, as the glTF Importer parents a new node to\r\n * lights and cameras to store their original transformation information.\r\n * @param babylonNode Babylon light or camera node.\r\n * @param parentBabylonNode Target Babylon parent node.\r\n * @returns True if the two nodes can be merged, false otherwise.\r\n */\r\nexport function IsChildCollapsible(babylonNode: ShadowLight | TargetCamera, parentBabylonNode: Node): boolean {\r\n    if (!(parentBabylonNode instanceof TransformNode)) {\r\n        return false;\r\n    }\r\n\r\n    // Verify child is the only descendant\r\n    const isOnlyDescendant = parentBabylonNode.getChildren().length === 1 && babylonNode.getChildren().length === 0 && babylonNode.parent === parentBabylonNode;\r\n    if (!isOnlyDescendant) {\r\n        return false;\r\n    }\r\n\r\n    // Verify parent has the expected scaling, determined by the node type and scene's coordinate system.\r\n    const scene = babylonNode.getScene();\r\n    const expectedScale = babylonNode instanceof TargetCamera && !scene.useRightHandedSystem ? DefaultLoaderCameraParentScaleLh : DefaultScale;\r\n\r\n    if (!parentBabylonNode.scaling.equalsWithEpsilon(expectedScale, Epsilon)) {\r\n        Logger.Warn(`Cannot collapse node ${babylonNode.name} into parent node ${parentBabylonNode.name} with modified scaling.`);\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Converts an IndicesArray into either Uint32Array or Uint16Array, only copying if the data is number[].\r\n * @param indices input array to be converted\r\n * @param start starting index to copy from\r\n * @param count number of indices to copy\r\n * @returns a Uint32Array or Uint16Array\r\n * @internal\r\n */\r\nexport function IndicesArrayToTypedArray(indices: IndicesArray, start: number, count: number, is32Bits: boolean): Uint32Array | Uint16Array {\r\n    if (indices instanceof Uint16Array || indices instanceof Uint32Array) {\r\n        return indices;\r\n    }\r\n\r\n    // If Int32Array, cast the indices (which are all positive) to Uint32Array\r\n    if (indices instanceof Int32Array) {\r\n        return new Uint32Array(indices.buffer, indices.byteOffset, indices.length);\r\n    }\r\n\r\n    const subarray = indices.slice(start, start + count);\r\n    return is32Bits ? new Uint32Array(subarray) : new Uint16Array(subarray);\r\n}\r\n\r\nexport function DataArrayToUint8Array(data: DataArray): Uint8Array {\r\n    if (data instanceof Array) {\r\n        const floatData = new Float32Array(data);\r\n        return new Uint8Array(floatData.buffer, floatData.byteOffset, floatData.byteLength);\r\n    }\r\n\r\n    return ArrayBuffer.isView(data) ? new Uint8Array(data.buffer, data.byteOffset, data.byteLength) : new Uint8Array(data);\r\n}\r\n\r\nexport function GetMinMax(data: DataArray, vertexBuffer: VertexBuffer, start: number, count: number): { min: number[]; max: number[] } {\r\n    const { byteOffset, byteStride, type, normalized } = vertexBuffer;\r\n    const size = vertexBuffer.getSize();\r\n    const min = new Array<number>(size).fill(Infinity);\r\n    const max = new Array<number>(size).fill(-Infinity);\r\n    EnumerateFloatValues(data, byteOffset + start * byteStride, byteStride, size, type, count * size, normalized, (values) => {\r\n        for (let i = 0; i < size; i++) {\r\n            min[i] = Math.min(min[i], values[i]);\r\n            max[i] = Math.max(max[i], values[i]);\r\n        }\r\n    });\r\n\r\n    return { min, max };\r\n}\r\n\r\n/**\r\n * Removes, in-place, object properties which have the same value as the default value.\r\n * Useful for avoiding unnecessary properties in the glTF JSON.\r\n * @param object the object to omit default values from\r\n * @param defaultValues a partial object with default values\r\n * @returns object with default values omitted\r\n */\r\nexport function OmitDefaultValues<T extends object>(object: T, defaultValues: Partial<T>): T {\r\n    for (const [key, value] of Object.entries(object)) {\r\n        const defaultValue = defaultValues[key as keyof T];\r\n        if ((Array.isArray(value) && Array.isArray(defaultValue) && AreArraysEqual(value, defaultValue)) || value === defaultValue) {\r\n            delete object[key as keyof T];\r\n        }\r\n    }\r\n    return object;\r\n}\r\n\r\nfunction AreArraysEqual(array1: unknown[], array2: unknown[]): boolean {\r\n    return array1.length === array2.length && array1.every((val, i) => val === array2[i]);\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\nimport type { TypedArray } from \"core/types\";\r\n\r\nconst TypedArrayToWriteMethod = new Map<Function, (dataView: DataView, byteOffset: number, value: number) => void>([\r\n    [Int8Array, (d, b, v) => d.setInt8(b, v)],\r\n    [Uint8Array, (dv, bo, v) => dv.setUint8(bo, v)],\r\n    [Uint8ClampedArray, (dv, bo, v) => dv.setUint8(bo, v)],\r\n    [Int16Array, (dv, bo, v) => dv.setInt16(bo, v, true)],\r\n    [Uint16Array, (dv, bo, v) => dv.setUint16(bo, v, true)],\r\n    [Int32Array, (dv, bo, v) => dv.setInt32(bo, v, true)],\r\n    [Uint32Array, (dv, bo, v) => dv.setUint32(bo, v, true)],\r\n    [Float32Array, (dv, bo, v) => dv.setFloat32(bo, v, true)],\r\n    [Float64Array, (dv, bo, v) => dv.setFloat64(bo, v, true)],\r\n]);\r\n\r\n/** @internal */\r\nexport class DataWriter {\r\n    private _data: Uint8Array;\r\n    private _dataView: DataView;\r\n    private _byteOffset: number;\r\n\r\n    public writeTypedArray(value: Exclude<TypedArray, BigInt64Array | BigUint64Array>): void {\r\n        this._checkGrowBuffer(value.byteLength);\r\n        const setMethod = TypedArrayToWriteMethod.get(value.constructor)!;\r\n        for (let i = 0; i < value.length; i++) {\r\n            setMethod(this._dataView, this._byteOffset, value[i]);\r\n            this._byteOffset += value.BYTES_PER_ELEMENT;\r\n        }\r\n    }\r\n\r\n    public constructor(byteLength: number) {\r\n        this._data = new Uint8Array(byteLength);\r\n        this._dataView = new DataView(this._data.buffer);\r\n        this._byteOffset = 0;\r\n    }\r\n\r\n    public get byteOffset(): number {\r\n        return this._byteOffset;\r\n    }\r\n\r\n    public getOutputData(): Uint8Array {\r\n        return new Uint8Array(this._data.buffer, 0, this._byteOffset);\r\n    }\r\n\r\n    public writeUInt8(value: number): void {\r\n        this._checkGrowBuffer(1);\r\n        this._dataView.setUint8(this._byteOffset, value);\r\n        this._byteOffset++;\r\n    }\r\n\r\n    public writeInt8(value: number): void {\r\n        this._checkGrowBuffer(1);\r\n        this._dataView.setInt8(this._byteOffset, value);\r\n        this._byteOffset++;\r\n    }\r\n\r\n    public writeInt16(entry: number): void {\r\n        this._checkGrowBuffer(2);\r\n        this._dataView.setInt16(this._byteOffset, entry, true);\r\n        this._byteOffset += 2;\r\n    }\r\n\r\n    public writeUInt16(value: number): void {\r\n        this._checkGrowBuffer(2);\r\n        this._dataView.setUint16(this._byteOffset, value, true);\r\n        this._byteOffset += 2;\r\n    }\r\n\r\n    public writeInt32(entry: number): void {\r\n        this._checkGrowBuffer(4);\r\n        this._dataView.setInt32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n\r\n    public writeUInt32(value: number): void {\r\n        this._checkGrowBuffer(4);\r\n        this._dataView.setUint32(this._byteOffset, value, true);\r\n        this._byteOffset += 4;\r\n    }\r\n\r\n    public writeFloat32(value: number): void {\r\n        this._checkGrowBuffer(4);\r\n        this._dataView.setFloat32(this._byteOffset, value, true);\r\n        this._byteOffset += 4;\r\n    }\r\n\r\n    public writeFloat64(value: number): void {\r\n        this._checkGrowBuffer(8);\r\n        this._dataView.setFloat64(this._byteOffset, value, true);\r\n        this._byteOffset += 8;\r\n    }\r\n\r\n    private _checkGrowBuffer(byteLength: number): void {\r\n        const newByteLength = this.byteOffset + byteLength;\r\n        if (newByteLength > this._data.byteLength) {\r\n            const newData = new Uint8Array(newByteLength * 2);\r\n            newData.set(this._data);\r\n            this._data = newData;\r\n            this._dataView = new DataView(this._data.buffer);\r\n        }\r\n    }\r\n}\r\n","import type { TypedArray } from \"core/types\";\nimport type { AccessorComponentType, AccessorType, IAccessor, IBufferView } from \"babylonjs-gltf2interface\";\nimport { DataWriter } from \"./dataWriter\";\n\ntype TypedArrayForglTF = Exclude<TypedArray, Float64Array | BigInt64Array | BigUint64Array>;\n\ninterface IPropertyWithBufferView {\n    bufferView?: number;\n}\n\nfunction GetHighestByteAlignment(byteLength: number): number {\n    if (byteLength % 4 === 0) {\n        return 4;\n    }\n    if (byteLength % 2 === 0) {\n        return 2;\n    }\n    return 1;\n}\n\n/**\n * Utility class to centralize the management of binary data, bufferViews, and the objects that reference them.\n * @internal\n */\nexport class BufferManager {\n    /**\n     * Maps a bufferView to its data\n     */\n    private _bufferViewToData: Map<IBufferView, TypedArrayForglTF> = new Map<IBufferView, TypedArrayForglTF>();\n\n    /**\n     * Maps a bufferView to glTF objects that reference it via a \"bufferView\" property (e.g. accessors, images)\n     */\n    private _bufferViewToProperties: Map<IBufferView, IPropertyWithBufferView[]> = new Map<IBufferView, IPropertyWithBufferView[]>();\n\n    /**\n     * Maps an accessor to its bufferView\n     */\n    private _accessorToBufferView: Map<IAccessor, IBufferView> = new Map<IAccessor, IBufferView>();\n\n    /**\n     * Generates a binary buffer from the stored bufferViews. Also populates the bufferViews list.\n     * @param bufferViews The list of bufferViews to be populated while writing the binary\n     * @returns The binary buffer\n     */\n    public generateBinary(bufferViews: IBufferView[]): Uint8Array {\n        // Construct a DataWriter with the total byte length to prevent resizing\n        let totalByteLength = 0;\n        this._bufferViewToData.forEach((data) => {\n            totalByteLength += data.byteLength;\n        });\n        const dataWriter = new DataWriter(totalByteLength);\n\n        // Order the bufferViews in descending order of their alignment requirements\n        const orderedBufferViews = Array.from(this._bufferViewToData.keys()).sort((a, b) => GetHighestByteAlignment(b.byteLength) - GetHighestByteAlignment(a.byteLength));\n\n        // Fill in the bufferViews list and missing bufferView index references while writing the binary\n        for (const bufferView of orderedBufferViews) {\n            bufferView.byteOffset = dataWriter.byteOffset;\n            bufferViews.push(bufferView);\n\n            const bufferViewIndex = bufferViews.length - 1;\n            const properties = this.getPropertiesWithBufferView(bufferView);\n            for (const object of properties) {\n                object.bufferView = bufferViewIndex;\n            }\n\n            dataWriter.writeTypedArray(this._bufferViewToData.get(bufferView)!);\n\n            this._bufferViewToData.delete(bufferView); // Try to free up memory ASAP\n        }\n\n        return dataWriter.getOutputData();\n    }\n\n    /**\n     * Creates a buffer view based on the supplied arguments\n     * @param data a TypedArray to create the bufferView for\n     * @param byteStride byte distance between consecutive elements\n     * @returns bufferView for glTF\n     */\n    public createBufferView(data: TypedArrayForglTF, byteStride?: number): IBufferView {\n        const bufferView: IBufferView = {\n            buffer: 0,\n            byteOffset: undefined, // byteOffset will be set later, when we write the binary and decide bufferView ordering\n            byteLength: data.byteLength,\n            byteStride: byteStride,\n        };\n        this._bufferViewToData.set(bufferView, data);\n        return bufferView;\n    }\n\n    /**\n     * Creates an accessor based on the supplied arguments and assigns it to the bufferView\n     * @param bufferView The glTF bufferView referenced by this accessor\n     * @param type The type of the accessor\n     * @param componentType The datatype of components in the attribute\n     * @param count The number of attributes referenced by this accessor\n     * @param byteOffset The offset relative to the start of the bufferView in bytes\n     * @param minMax Minimum and maximum value of each component in this attribute\n     * @param normalized Specifies whether integer data values are normalized before usage\n     * @returns accessor for glTF\n     */\n    public createAccessor(\n        bufferView: IBufferView,\n        type: AccessorType,\n        componentType: AccessorComponentType,\n        count: number,\n        byteOffset?: number,\n        minMax?: { min: number[]; max: number[] },\n        normalized?: boolean\n    ): IAccessor {\n        this._verifyBufferView(bufferView);\n        const accessor: IAccessor = {\n            bufferView: undefined, // bufferView will be set to a real index later, once we write the binary and decide bufferView ordering\n            componentType: componentType,\n            count: count,\n            type: type,\n            min: minMax?.min,\n            max: minMax?.max,\n            normalized: normalized,\n            byteOffset: byteOffset,\n        };\n        this.setBufferView(accessor, bufferView);\n        this._accessorToBufferView.set(accessor, bufferView);\n        return accessor;\n    }\n\n    /**\n     * Assigns a bufferView to a glTF object that references it\n     * @param object The glTF object\n     * @param bufferView The bufferView to assign\n     */\n    public setBufferView(object: IPropertyWithBufferView, bufferView: IBufferView) {\n        this._verifyBufferView(bufferView);\n        const properties = this.getPropertiesWithBufferView(bufferView);\n        properties.push(object);\n    }\n\n    /**\n     * Removes buffer view from the binary data, as well as from all its known references\n     * @param bufferView the bufferView to remove\n     */\n    public removeBufferView(bufferView: IBufferView): void {\n        const properties = this.getPropertiesWithBufferView(bufferView);\n        for (const object of properties) {\n            if (object.bufferView !== undefined) {\n                delete object.bufferView;\n            }\n        }\n\n        this._bufferViewToData.delete(bufferView);\n        this._bufferViewToProperties.delete(bufferView);\n        this._accessorToBufferView.forEach((bv, accessor) => {\n            if (bv === bufferView) {\n                // Additionally, remove byteOffset from accessor referencing this bufferView\n                if (accessor.byteOffset !== undefined) {\n                    delete accessor.byteOffset;\n                }\n                this._accessorToBufferView.delete(accessor);\n            }\n        });\n    }\n\n    public getBufferView(accessor: IAccessor): IBufferView {\n        const bufferView = this._accessorToBufferView.get(accessor);\n        this._verifyBufferView(bufferView);\n        return bufferView!;\n    }\n\n    public getPropertiesWithBufferView(bufferView: IBufferView): IPropertyWithBufferView[] {\n        this._verifyBufferView(bufferView);\n        this._bufferViewToProperties.set(bufferView, this._bufferViewToProperties.get(bufferView) ?? []);\n        return this._bufferViewToProperties.get(bufferView)!;\n    }\n\n    public getData(bufferView: IBufferView): TypedArrayForglTF {\n        this._verifyBufferView(bufferView);\n        return this._bufferViewToData.get(bufferView)!;\n    }\n\n    private _verifyBufferView(bufferView?: IBufferView): void {\n        if (bufferView === undefined || !this._bufferViewToData.has(bufferView)) {\n            throw new Error(`BufferView ${bufferView} not found in BufferManager.`);\n        }\n    }\n}\n","import type { IAnimation, INode, IBufferView, IAccessor, IAnimationSampler, IAnimationChannel } from \"babylonjs-gltf2interface\";\r\nimport { AnimationSamplerInterpolation, AnimationChannelTargetPath, AccessorType, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\n\r\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\n\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { BufferManager } from \"./bufferManager\";\r\nimport { GetAccessorElementCount, ConvertToRightHandedPosition, Rotate180Y, ConvertToRightHandedRotation } from \"./glTFUtilities\";\r\n\r\n/**\r\n * @internal\r\n * Interface to store animation data.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationData {\r\n    /**\r\n     * Keyframe data.\r\n     */\r\n    inputs: number[];\r\n    /**\r\n     * Value data.\r\n     */\r\n    outputs: number[][];\r\n    /**\r\n     * Animation interpolation data.\r\n     */\r\n    samplerInterpolation: AnimationSamplerInterpolation;\r\n    /**\r\n     * Minimum keyframe value.\r\n     */\r\n    inputsMin: number;\r\n    /**\r\n     * Maximum keyframe value.\r\n     */\r\n    inputsMax: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationInfo {\r\n    /**\r\n     * The target channel for the animation\r\n     */\r\n    animationChannelTargetPath: AnimationChannelTargetPath;\r\n    /**\r\n     * The glTF accessor type for the data.\r\n     */\r\n    dataAccessorType: AccessorType.VEC3 | AccessorType.VEC4 | AccessorType.SCALAR;\r\n    /**\r\n     * Specifies if quaternions should be used.\r\n     */\r\n    useQuaternion: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Enum for handling in tangent and out tangent.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _TangentType {\r\n    /**\r\n     * Specifies that input tangents are used.\r\n     */\r\n    INTANGENT,\r\n    /**\r\n     * Specifies that output tangents are used.\r\n     */\r\n    OUTTANGENT,\r\n}\r\n\r\n/**\r\n * @internal\r\n * Utility class for generating glTF animation data from BabylonJS.\r\n */\r\nexport class _GLTFAnimation {\r\n    /**\r\n     * Determine if a node is transformable - ie has properties it should be part of animation of transformation.\r\n     * @param babylonNode the node to test\r\n     * @returns true if can be animated, false otherwise. False if the parameter is null or undefined.\r\n     */\r\n    private static _IsTransformable(babylonNode: Node): boolean {\r\n        return babylonNode && (babylonNode instanceof TransformNode || babylonNode instanceof Camera || babylonNode instanceof Light);\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Creates glTF channel animation from BabylonJS animation.\r\n     * @param babylonTransformNode - BabylonJS mesh.\r\n     * @param animation - animation.\r\n     * @param animationChannelTargetPath - The target animation channel.\r\n     * @param useQuaternion - Specifies if quaternions are used.\r\n     * @returns nullable IAnimationData\r\n     */\r\n    public static _CreateNodeAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean,\r\n        animationSampleRate: number\r\n    ): Nullable<_IAnimationData> {\r\n        if (this._IsTransformable(babylonTransformNode)) {\r\n            const inputs: number[] = [];\r\n            const outputs: number[][] = [];\r\n            const keyFrames = animation.getKeys();\r\n            const minMaxKeyFrames = _GLTFAnimation._CalculateMinMaxKeyFrames(keyFrames);\r\n            const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\r\n\r\n            const interpolation = interpolationOrBake.interpolationType;\r\n            const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\r\n\r\n            if (shouldBakeAnimation) {\r\n                _GLTFAnimation._CreateBakedAnimation(\r\n                    babylonTransformNode,\r\n                    animation,\r\n                    animationChannelTargetPath,\r\n                    minMaxKeyFrames.min,\r\n                    minMaxKeyFrames.max,\r\n                    animation.framePerSecond,\r\n                    animationSampleRate,\r\n                    inputs,\r\n                    outputs,\r\n                    minMaxKeyFrames,\r\n                    useQuaternion\r\n                );\r\n            } else {\r\n                if (interpolation === AnimationSamplerInterpolation.LINEAR || interpolation === AnimationSamplerInterpolation.STEP) {\r\n                    _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);\r\n                } else if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                    _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);\r\n                } else {\r\n                    _GLTFAnimation._CreateBakedAnimation(\r\n                        babylonTransformNode,\r\n                        animation,\r\n                        animationChannelTargetPath,\r\n                        minMaxKeyFrames.min,\r\n                        minMaxKeyFrames.max,\r\n                        animation.framePerSecond,\r\n                        animationSampleRate,\r\n                        inputs,\r\n                        outputs,\r\n                        minMaxKeyFrames,\r\n                        useQuaternion\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (inputs.length && outputs.length) {\r\n                const result: _IAnimationData = {\r\n                    inputs: inputs,\r\n                    outputs: outputs,\r\n                    samplerInterpolation: interpolation,\r\n                    inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\r\n                    inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond),\r\n                };\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _DeduceAnimationInfo(animation: Animation): Nullable<_IAnimationInfo> {\r\n        let animationChannelTargetPath: Nullable<AnimationChannelTargetPath> = null;\r\n        let dataAccessorType = AccessorType.VEC3;\r\n        let useQuaternion: boolean = false;\r\n        const property = animation.targetProperty.split(\".\");\r\n        switch (property[0]) {\r\n            case \"scaling\": {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.SCALE;\r\n                break;\r\n            }\r\n            case \"position\": {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.TRANSLATION;\r\n                break;\r\n            }\r\n            case \"rotation\": {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case \"rotationQuaternion\": {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                useQuaternion = true;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case \"influence\": {\r\n                dataAccessorType = AccessorType.SCALAR;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.WEIGHTS;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported animatable property ${property[0]}`);\r\n            }\r\n        }\r\n        if (animationChannelTargetPath) {\r\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\r\n        } else {\r\n            Tools.Error(\"animation channel target path and data accessor type could be deduced\");\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the transform node animations\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param bufferManager\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAnimationFromNodeAnimations(\r\n        babylonNode: Node,\r\n        runtimeGLTFAnimation: IAnimation,\r\n        idleGLTFAnimations: IAnimation[],\r\n        nodeMap: Map<Node, number>,\r\n        nodes: INode[],\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        useRightHanded: boolean,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (_GLTFAnimation._IsTransformable(babylonNode)) {\r\n            if (babylonNode.animations) {\r\n                for (const animation of babylonNode.animations) {\r\n                    if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                        continue;\r\n                    }\r\n                    const animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\r\n                    if (animationInfo) {\r\n                        glTFAnimation = {\r\n                            name: animation.name,\r\n                            samplers: [],\r\n                            channels: [],\r\n                        };\r\n                        _GLTFAnimation._AddAnimation(\r\n                            `${animation.name}`,\r\n                            animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                            babylonNode,\r\n                            animation,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            bufferManager,\r\n                            bufferViews,\r\n                            accessors,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate,\r\n                            useRightHanded\r\n                        );\r\n                        if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                            idleGLTFAnimations.push(glTFAnimation);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create individual morph animations from the mesh's morph target animation tracks\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param bufferManager\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateMorphTargetAnimationFromMorphTargetAnimations(\r\n        babylonNode: Node,\r\n        runtimeGLTFAnimation: IAnimation,\r\n        idleGLTFAnimations: IAnimation[],\r\n        nodeMap: Map<Node, number>,\r\n        nodes: INode[],\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        useRightHanded: boolean,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonNode instanceof Mesh) {\r\n            const morphTargetManager = babylonNode.morphTargetManager;\r\n            if (morphTargetManager) {\r\n                for (let i = 0; i < morphTargetManager.numTargets; ++i) {\r\n                    const morphTarget = morphTargetManager.getTarget(i);\r\n                    for (const animation of morphTarget.animations) {\r\n                        if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                            continue;\r\n                        }\r\n                        const combinedAnimation = new Animation(\r\n                            `${animation.name}`,\r\n                            \"influence\",\r\n                            animation.framePerSecond,\r\n                            animation.dataType,\r\n                            animation.loopMode,\r\n                            animation.enableBlending\r\n                        );\r\n                        const combinedAnimationKeys: IAnimationKey[] = [];\r\n                        const animationKeys = animation.getKeys();\r\n\r\n                        for (let j = 0; j < animationKeys.length; ++j) {\r\n                            const animationKey = animationKeys[j];\r\n                            for (let k = 0; k < morphTargetManager.numTargets; ++k) {\r\n                                if (k == i) {\r\n                                    combinedAnimationKeys.push(animationKey);\r\n                                } else {\r\n                                    combinedAnimationKeys.push({ frame: animationKey.frame, value: 0 });\r\n                                }\r\n                            }\r\n                        }\r\n                        combinedAnimation.setKeys(combinedAnimationKeys);\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(combinedAnimation);\r\n                        if (animationInfo) {\r\n                            glTFAnimation = {\r\n                                name: combinedAnimation.name,\r\n                                samplers: [],\r\n                                channels: [],\r\n                            };\r\n                            _GLTFAnimation._AddAnimation(\r\n                                animation.name,\r\n                                animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                                babylonNode,\r\n                                combinedAnimation,\r\n                                animationInfo.dataAccessorType,\r\n                                animationInfo.animationChannelTargetPath,\r\n                                nodeMap,\r\n                                bufferManager,\r\n                                bufferViews,\r\n                                accessors,\r\n                                animationInfo.useQuaternion,\r\n                                animationSampleRate,\r\n                                useRightHanded,\r\n                                morphTargetManager.numTargets\r\n                            );\r\n                            if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                                idleGLTFAnimations.push(glTFAnimation);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Create node and morph animations from the animation groups\r\n     * @param babylonScene\r\n     * @param glTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param bufferManager\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAndMorphAnimationFromAnimationGroups(\r\n        babylonScene: Scene,\r\n        glTFAnimations: IAnimation[],\r\n        nodeMap: Map<Node, number>,\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        leftHandedNodes: Set<Node>,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonScene.animationGroups) {\r\n            const animationGroups = babylonScene.animationGroups;\r\n            for (const animationGroup of animationGroups) {\r\n                const morphAnimations: Map<Mesh, Map<MorphTarget, Animation>> = new Map();\r\n                const sampleAnimations: Map<Mesh, Animation> = new Map();\r\n                const morphAnimationMeshes: Set<Mesh> = new Set();\r\n                const animationGroupFrameDiff = animationGroup.to - animationGroup.from;\r\n                glTFAnimation = {\r\n                    name: animationGroup.name,\r\n                    channels: [],\r\n                    samplers: [],\r\n                };\r\n                for (let i = 0; i < animationGroup.targetedAnimations.length; ++i) {\r\n                    const targetAnimation = animationGroup.targetedAnimations[i];\r\n                    const target = targetAnimation.target;\r\n                    const animation = targetAnimation.animation;\r\n                    if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                        continue;\r\n                    }\r\n\r\n                    const convertToRightHanded = leftHandedNodes.has(target);\r\n\r\n                    if (this._IsTransformable(target) || (target.length === 1 && this._IsTransformable(target[0]))) {\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            const babylonTransformNode = this._IsTransformable(target) ? target : this._IsTransformable(target[0]) ? target[0] : null;\r\n                            if (babylonTransformNode) {\r\n                                _GLTFAnimation._AddAnimation(\r\n                                    `${animation.name}`,\r\n                                    glTFAnimation,\r\n                                    babylonTransformNode,\r\n                                    animation,\r\n                                    animationInfo.dataAccessorType,\r\n                                    animationInfo.animationChannelTargetPath,\r\n                                    nodeMap,\r\n                                    bufferManager,\r\n                                    bufferViews,\r\n                                    accessors,\r\n                                    animationInfo.useQuaternion,\r\n                                    animationSampleRate,\r\n                                    convertToRightHanded\r\n                                );\r\n                            }\r\n                        }\r\n                    } else if (target instanceof MorphTarget || (target.length === 1 && target[0] instanceof MorphTarget)) {\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            const babylonMorphTarget = target instanceof MorphTarget ? target : (target[0] as MorphTarget);\r\n                            if (babylonMorphTarget) {\r\n                                const babylonMorphTargetManager = babylonScene.morphTargetManagers.find((morphTargetManager) => {\r\n                                    for (let j = 0; j < morphTargetManager.numTargets; ++j) {\r\n                                        if (morphTargetManager.getTarget(j) === babylonMorphTarget) {\r\n                                            return true;\r\n                                        }\r\n                                    }\r\n                                    return false;\r\n                                });\r\n                                if (babylonMorphTargetManager) {\r\n                                    const babylonMesh = babylonScene.meshes.find((mesh) => {\r\n                                        return (mesh as Mesh).morphTargetManager === babylonMorphTargetManager;\r\n                                    }) as Mesh;\r\n                                    if (babylonMesh) {\r\n                                        if (!morphAnimations.has(babylonMesh)) {\r\n                                            morphAnimations.set(babylonMesh, new Map());\r\n                                        }\r\n                                        morphAnimations.get(babylonMesh)?.set(babylonMorphTarget, animation);\r\n                                        morphAnimationMeshes.add(babylonMesh);\r\n                                        sampleAnimations.set(babylonMesh, animation);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        // this is the place for the KHR_animation_pointer.\r\n                    }\r\n                }\r\n                morphAnimationMeshes.forEach((mesh) => {\r\n                    const morphTargetManager = mesh.morphTargetManager!;\r\n                    let combinedAnimationGroup: Nullable<Animation> = null;\r\n                    const animationKeys: IAnimationKey[] = [];\r\n                    const sampleAnimation = sampleAnimations.get(mesh)!;\r\n                    const sampleAnimationKeys = sampleAnimation.getKeys();\r\n                    const numAnimationKeys = sampleAnimationKeys.length;\r\n                    /*\r\n                        Due to how glTF expects morph target animation data to be formatted, we need to rearrange the individual morph target animation tracks,\r\n                        such that we have a single animation, where a given keyframe input value has successive output values for each morph target belonging to the manager.\r\n                        See: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n\r\n                        We do this via constructing a new Animation track, and interleaving the frames of each morph target animation track in the current Animation Group\r\n                        We reuse the Babylon Animation data structure for ease of handling export of cubic spline animation keys, and to reuse the\r\n                        existing _GLTFAnimation.AddAnimation codepath with minimal modification, however the constructed Babylon Animation is NOT intended for use in-engine.\r\n                    */\r\n                    for (let i = 0; i < numAnimationKeys; ++i) {\r\n                        for (let j = 0; j < morphTargetManager.numTargets; ++j) {\r\n                            const morphTarget = morphTargetManager.getTarget(j);\r\n                            const animationsByMorphTarget = morphAnimations.get(mesh);\r\n                            if (animationsByMorphTarget) {\r\n                                const morphTargetAnimation = animationsByMorphTarget.get(morphTarget);\r\n                                if (morphTargetAnimation) {\r\n                                    if (!combinedAnimationGroup) {\r\n                                        combinedAnimationGroup = new Animation(\r\n                                            `${animationGroup.name}_${mesh.name}_MorphWeightAnimation`,\r\n                                            \"influence\",\r\n                                            morphTargetAnimation.framePerSecond,\r\n                                            Animation.ANIMATIONTYPE_FLOAT,\r\n                                            morphTargetAnimation.loopMode,\r\n                                            morphTargetAnimation.enableBlending\r\n                                        );\r\n                                    }\r\n                                    animationKeys.push(morphTargetAnimation.getKeys()[i]);\r\n                                } else {\r\n                                    animationKeys.push({\r\n                                        frame: animationGroup.from + (animationGroupFrameDiff / numAnimationKeys) * i,\r\n                                        value: morphTarget.influence,\r\n                                        inTangent: sampleAnimationKeys[0].inTangent ? 0 : undefined,\r\n                                        outTangent: sampleAnimationKeys[0].outTangent ? 0 : undefined,\r\n                                    });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    combinedAnimationGroup!.setKeys(animationKeys);\r\n                    const animationInfo = _GLTFAnimation._DeduceAnimationInfo(combinedAnimationGroup!);\r\n                    if (animationInfo) {\r\n                        _GLTFAnimation._AddAnimation(\r\n                            `${animationGroup.name}_${mesh.name}_MorphWeightAnimation`,\r\n                            glTFAnimation,\r\n                            mesh,\r\n                            combinedAnimationGroup!,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            bufferManager,\r\n                            bufferViews,\r\n                            accessors,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate,\r\n                            false,\r\n                            morphTargetManager?.numTargets\r\n                        );\r\n                    }\r\n                });\r\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\r\n                    glTFAnimations.push(glTFAnimation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _AddAnimation(\r\n        name: string,\r\n        glTFAnimation: IAnimation,\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        dataAccessorType: AccessorType,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        nodeMap: Map<Node, number>,\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        useQuaternion: boolean,\r\n        animationSampleRate: number,\r\n        convertToRightHanded: boolean,\r\n        morphAnimationChannels?: number\r\n    ) {\r\n        const animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, useQuaternion, animationSampleRate);\r\n        let bufferView: IBufferView;\r\n        let accessor: IAccessor;\r\n        let keyframeAccessorIndex: number;\r\n        let dataAccessorIndex: number;\r\n        let animationSampler: IAnimationSampler;\r\n        let animationChannel: IAnimationChannel;\r\n\r\n        if (animationData) {\r\n            /*\r\n             * Now that we have the glTF converted morph target animation data,\r\n             * we can remove redundant input data so that we have n input frames,\r\n             * and morphAnimationChannels * n output frames\r\n             */\r\n            if (morphAnimationChannels) {\r\n                let index = 0;\r\n                let currentInput: number = 0;\r\n                const newInputs: number[] = [];\r\n                while (animationData.inputs.length > 0) {\r\n                    currentInput = animationData.inputs.shift()!;\r\n                    if (index % morphAnimationChannels == 0) {\r\n                        newInputs.push(currentInput);\r\n                    }\r\n                    index++;\r\n                }\r\n                animationData.inputs = newInputs;\r\n            }\r\n\r\n            const nodeIndex = nodeMap.get(babylonTransformNode);\r\n\r\n            // Create buffer view and accessor for key frames.\r\n            const inputData = new Float32Array(animationData.inputs);\r\n            bufferView = bufferManager.createBufferView(inputData);\r\n            accessor = bufferManager.createAccessor(bufferView, AccessorType.SCALAR, AccessorComponentType.FLOAT, animationData.inputs.length, undefined, {\r\n                min: [animationData.inputsMin],\r\n                max: [animationData.inputsMax],\r\n            });\r\n            accessors.push(accessor);\r\n            keyframeAccessorIndex = accessors.length - 1;\r\n\r\n            // Perform conversions on keyed values while also building their buffer.\r\n            const rotationQuaternion = new Quaternion();\r\n            const eulerVec3 = new Vector3();\r\n            const position = new Vector3();\r\n            const isCamera = babylonTransformNode instanceof Camera;\r\n\r\n            const elementCount = GetAccessorElementCount(dataAccessorType);\r\n            const outputData = new Float32Array(animationData.outputs.length * elementCount);\r\n            animationData.outputs.forEach(function (output: number[], index: number) {\r\n                let outputToWrite: number[] = output;\r\n                switch (animationChannelTargetPath) {\r\n                    case AnimationChannelTargetPath.TRANSLATION:\r\n                        if (convertToRightHanded) {\r\n                            Vector3.FromArrayToRef(output, 0, position);\r\n                            ConvertToRightHandedPosition(position);\r\n                            position.toArray(outputToWrite);\r\n                        }\r\n                        break;\r\n                    case AnimationChannelTargetPath.ROTATION:\r\n                        if (output.length === 4) {\r\n                            Quaternion.FromArrayToRef(output, 0, rotationQuaternion);\r\n                        } else {\r\n                            outputToWrite = new Array(4); // Will need 4, not 3, for a quaternion\r\n                            Vector3.FromArrayToRef(output, 0, eulerVec3);\r\n                            Quaternion.FromEulerVectorToRef(eulerVec3, rotationQuaternion);\r\n                        }\r\n\r\n                        if (convertToRightHanded) {\r\n                            ConvertToRightHandedRotation(rotationQuaternion);\r\n                            if (isCamera) {\r\n                                Rotate180Y(rotationQuaternion);\r\n                            }\r\n                        }\r\n\r\n                        rotationQuaternion.toArray(outputToWrite);\r\n                        break;\r\n                }\r\n                outputData.set(outputToWrite, index * elementCount);\r\n            });\r\n\r\n            // Create buffer view and accessor for keyed values.\r\n            bufferView = bufferManager.createBufferView(outputData);\r\n            accessor = bufferManager.createAccessor(bufferView, dataAccessorType, AccessorComponentType.FLOAT, animationData.outputs.length);\r\n            accessors.push(accessor);\r\n            dataAccessorIndex = accessors.length - 1;\r\n\r\n            // create sampler\r\n            animationSampler = {\r\n                interpolation: animationData.samplerInterpolation,\r\n                input: keyframeAccessorIndex,\r\n                output: dataAccessorIndex,\r\n            };\r\n            glTFAnimation.samplers.push(animationSampler);\r\n\r\n            // create channel\r\n            animationChannel = {\r\n                sampler: glTFAnimation.samplers.length - 1,\r\n                target: {\r\n                    node: nodeIndex,\r\n                    path: animationChannelTargetPath,\r\n                },\r\n            };\r\n            glTFAnimation.channels.push(animationChannel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a baked animation\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\r\n     * @param animationChannelTargetPath animation target channel\r\n     * @param minFrame minimum animation frame\r\n     * @param maxFrame maximum animation frame\r\n     * @param fps frames per second of the animation\r\n     * @param sampleRate\r\n     * @param inputs input key frames of the animation\r\n     * @param outputs output key frame data of the animation\r\n     * @param minMaxFrames\r\n     * @param minMaxFrames.min\r\n     * @param minMaxFrames.max\r\n     * @param useQuaternion specifies if quaternions should be used\r\n     */\r\n    private static _CreateBakedAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        minFrame: number,\r\n        maxFrame: number,\r\n        fps: number,\r\n        sampleRate: number,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        minMaxFrames: { min: number; max: number },\r\n        useQuaternion: boolean\r\n    ) {\r\n        let value: number | Vector3 | Quaternion;\r\n        const quaternionCache: Quaternion = Quaternion.Identity();\r\n        let previousTime: Nullable<number> = null;\r\n        let time: number;\r\n        let maxUsedFrame: Nullable<number> = null;\r\n        let currKeyFrame: Nullable<IAnimationKey> = null;\r\n        let nextKeyFrame: Nullable<IAnimationKey> = null;\r\n        let prevKeyFrame: Nullable<IAnimationKey> = null;\r\n        let endFrame: Nullable<number> = null;\r\n        minMaxFrames.min = Tools.FloatRound(minFrame / fps);\r\n\r\n        const keyFrames = animation.getKeys();\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            endFrame = null;\r\n            currKeyFrame = keyFrames[i];\r\n\r\n            if (i + 1 < length) {\r\n                nextKeyFrame = keyFrames[i + 1];\r\n                if ((currKeyFrame.value.equals && currKeyFrame.value.equals(nextKeyFrame.value)) || currKeyFrame.value === nextKeyFrame.value) {\r\n                    if (i === 0) {\r\n                        // set the first frame to itself\r\n                        endFrame = currKeyFrame.frame;\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    endFrame = nextKeyFrame.frame;\r\n                }\r\n            } else {\r\n                // at the last key frame\r\n                prevKeyFrame = keyFrames[i - 1];\r\n                if ((currKeyFrame.value.equals && currKeyFrame.value.equals(prevKeyFrame.value)) || currKeyFrame.value === prevKeyFrame.value) {\r\n                    continue;\r\n                } else {\r\n                    endFrame = maxFrame;\r\n                }\r\n            }\r\n            if (endFrame) {\r\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\r\n                    time = Tools.FloatRound(f / fps);\r\n                    if (time === previousTime) {\r\n                        continue;\r\n                    }\r\n                    previousTime = time;\r\n                    maxUsedFrame = time;\r\n                    const state = {\r\n                        key: 0,\r\n                        repeatCount: 0,\r\n                        loopMode: animation.loopMode,\r\n                    };\r\n                    value = animation._interpolate(f, state);\r\n\r\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, useQuaternion);\r\n                }\r\n            }\r\n        }\r\n        if (maxUsedFrame) {\r\n            minMaxFrames.max = maxUsedFrame;\r\n        }\r\n    }\r\n\r\n    private static _ConvertFactorToVector3OrQuaternion(\r\n        factor: number,\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean\r\n    ): Vector3 | Quaternion {\r\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, useQuaternion);\r\n        // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n        const property = animation.targetProperty.split(\".\");\r\n        const componentName = property ? property[1] : \"\"; // x, y, z, or w component\r\n        const value = useQuaternion ? Quaternion.FromArray(basePositionRotationOrScale).normalize() : Vector3.FromArray(basePositionRotationOrScale);\r\n\r\n        switch (componentName) {\r\n            case \"x\":\r\n            case \"y\":\r\n            case \"z\": {\r\n                value[componentName] = factor;\r\n                break;\r\n            }\r\n            case \"w\": {\r\n                (value as Quaternion).w = factor;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`glTFAnimation: Unsupported component name \"${componentName}\"!`);\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private static _SetInterpolatedValue(\r\n        babylonTransformNode: Node,\r\n        value: number | Vector3 | Quaternion,\r\n        time: number,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        quaternionCache: Quaternion,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        let cacheValue: Vector3 | Quaternion | number;\r\n        inputs.push(time);\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n            outputs.push([value as number]);\r\n            return;\r\n        }\r\n\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_FLOAT) {\r\n            value = this._ConvertFactorToVector3OrQuaternion(value as number, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion);\r\n        }\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                quaternionCache = value as Quaternion;\r\n            } else {\r\n                cacheValue = value as Vector3;\r\n                Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\r\n            }\r\n            outputs.push(quaternionCache.asArray());\r\n        } else {\r\n            // scaling and position animation\r\n            cacheValue = value as Vector3;\r\n            outputs.push(cacheValue.asArray());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates linear animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateLinearOrStepAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        for (const keyFrame of animation.getKeys()) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates cubic spline animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateCubicSplineAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        animation.getKeys().forEach(function (keyFrame) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddSplineTangent(_TangentType.INTANGENT, outputs, animationChannelTargetPath, AnimationSamplerInterpolation.CUBICSPLINE, keyFrame, useQuaternion);\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);\r\n\r\n            _GLTFAnimation._AddSplineTangent(_TangentType.OUTTANGENT, outputs, animationChannelTargetPath, AnimationSamplerInterpolation.CUBICSPLINE, keyFrame, useQuaternion);\r\n        });\r\n    }\r\n\r\n    private static _GetBasePositionRotationOrScale(babylonTransformNode: Node, animationChannelTargetPath: AnimationChannelTargetPath, useQuaternion: boolean) {\r\n        let basePositionRotationOrScale: number[];\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                const q = (babylonTransformNode as TransformNode).rotationQuaternion;\r\n                basePositionRotationOrScale = (q ?? Quaternion.Identity()).asArray();\r\n            } else {\r\n                const r: Vector3 = (babylonTransformNode as TransformNode).rotation;\r\n                basePositionRotationOrScale = (r ?? Vector3.Zero()).asArray();\r\n            }\r\n        } else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n            const p: Vector3 = (babylonTransformNode as TransformNode).position;\r\n            basePositionRotationOrScale = (p ?? Vector3.Zero()).asArray();\r\n        } else {\r\n            // scale\r\n            const s: Vector3 = (babylonTransformNode as TransformNode).scaling;\r\n            basePositionRotationOrScale = (s ?? Vector3.One()).asArray();\r\n        }\r\n        return basePositionRotationOrScale;\r\n    }\r\n\r\n    /**\r\n     * Adds a key frame value\r\n     * @param keyFrame\r\n     * @param animation\r\n     * @param outputs\r\n     * @param animationChannelTargetPath\r\n     * @param babylonTransformNode\r\n     * @param useQuaternion\r\n     */\r\n    private static _AddKeyframeValue(\r\n        keyFrame: IAnimationKey,\r\n        animation: Animation,\r\n        outputs: number[][],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        babylonTransformNode: Node,\r\n        useQuaternion: boolean\r\n    ) {\r\n        let newPositionRotationOrScale: Nullable<Vector3 | Quaternion | number>;\r\n        const animationType = animation.dataType;\r\n        if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {\r\n            let value = keyFrame.value.asArray();\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                const array = Vector3.FromArray(value);\r\n                const rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\r\n                value = rotationQuaternion.asArray();\r\n            }\r\n            outputs.push(value); // scale  vector.\r\n        } else if (animationType === Animation.ANIMATIONTYPE_FLOAT) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n                outputs.push([keyFrame.value]);\r\n            } else {\r\n                // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n                newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(\r\n                    keyFrame.value as number,\r\n                    babylonTransformNode,\r\n                    animation,\r\n                    animationChannelTargetPath,\r\n                    useQuaternion\r\n                );\r\n                if (newPositionRotationOrScale) {\r\n                    if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                        const posRotScale = useQuaternion\r\n                            ? (newPositionRotationOrScale as Quaternion)\r\n                            : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\r\n                        outputs.push(posRotScale.asArray());\r\n                    }\r\n                    outputs.push(newPositionRotationOrScale.asArray());\r\n                }\r\n            }\r\n        } else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            outputs.push((keyFrame.value as Quaternion).normalize().asArray());\r\n        } else {\r\n            Tools.Error(\"glTFAnimation: Unsupported key frame values for animation!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Determine the interpolation based on the key frames\r\n     * @param keyFrames\r\n     * @param animationChannelTargetPath\r\n     * @param useQuaternion\r\n     */\r\n    private static _DeduceInterpolation(\r\n        keyFrames: IAnimationKey[],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean\r\n    ): { interpolationType: AnimationSamplerInterpolation; shouldBakeAnimation: boolean } {\r\n        let interpolationType: AnimationSamplerInterpolation | undefined;\r\n        let shouldBakeAnimation = false;\r\n        let key: IAnimationKey;\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION && !useQuaternion) {\r\n            return { interpolationType: AnimationSamplerInterpolation.LINEAR, shouldBakeAnimation: true };\r\n        }\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            key = keyFrames[i];\r\n            if (key.inTangent || key.outTangent) {\r\n                if (interpolationType) {\r\n                    if (interpolationType !== AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    interpolationType = AnimationSamplerInterpolation.CUBICSPLINE;\r\n                }\r\n            } else {\r\n                if (interpolationType) {\r\n                    if (\r\n                        interpolationType === AnimationSamplerInterpolation.CUBICSPLINE ||\r\n                        (key.interpolation && key.interpolation === AnimationKeyInterpolation.STEP && interpolationType !== AnimationSamplerInterpolation.STEP)\r\n                    ) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    if (key.interpolation && key.interpolation === AnimationKeyInterpolation.STEP) {\r\n                        interpolationType = AnimationSamplerInterpolation.STEP;\r\n                    } else {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!interpolationType) {\r\n            interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n        }\r\n\r\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\r\n    }\r\n\r\n    /**\r\n     * Adds an input tangent or output tangent to the output data\r\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\r\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\r\n     * @param outputs The animation data by keyframe\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param interpolation The interpolation type\r\n     * @param keyFrame The key frame with the animation data\r\n     * @param useQuaternion Specifies if quaternions are used\r\n     */\r\n    private static _AddSplineTangent(\r\n        tangentType: _TangentType,\r\n        outputs: number[][],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        interpolation: AnimationSamplerInterpolation,\r\n        keyFrame: IAnimationKey,\r\n        useQuaternion: boolean\r\n    ) {\r\n        let tangent: number[];\r\n        const tangentValue: Vector3 | Quaternion | number = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\r\n        if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (tangentValue) {\r\n                    if (useQuaternion) {\r\n                        tangent = (tangentValue as Quaternion).asArray();\r\n                    } else {\r\n                        const array = tangentValue as Vector3;\r\n                        tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\r\n                    }\r\n                } else {\r\n                    tangent = [0, 0, 0, 0];\r\n                }\r\n            } else if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n                if (tangentValue) {\r\n                    tangent = [tangentValue as number];\r\n                } else {\r\n                    tangent = [0];\r\n                }\r\n            } else {\r\n                if (tangentValue) {\r\n                    tangent = (tangentValue as Vector3).asArray();\r\n                } else {\r\n                    tangent = [0, 0, 0];\r\n                }\r\n            }\r\n\r\n            outputs.push(tangent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the minimum and maximum key frames' frame values\r\n     * @param keyFrames animation key frames\r\n     * @returns the minimum and maximum key frame value\r\n     */\r\n    private static _CalculateMinMaxKeyFrames(keyFrames: IAnimationKey[]): { min: number; max: number } {\r\n        let min: number = Infinity;\r\n        let max: number = -Infinity;\r\n        keyFrames.forEach(function (keyFrame) {\r\n            min = Math.min(min, keyFrame.frame);\r\n            max = Math.max(max, keyFrame.frame);\r\n        });\r\n\r\n        return { min: min, max: max };\r\n    }\r\n}\r\n","import type { IBufferView, IAccessor } from \"babylonjs-gltf2interface\";\r\nimport { AccessorComponentType, AccessorType } from \"babylonjs-gltf2interface\";\r\nimport type { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport type { BufferManager } from \"./bufferManager\";\r\n\r\nimport { NormalizeTangent } from \"./glTFUtilities\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Vector3, Vector4 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Interface to store morph target information.\r\n * @internal\r\n */\r\nexport interface IMorphTargetData {\r\n    attributes: Record<string, number>;\r\n    influence: number;\r\n    name: string;\r\n}\r\n\r\nexport function BuildMorphTargetBuffers(\r\n    morphTarget: MorphTarget,\r\n    mesh: AbstractMesh,\r\n    bufferManager: BufferManager,\r\n    bufferViews: IBufferView[],\r\n    accessors: IAccessor[],\r\n    convertToRightHanded: boolean\r\n): IMorphTargetData {\r\n    const result: IMorphTargetData = {\r\n        attributes: {},\r\n        influence: morphTarget.influence,\r\n        name: morphTarget.name,\r\n    };\r\n\r\n    const geometry = mesh.geometry;\r\n    if (!geometry) {\r\n        Tools.Warn(\"Attempted to export morph target data from a mesh without geometry. This should not happen.\");\r\n        return result;\r\n    }\r\n\r\n    const flipX = convertToRightHanded ? -1 : 1;\r\n    const floatSize = 4;\r\n    const difference = Vector3.Zero();\r\n    let vertexStart = 0;\r\n    let vertexCount = 0;\r\n\r\n    if (morphTarget.hasPositions) {\r\n        const morphPositions = morphTarget.getPositions()!;\r\n        const originalPositions = geometry.getVerticesData(VertexBuffer.PositionKind); // Bypasses any instance data of mesh\r\n\r\n        if (originalPositions) {\r\n            const positionData = new Float32Array(originalPositions.length);\r\n            const min = [Infinity, Infinity, Infinity];\r\n            const max = [-Infinity, -Infinity, -Infinity];\r\n            vertexCount = originalPositions.length / 3;\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                const originalPosition = Vector3.FromArray(originalPositions, i * 3);\r\n                const morphPosition = Vector3.FromArray(morphPositions, i * 3);\r\n                morphPosition.subtractToRef(originalPosition, difference);\r\n                difference.x *= flipX;\r\n\r\n                min[0] = Math.min(min[0], difference.x);\r\n                max[0] = Math.max(max[0], difference.x);\r\n\r\n                min[1] = Math.min(min[1], difference.y);\r\n                max[1] = Math.max(max[1], difference.y);\r\n\r\n                min[2] = Math.min(min[2], difference.z);\r\n                max[2] = Math.max(max[2], difference.z);\r\n\r\n                positionData[i * 3] = difference.x;\r\n                positionData[i * 3 + 1] = difference.y;\r\n                positionData[i * 3 + 2] = difference.z;\r\n            }\r\n\r\n            const bufferView = bufferManager.createBufferView(positionData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, morphPositions.length / 3, 0, { min, max });\r\n            accessors.push(accessor);\r\n            result.attributes[\"POSITION\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target positions for mesh ${mesh.name} were not exported. Mesh does not have position vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasNormals) {\r\n        const morphNormals = morphTarget.getNormals()!;\r\n        const originalNormals = geometry.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n        if (originalNormals) {\r\n            const normalData = new Float32Array(originalNormals.length);\r\n            vertexCount = originalNormals.length / 3;\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                const originalNormal = Vector3.FromArray(originalNormals, i * 3).normalize();\r\n                const morphNormal = Vector3.FromArray(morphNormals, i * 3).normalize();\r\n                morphNormal.subtractToRef(originalNormal, difference);\r\n\r\n                normalData[i * 3] = difference.x * flipX;\r\n                normalData[i * 3 + 1] = difference.y;\r\n                normalData[i * 3 + 2] = difference.z;\r\n            }\r\n\r\n            const bufferView = bufferManager.createBufferView(normalData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, morphNormals.length / 3, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"NORMAL\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target normals for mesh ${mesh.name} were not exported. Mesh does not have normals vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasTangents) {\r\n        const morphTangents = morphTarget.getTangents()!;\r\n        const originalTangents = geometry.getVerticesData(VertexBuffer.TangentKind);\r\n\r\n        if (originalTangents) {\r\n            vertexCount = originalTangents.length / 4;\r\n            const tangentData = new Float32Array(vertexCount * 3);\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                // Only read the x, y, z components and ignore w\r\n                const originalTangent = Vector3.FromArray(originalTangents, i * 4);\r\n                NormalizeTangent(originalTangent);\r\n\r\n                // Morph target tangents omit the w component so it won't be present in the data\r\n                const morphTangent = Vector3.FromArray(morphTangents, i * 3);\r\n                NormalizeTangent(morphTangent);\r\n\r\n                morphTangent.subtractToRef(originalTangent, difference);\r\n                tangentData[i * 3] = difference.x * flipX;\r\n                tangentData[i * 3 + 1] = difference.y;\r\n                tangentData[i * 3 + 2] = difference.z;\r\n            }\r\n            const bufferView = bufferManager.createBufferView(tangentData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, vertexCount, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"TANGENT\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target tangents for mesh ${mesh.name} were not exported. Mesh does not have tangents vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasColors) {\r\n        const morphColors = morphTarget.getColors()!;\r\n        const originalColors = geometry.getVerticesData(VertexBuffer.ColorKind);\r\n        const buffer = geometry.getVertexBuffer(VertexBuffer.ColorKind);\r\n\r\n        if (originalColors && buffer) {\r\n            const componentSize = buffer.getSize();\r\n\r\n            vertexCount = originalColors.length / componentSize;\r\n            const colorData = new Float32Array(vertexCount * componentSize);\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                if (componentSize === 3) {\r\n                    const originalColor = Vector3.FromArray(originalColors, i * componentSize);\r\n                    const morphColor = Vector3.FromArray(morphColors, i * componentSize);\r\n\r\n                    morphColor.subtractToRef(originalColor, difference);\r\n                    colorData[i * 3] = difference.x;\r\n                    colorData[i * 3 + 1] = difference.y;\r\n                    colorData[i * 3 + 2] = difference.z;\r\n                } else if (componentSize === 4) {\r\n                    const difference4 = new Vector4();\r\n                    const originalColor = Vector4.FromArray(originalColors, i * componentSize);\r\n                    const morphColor = Vector4.FromArray(morphColors, i * componentSize);\r\n\r\n                    morphColor.subtractToRef(originalColor, difference4);\r\n                    colorData[i * 4] = difference4.x;\r\n                    colorData[i * 4 + 1] = difference4.y;\r\n                    colorData[i * 4 + 2] = difference4.z;\r\n                    colorData[i * 4 + 3] = difference4.w;\r\n                } else {\r\n                    Tools.Warn(`Unsupported number of components for color attribute: ${componentSize}`);\r\n                }\r\n            }\r\n            const bufferView = bufferManager.createBufferView(colorData, floatSize * componentSize);\r\n            const accessor = bufferManager.createAccessor(bufferView, componentSize === 3 ? AccessorType.VEC3 : AccessorType.VEC4, AccessorComponentType.FLOAT, vertexCount, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"COLOR_0\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target colors for mesh ${mesh.name} were not exported. Mesh does not have colors vertex data`);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n","import type {\r\n    IBufferView,\r\n    IAccessor,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IMaterial,\r\n    ITexture,\r\n    IImage,\r\n    ISampler,\r\n    IAnimation,\r\n    IMeshPrimitive,\r\n    IBuffer,\r\n    IGLTF,\r\n    ITextureInfo,\r\n    ISkin,\r\n    ICamera,\r\n    ImageMimeType,\r\n} from \"babylonjs-gltf2interface\";\r\nimport { AccessorComponentType, AccessorType, CameraType } from \"babylonjs-gltf2interface\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"core/types\";\r\nimport { TmpVectors, Quaternion } from \"core/Maths/math.vector\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Buffer } from \"core/Buffers/buffer\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Node } from \"core/node\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { Engine } from \"core/Engines/engine\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\nimport type { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport type { IExportOptions } from \"./glTFSerializer\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport {\r\n    ConvertToRightHandedPosition,\r\n    ConvertToRightHandedRotation,\r\n    DataArrayToUint8Array,\r\n    GetAccessorType,\r\n    GetAttributeType,\r\n    GetMinMax,\r\n    GetPrimitiveMode,\r\n    IsTriangleFillMode,\r\n    IsChildCollapsible,\r\n    FloatsNeed16BitInteger,\r\n    IsStandardVertexAttribute,\r\n    IndicesArrayToTypedArray,\r\n    GetVertexBufferInfo,\r\n    CollapseChildIntoParent,\r\n    Rotate180Y,\r\n    DefaultTranslation,\r\n    DefaultScale,\r\n    DefaultRotation,\r\n    ConvertToRightHandedTransformMatrix,\r\n} from \"./glTFUtilities\";\r\nimport { IsNoopNode } from \"../../exportUtils\";\r\nimport { BufferManager } from \"./bufferManager\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { EnumerateFloatValues, AreIndices32Bits } from \"core/Buffers/bufferUtils\";\r\nimport type { Bone, Skeleton } from \"core/Bones\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\nimport type { MorphTarget } from \"core/Morph\";\r\nimport { BuildMorphTargetBuffers } from \"./glTFMorphTargetsUtilities\";\r\nimport type { IMorphTargetData } from \"./glTFMorphTargetsUtilities\";\r\nimport { LinesMesh } from \"core/Meshes/linesMesh\";\r\nimport { GreasedLineBaseMesh } from \"core/Meshes/GreasedLine/greasedLineBaseMesh\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { TargetCamera } from \"core/Cameras/targetCamera\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\nimport { DataWriter } from \"./dataWriter\";\r\n\r\nclass ExporterState {\r\n    // Babylon indices array, start, count, offset, flip -> glTF accessor index\r\n    private _indicesAccessorMap = new Map<Nullable<IndicesArray>, Map<number, Map<number, Map<number, Map<boolean, number>>>>>();\r\n\r\n    // Babylon buffer -> glTF buffer view\r\n    private _vertexBufferViewMap = new Map<Buffer, IBufferView>();\r\n\r\n    // Babylon vertex buffer, start, count -> glTF accessor index\r\n    private _vertexAccessorMap = new Map<VertexBuffer, Map<number, Map<number, number>>>();\r\n\r\n    private _remappedBufferView = new Map<Buffer, Map<VertexBuffer, IBufferView>>();\r\n\r\n    private _meshMorphTargetMap = new Map<AbstractMesh, IMorphTargetData[]>();\r\n\r\n    private _vertexMapColorAlpha = new Map<VertexBuffer, boolean>();\r\n\r\n    private _exportedNodes = new Set<Node>();\r\n\r\n    // Babylon mesh -> glTF mesh index\r\n    private _meshMap = new Map<AbstractMesh, number>();\r\n\r\n    public constructor(convertToRightHanded: boolean, wasAddedByNoopNode: boolean) {\r\n        this.convertToRightHanded = convertToRightHanded;\r\n        this.wasAddedByNoopNode = wasAddedByNoopNode;\r\n    }\r\n\r\n    public readonly convertToRightHanded: boolean;\r\n\r\n    public readonly wasAddedByNoopNode: boolean;\r\n\r\n    // Only used when convertToRightHanded is true.\r\n    public readonly convertedToRightHandedBuffers = new Map<Buffer, Uint8Array>();\r\n\r\n    public getIndicesAccessor(indices: Nullable<IndicesArray>, start: number, count: number, offset: number, flip: boolean): number | undefined {\r\n        return this._indicesAccessorMap.get(indices)?.get(start)?.get(count)?.get(offset)?.get(flip);\r\n    }\r\n\r\n    public setIndicesAccessor(indices: Nullable<IndicesArray>, start: number, count: number, offset: number, flip: boolean, accessorIndex: number): void {\r\n        let map1 = this._indicesAccessorMap.get(indices);\r\n        if (!map1) {\r\n            map1 = new Map<number, Map<number, Map<number, Map<boolean, number>>>>();\r\n            this._indicesAccessorMap.set(indices, map1);\r\n        }\r\n\r\n        let map2 = map1.get(start);\r\n        if (!map2) {\r\n            map2 = new Map<number, Map<number, Map<boolean, number>>>();\r\n            map1.set(start, map2);\r\n        }\r\n\r\n        let map3 = map2.get(count);\r\n        if (!map3) {\r\n            map3 = new Map<number, Map<boolean, number>>();\r\n            map2.set(count, map3);\r\n        }\r\n\r\n        let map4 = map3.get(offset);\r\n        if (!map4) {\r\n            map4 = new Map<boolean, number>();\r\n            map3.set(offset, map4);\r\n        }\r\n\r\n        map4.set(flip, accessorIndex);\r\n    }\r\n\r\n    public pushExportedNode(node: Node) {\r\n        if (!this._exportedNodes.has(node)) {\r\n            this._exportedNodes.add(node);\r\n        }\r\n    }\r\n\r\n    public getNodesSet(): Set<Node> {\r\n        return this._exportedNodes;\r\n    }\r\n\r\n    public getVertexBufferView(buffer: Buffer): IBufferView | undefined {\r\n        return this._vertexBufferViewMap.get(buffer);\r\n    }\r\n\r\n    public setVertexBufferView(buffer: Buffer, bufferView: IBufferView): void {\r\n        this._vertexBufferViewMap.set(buffer, bufferView);\r\n    }\r\n\r\n    public setRemappedBufferView(buffer: Buffer, vertexBuffer: VertexBuffer, bufferView: IBufferView) {\r\n        this._remappedBufferView.set(buffer, new Map<VertexBuffer, IBufferView>());\r\n        this._remappedBufferView.get(buffer)!.set(vertexBuffer, bufferView);\r\n    }\r\n\r\n    public getRemappedBufferView(buffer: Buffer, vertexBuffer: VertexBuffer): IBufferView | undefined {\r\n        return this._remappedBufferView.get(buffer)?.get(vertexBuffer);\r\n    }\r\n\r\n    public getVertexAccessor(vertexBuffer: VertexBuffer, start: number, count: number): number | undefined {\r\n        return this._vertexAccessorMap.get(vertexBuffer)?.get(start)?.get(count);\r\n    }\r\n\r\n    public setVertexAccessor(vertexBuffer: VertexBuffer, start: number, count: number, accessorIndex: number): void {\r\n        let map1 = this._vertexAccessorMap.get(vertexBuffer);\r\n        if (!map1) {\r\n            map1 = new Map<number, Map<number, number>>();\r\n            this._vertexAccessorMap.set(vertexBuffer, map1);\r\n        }\r\n\r\n        let map2 = map1.get(start);\r\n        if (!map2) {\r\n            map2 = new Map<number, number>();\r\n            map1.set(start, map2);\r\n        }\r\n\r\n        map2.set(count, accessorIndex);\r\n    }\r\n\r\n    public hasVertexColorAlpha(vertexBuffer: VertexBuffer): boolean {\r\n        return this._vertexMapColorAlpha.get(vertexBuffer) || false;\r\n    }\r\n\r\n    public setHasVertexColorAlpha(vertexBuffer: VertexBuffer, hasAlpha: boolean) {\r\n        return this._vertexMapColorAlpha.set(vertexBuffer, hasAlpha);\r\n    }\r\n\r\n    public getMesh(mesh: AbstractMesh): number | undefined {\r\n        return this._meshMap.get(mesh);\r\n    }\r\n\r\n    public setMesh(mesh: AbstractMesh, meshIndex: number): void {\r\n        this._meshMap.set(mesh, meshIndex);\r\n    }\r\n\r\n    public bindMorphDataToMesh(mesh: AbstractMesh, morphData: IMorphTargetData) {\r\n        const morphTargets = this._meshMorphTargetMap.get(mesh) || [];\r\n        this._meshMorphTargetMap.set(mesh, morphTargets);\r\n        if (morphTargets.indexOf(morphData) === -1) {\r\n            morphTargets.push(morphData);\r\n        }\r\n    }\r\n\r\n    public getMorphTargetsFromMesh(mesh: AbstractMesh): IMorphTargetData[] | undefined {\r\n        return this._meshMorphTargetMap.get(mesh);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class GLTFExporter {\r\n    public readonly _glTF: IGLTF = {\r\n        asset: { generator: `Babylon.js v${Engine.Version}`, version: \"2.0\" },\r\n    };\r\n\r\n    public readonly _animations: IAnimation[] = [];\r\n    public readonly _accessors: IAccessor[] = [];\r\n    public readonly _bufferViews: IBufferView[] = [];\r\n    public readonly _cameras: ICamera[] = [];\r\n    public readonly _images: IImage[] = [];\r\n    public readonly _materials: IMaterial[] = [];\r\n    public readonly _meshes: IMesh[] = [];\r\n    public readonly _nodes: INode[] = [];\r\n    public readonly _samplers: ISampler[] = [];\r\n    public readonly _scenes: IScene[] = [];\r\n    public readonly _skins: ISkin[] = [];\r\n    public readonly _textures: ITexture[] = [];\r\n\r\n    public readonly _babylonScene: Scene;\r\n    public readonly _imageData: { [fileName: string]: { data: ArrayBuffer; mimeType: ImageMimeType } } = {};\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    private readonly _options: Required<IExportOptions>;\r\n\r\n    public _shouldUseGlb: boolean = false;\r\n\r\n    public readonly _materialExporter = new GLTFMaterialExporter(this);\r\n\r\n    private readonly _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    public readonly _bufferManager = new BufferManager();\r\n\r\n    private readonly _shouldExportNodeMap = new Map<Node, boolean>();\r\n\r\n    // Babylon node -> glTF node index\r\n    private readonly _nodeMap = new Map<Node, number>();\r\n\r\n    // Babylon material -> glTF material index\r\n    public readonly _materialMap = new Map<Material, number>();\r\n    private readonly _camerasMap = new Map<Camera, ICamera>();\r\n    private readonly _nodesCameraMap = new Map<ICamera, INode[]>();\r\n    private readonly _skinMap = new Map<Skeleton, ISkin>();\r\n    private readonly _nodesSkinMap = new Map<ISkin, INode[]>();\r\n\r\n    // A material in this set requires UVs\r\n    public readonly _materialNeedsUVsSet = new Set<Material>();\r\n\r\n    private static readonly _ExtensionNames = new Array<string>();\r\n    private static readonly _ExtensionFactories: { [name: string]: (exporter: GLTFExporter) => IGLTFExporterExtensionV2 } = {};\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    private _ApplyExtension<T>(\r\n        node: T,\r\n        extensions: IGLTFExporterExtensionV2[],\r\n        index: number,\r\n        actionAsync: (extension: IGLTFExporterExtensionV2, node: T) => Promise<Nullable<T>> | undefined\r\n    ): Promise<Nullable<T>> {\r\n        if (index >= extensions.length) {\r\n            return Promise.resolve(node);\r\n        }\r\n\r\n        const currentPromise = actionAsync(extensions[index], node);\r\n\r\n        if (!currentPromise) {\r\n            return this._ApplyExtension(node, extensions, index + 1, actionAsync);\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return currentPromise.then(async (newNode) => (newNode ? await this._ApplyExtension(newNode, extensions, index + 1, actionAsync) : null));\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    private _ApplyExtensions<T>(node: T, actionAsync: (extension: IGLTFExporterExtensionV2, node: T) => Promise<Nullable<T>> | undefined): Promise<Nullable<T>> {\r\n        const extensions: IGLTFExporterExtensionV2[] = [];\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            extensions.push(this._extensions[name]);\r\n        }\r\n\r\n        return this._ApplyExtension(node, extensions, 0, actionAsync);\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public _extensionsPostExportNodeAsync(context: string, node: INode, babylonNode: Node, nodeMap: Map<Node, number>, convertToRightHanded: boolean): Promise<Nullable<INode>> {\r\n        return this._ApplyExtensions(\r\n            node,\r\n            // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n            (extension, node) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node, babylonNode, nodeMap, convertToRightHanded, this._bufferManager)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public _extensionsPostExportMaterialAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<Nullable<IMaterial>> {\r\n        // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n        return this._ApplyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));\r\n    }\r\n\r\n    public _extensionsPostExportMaterialAdditionalTextures(context: string, material: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const output: BaseTexture[] = [];\r\n\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportMaterialAdditionalTextures) {\r\n                output.push(...extension.postExportMaterialAdditionalTextures(context, material, babylonMaterial));\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    public _extensionsPostExportTextures(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportTexture) {\r\n                extension.postExportTexture(context, textureInfo, babylonTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitive(primitive: IMeshPrimitive): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportMeshPrimitive) {\r\n                extension.postExportMeshPrimitive(primitive, this._bufferManager, this._accessors);\r\n            }\r\n        }\r\n    }\r\n\r\n    public async _extensionsPreGenerateBinaryAsync(): Promise<void> {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.preGenerateBinaryAsync) {\r\n                // eslint-disable-next-line no-await-in-loop\r\n                await extension.preGenerateBinaryAsync(this._bufferManager);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFExporterExtensionV2) => void): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _extensionsOnExporting(): void {\r\n        this._forEachExtensions((extension) => {\r\n            if (extension.wasUsed) {\r\n                this._glTF.extensionsUsed ||= [];\r\n                if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {\r\n                    this._glTF.extensionsUsed.push(extension.name);\r\n                }\r\n\r\n                if (extension.required) {\r\n                    this._glTF.extensionsRequired ||= [];\r\n                    if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {\r\n                        this._glTF.extensionsRequired.push(extension.name);\r\n                    }\r\n                }\r\n\r\n                this._glTF.extensions ||= {};\r\n                if (extension.onExporting) {\r\n                    extension.onExporting();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadExtensions(): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = GLTFExporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    public constructor(babylonScene: Nullable<Scene> = EngineStore.LastCreatedScene, options?: IExportOptions) {\r\n        if (!babylonScene) {\r\n            throw new Error(\"No scene available to export\");\r\n        }\r\n\r\n        this._babylonScene = babylonScene;\r\n\r\n        this._options = {\r\n            shouldExportNode: () => true,\r\n            shouldExportAnimation: () => true,\r\n            metadataSelector: (metadata) => metadata?.gltf?.extras,\r\n            animationSampleRate: 1 / 60,\r\n            exportWithoutWaitingForScene: false,\r\n            exportUnusedUVs: false,\r\n            removeNoopRootNodes: true,\r\n            includeCoordinateSystemConversionNodes: false,\r\n            meshCompressionMethod: \"None\",\r\n            ...options,\r\n        };\r\n\r\n        this._loadExtensions();\r\n    }\r\n\r\n    public dispose() {\r\n        for (const key in this._extensions) {\r\n            const extension = this._extensions[key];\r\n            extension.dispose();\r\n        }\r\n    }\r\n\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public static RegisterExtension(name: string, factory: (exporter: GLTFExporter) => IGLTFExporterExtensionV2): void {\r\n        if (GLTFExporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        GLTFExporter._ExtensionFactories[name] = factory;\r\n        GLTFExporter._ExtensionNames.push(name);\r\n    }\r\n\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!GLTFExporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete GLTFExporter._ExtensionFactories[name];\r\n\r\n        const index = GLTFExporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            GLTFExporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _generateJSON(bufferByteLength: number, fileName?: string, prettyPrint?: boolean): string {\r\n        const buffer: IBuffer = { byteLength: bufferByteLength };\r\n\r\n        if (buffer.byteLength) {\r\n            this._glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            this._glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            this._glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            this._glTF.scenes = this._scenes;\r\n            this._glTF.scene = 0;\r\n        }\r\n        if (this._cameras && this._cameras.length) {\r\n            this._glTF.cameras = this._cameras;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            this._glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            this._glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            this._glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            this._glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            this._glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            this._glTF.samplers = this._samplers;\r\n        }\r\n        if (this._skins && this._skins.length) {\r\n            this._glTF.skins = this._skins;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            this._glTF.images = this._images;\r\n        }\r\n\r\n        if (!this._shouldUseGlb) {\r\n            buffer.uri = fileName + \".bin\";\r\n        }\r\n\r\n        return prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);\r\n    }\r\n\r\n    public async generateGLTFAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        const binaryBuffer = await this._generateBinaryAsync();\r\n        this._extensionsOnExporting();\r\n        const jsonText = this._generateJSON(binaryBuffer.byteLength, glTFPrefix, true);\r\n\r\n        const bin = new Blob([binaryBuffer], { type: \"application/octet-stream\" });\r\n\r\n        const glTFFileName = glTFPrefix + \".gltf\";\r\n        const glTFBinFile = glTFPrefix + \".bin\";\r\n\r\n        const container = new GLTFData();\r\n\r\n        container.files[glTFFileName] = jsonText;\r\n        container.files[glTFBinFile] = bin;\r\n\r\n        if (this._imageData) {\r\n            for (const image in this._imageData) {\r\n                container.files[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n            }\r\n        }\r\n\r\n        return container;\r\n    }\r\n\r\n    private async _generateBinaryAsync(): Promise<Uint8Array> {\r\n        await this._exportSceneAsync();\r\n        await this._extensionsPreGenerateBinaryAsync();\r\n        return this._bufferManager.generateBinary(this._bufferViews);\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        const remainder = num % 4;\r\n        const padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    public async generateGLBAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        this._shouldUseGlb = true;\r\n        const binaryBuffer = await this._generateBinaryAsync();\r\n        this._extensionsOnExporting();\r\n        const jsonText = this._generateJSON(binaryBuffer.byteLength);\r\n\r\n        const glbFileName = glTFPrefix + \".glb\";\r\n        const headerLength = 12;\r\n        const chunkLengthPrefix = 8;\r\n        let jsonLength = jsonText.length;\r\n        let encodedJsonText;\r\n        // Make use of TextEncoder when available\r\n        if (typeof TextEncoder !== \"undefined\") {\r\n            const encoder = new TextEncoder();\r\n            encodedJsonText = encoder.encode(jsonText);\r\n            jsonLength = encodedJsonText.length;\r\n        }\r\n        const jsonPadding = this._getPadding(jsonLength);\r\n        const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n\r\n        const byteLength = headerLength + 2 * chunkLengthPrefix + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding;\r\n\r\n        const dataWriter = new DataWriter(byteLength);\r\n\r\n        // Header\r\n        dataWriter.writeUInt32(0x46546c67); // \"glTF\"\r\n        dataWriter.writeUInt32(2); // Version\r\n        dataWriter.writeUInt32(byteLength); // Total bytes in file\r\n\r\n        // JSON chunk length prefix\r\n        dataWriter.writeUInt32(jsonLength + jsonPadding);\r\n        dataWriter.writeUInt32(0x4e4f534a); // \"JSON\"\r\n\r\n        // JSON chunk bytes\r\n        if (encodedJsonText) {\r\n            // If TextEncoder was available, we can simply copy the encoded array\r\n            dataWriter.writeTypedArray(encodedJsonText);\r\n        } else {\r\n            const blankCharCode = \"_\".charCodeAt(0);\r\n            for (let i = 0; i < jsonLength; ++i) {\r\n                const charCode = jsonText.charCodeAt(i);\r\n                // If the character doesn't fit into a single UTF-16 code unit, just put a blank character\r\n                if (charCode != jsonText.codePointAt(i)) {\r\n                    dataWriter.writeUInt8(blankCharCode);\r\n                } else {\r\n                    dataWriter.writeUInt8(charCode);\r\n                }\r\n            }\r\n        }\r\n\r\n        // JSON padding\r\n        for (let i = 0; i < jsonPadding; ++i) {\r\n            dataWriter.writeUInt8(0x20);\r\n        }\r\n\r\n        // Binary chunk length prefix\r\n        dataWriter.writeUInt32(binaryBuffer.byteLength + binPadding);\r\n        dataWriter.writeUInt32(0x004e4942); // \"BIN\"\r\n\r\n        // Binary chunk bytes\r\n        dataWriter.writeTypedArray(binaryBuffer);\r\n\r\n        // Binary padding\r\n        for (let i = 0; i < binPadding; ++i) {\r\n            dataWriter.writeUInt8(0);\r\n        }\r\n\r\n        const container = new GLTFData();\r\n        container.files[glbFileName] = new Blob([dataWriter.getOutputData()], { type: \"application/octet-stream\" });\r\n\r\n        return container;\r\n    }\r\n\r\n    private _setNodeTransformation(node: INode, babylonTransformNode: TransformNode, convertToRightHanded: boolean): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n\r\n        if (!babylonTransformNode.position.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            const translation = TmpVectors.Vector3[0].copyFrom(babylonTransformNode.position);\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedPosition(translation);\r\n            }\r\n\r\n            node.translation = translation.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsWithEpsilon(DefaultScale, Epsilon)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        const rotationQuaternion =\r\n            babylonTransformNode.rotationQuaternion?.clone() ||\r\n            Quaternion.FromEulerAngles(babylonTransformNode.rotation.x, babylonTransformNode.rotation.y, babylonTransformNode.rotation.z);\r\n\r\n        if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedRotation(rotationQuaternion);\r\n            }\r\n\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private _setCameraTransformation(node: INode, babylonCamera: TargetCamera, convertToRightHanded: boolean): void {\r\n        if (!babylonCamera.position.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            const translation = TmpVectors.Vector3[0].copyFrom(babylonCamera.position);\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedPosition(translation);\r\n            }\r\n            node.translation = translation.asArray();\r\n        }\r\n\r\n        const rotationQuaternion = babylonCamera.rotationQuaternion || Quaternion.FromEulerAngles(babylonCamera.rotation.x, babylonCamera.rotation.y, babylonCamera.rotation.z);\r\n\r\n        if (convertToRightHanded) {\r\n            ConvertToRightHandedRotation(rotationQuaternion);\r\n        }\r\n\r\n        // Left-handed scenes have cameras that always face Z+ (opposite of glTF's Z-).\r\n        // Use scene coordinate system rather than convertToRightHanded, since some\r\n        // cameras may not need convertToRightHanded but still need correction to face Z-.\r\n        if (!this._babylonScene.useRightHandedSystem) {\r\n            Rotate180Y(rotationQuaternion);\r\n        }\r\n\r\n        if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n            node.rotation = rotationQuaternion.asArray();\r\n        }\r\n    }\r\n\r\n    // Export babylon cameras to glTF cameras\r\n    private _listAvailableCameras(): void {\r\n        for (const camera of this._babylonScene.cameras) {\r\n            const glTFCamera: ICamera = {\r\n                type: camera.mode === Camera.PERSPECTIVE_CAMERA ? CameraType.PERSPECTIVE : CameraType.ORTHOGRAPHIC,\r\n            };\r\n\r\n            if (camera.name) {\r\n                glTFCamera.name = camera.name;\r\n            }\r\n\r\n            if (glTFCamera.type === CameraType.PERSPECTIVE) {\r\n                glTFCamera.perspective = {\r\n                    aspectRatio: camera.getEngine().getAspectRatio(camera),\r\n                    yfov: camera.fovMode === Camera.FOVMODE_VERTICAL_FIXED ? camera.fov : camera.fov * camera.getEngine().getAspectRatio(camera),\r\n                    znear: camera.minZ,\r\n                    zfar: camera.maxZ,\r\n                };\r\n            } else if (glTFCamera.type === CameraType.ORTHOGRAPHIC) {\r\n                const halfWidth = camera.orthoLeft && camera.orthoRight ? 0.5 * (camera.orthoRight - camera.orthoLeft) : camera.getEngine().getRenderWidth() * 0.5;\r\n                const halfHeight = camera.orthoBottom && camera.orthoTop ? 0.5 * (camera.orthoTop - camera.orthoBottom) : camera.getEngine().getRenderHeight() * 0.5;\r\n                glTFCamera.orthographic = {\r\n                    xmag: halfWidth,\r\n                    ymag: halfHeight,\r\n                    znear: camera.minZ,\r\n                    zfar: camera.maxZ,\r\n                };\r\n            }\r\n            this._camerasMap.set(camera, glTFCamera);\r\n        }\r\n    }\r\n\r\n    // Cleanup unused cameras and assign index to nodes.\r\n    private _exportAndAssignCameras(): void {\r\n        const gltfCameras = Array.from(this._camerasMap.values());\r\n        for (const gltfCamera of gltfCameras) {\r\n            const usedNodes = this._nodesCameraMap.get(gltfCamera);\r\n            if (usedNodes !== undefined) {\r\n                this._cameras.push(gltfCamera);\r\n                for (const node of usedNodes) {\r\n                    node.camera = this._cameras.length - 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Collects all skins in a skins map so nodes can reference it during node parsing.\r\n    private _listAvailableSkeletons(): void {\r\n        for (const skeleton of this._babylonScene.skeletons) {\r\n            if (skeleton.bones.length <= 0) {\r\n                continue;\r\n            }\r\n\r\n            const skin: ISkin = { joints: [] };\r\n            this._skinMap.set(skeleton, skin);\r\n        }\r\n    }\r\n\r\n    private _exportAndAssignSkeletons(leftHandNodes: Set<Node>): void {\r\n        for (const skeleton of this._babylonScene.skeletons) {\r\n            if (skeleton.bones.length <= 0) {\r\n                continue;\r\n            }\r\n\r\n            const skin = this._skinMap.get(skeleton);\r\n            if (skin == undefined) {\r\n                continue;\r\n            }\r\n\r\n            // The bones (joints) of a skeleton (skin) must be exported in the same order as they appear in vertex attributes,\r\n            // which is indicated by getIndex and may not match a bone's index in skeleton.bones\r\n            const boneIndexMap: { [index: number]: Bone } = {};\r\n            let maxBoneIndex = -1;\r\n            for (let i = 0; i < skeleton.bones.length; ++i) {\r\n                const bone = skeleton.bones[i];\r\n                const boneIndex = bone.getIndex() ?? i;\r\n                if (boneIndex !== -1) {\r\n                    boneIndexMap[boneIndex] = bone;\r\n                    if (boneIndex > maxBoneIndex) {\r\n                        maxBoneIndex = boneIndex;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Set joints indices to scene nodes.\r\n            const inverseBindMatrices: Matrix[] = [];\r\n            for (let boneIndex = 0; boneIndex <= maxBoneIndex; ++boneIndex) {\r\n                const bone = boneIndexMap[boneIndex]; // Assumes no gaps in bone indices\r\n                const transformNode = bone.getTransformNode();\r\n                const nodeIndex = transformNode ? this._nodeMap.get(transformNode) : undefined;\r\n                if (nodeIndex === undefined) {\r\n                    Tools.Warn(\"Exporting a bone without a linked transform node is currently unsupported.\");\r\n                    continue; // The indices may be out-of-sync after this and break the skinning.\r\n                }\r\n                skin.joints.push(nodeIndex);\r\n\r\n                const boneMatrix = bone.getAbsoluteInverseBindMatrix().clone();\r\n                if (leftHandNodes.has(transformNode!)) {\r\n                    ConvertToRightHandedTransformMatrix(boneMatrix);\r\n                }\r\n                inverseBindMatrices.push(boneMatrix);\r\n            }\r\n\r\n            // Nodes that use this skin.\r\n            const skinnedNodes = this._nodesSkinMap.get(skin);\r\n\r\n            // Only export the skin if it has at least one joint and is used by a mesh.\r\n            if (skin.joints.length > 0 && skinnedNodes !== undefined) {\r\n                const inverseBindMatricesData = new Float32Array(inverseBindMatrices.length * 16); // Always a 4 x 4 matrix of 32 bit float\r\n                inverseBindMatrices.forEach((mat: Matrix, index: number) => {\r\n                    inverseBindMatricesData.set(mat.m, index * 16);\r\n                });\r\n\r\n                const bufferView = this._bufferManager.createBufferView(inverseBindMatricesData);\r\n                this._accessors.push(this._bufferManager.createAccessor(bufferView, AccessorType.MAT4, AccessorComponentType.FLOAT, inverseBindMatrices.length));\r\n                skin.inverseBindMatrices = this._accessors.length - 1;\r\n\r\n                this._skins.push(skin);\r\n                const skinIndex = this._skins.length - 1;\r\n                for (const skinnedNode of skinnedNodes) {\r\n                    skinnedNode.skin = skinIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _exportSceneAsync(): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n\r\n        // Scene metadata\r\n        if (this._babylonScene.metadata) {\r\n            const extras = this._options.metadataSelector(this._babylonScene.metadata);\r\n            if (extras) {\r\n                scene.extras = extras;\r\n            }\r\n        }\r\n\r\n        //  TODO:\r\n        //  deal with this from the loader:\r\n        //  babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\r\n        //  babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\r\n\r\n        const rootNodesRH = new Array<Node>();\r\n        const rootNodesLH = new Array<Node>();\r\n        const rootNoopNodesRH = new Array<Node>();\r\n\r\n        for (const rootNode of this._babylonScene.rootNodes) {\r\n            if (this._options.removeNoopRootNodes && !this._options.includeCoordinateSystemConversionNodes && IsNoopNode(rootNode, this._babylonScene.useRightHandedSystem)) {\r\n                rootNoopNodesRH.push(...rootNode.getChildren());\r\n            } else if (this._babylonScene.useRightHandedSystem) {\r\n                rootNodesRH.push(rootNode);\r\n            } else {\r\n                rootNodesLH.push(rootNode);\r\n            }\r\n        }\r\n\r\n        this._listAvailableCameras();\r\n        this._listAvailableSkeletons();\r\n\r\n        const stateLH = new ExporterState(true, false);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNodesLH, stateLH)));\r\n        const stateRH = new ExporterState(false, false);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNodesRH, stateRH)));\r\n        const noopRH = new ExporterState(false, true);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNoopNodesRH, noopRH)));\r\n\r\n        if (scene.nodes.length) {\r\n            this._scenes.push(scene);\r\n        }\r\n\r\n        this._exportAndAssignCameras();\r\n        this._exportAndAssignSkeletons(stateLH.getNodesSet());\r\n\r\n        if (this._babylonScene.animationGroups.length) {\r\n            _GLTFAnimation._CreateNodeAndMorphAnimationFromAnimationGroups(\r\n                this._babylonScene,\r\n                this._animations,\r\n                this._nodeMap,\r\n                this._bufferManager,\r\n                this._bufferViews,\r\n                this._accessors,\r\n                this._animationSampleRate,\r\n                stateLH.getNodesSet(),\r\n                this._options.shouldExportAnimation\r\n            );\r\n        }\r\n    }\r\n\r\n    private _shouldExportNode(babylonNode: Node): boolean {\r\n        let result = this._shouldExportNodeMap.get(babylonNode);\r\n\r\n        if (result === undefined) {\r\n            result = this._options.shouldExportNode(babylonNode);\r\n            this._shouldExportNodeMap.set(babylonNode, result);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private async _exportNodesAsync(babylonRootNodes: Node[], state: ExporterState): Promise<number[]> {\r\n        const nodes = new Array<number>();\r\n\r\n        this._exportBuffers(babylonRootNodes, state);\r\n\r\n        for (const babylonNode of babylonRootNodes) {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            await this._exportNodeAsync(babylonNode, nodes, state);\r\n        }\r\n\r\n        return nodes;\r\n    }\r\n\r\n    private _collectBuffers(\r\n        babylonNode: Node,\r\n        bufferToVertexBuffersMap: Map<Buffer, VertexBuffer[]>,\r\n        vertexBufferToMeshesMap: Map<VertexBuffer, AbstractMesh[]>,\r\n        morphTargetsToMeshesMap: Map<MorphTarget, AbstractMesh[]>,\r\n        state: ExporterState\r\n    ): void {\r\n        if (this._shouldExportNode(babylonNode) && babylonNode instanceof AbstractMesh && babylonNode.geometry) {\r\n            const vertexBuffers = babylonNode.geometry.getVertexBuffers();\r\n            if (vertexBuffers) {\r\n                for (const kind in vertexBuffers) {\r\n                    if (!IsStandardVertexAttribute(kind)) {\r\n                        continue;\r\n                    }\r\n                    const vertexBuffer = vertexBuffers[kind];\r\n                    state.setHasVertexColorAlpha(vertexBuffer, babylonNode.hasVertexAlpha);\r\n                    const buffer = vertexBuffer._buffer;\r\n                    const vertexBufferArray = bufferToVertexBuffersMap.get(buffer) || [];\r\n                    bufferToVertexBuffersMap.set(buffer, vertexBufferArray);\r\n                    if (vertexBufferArray.indexOf(vertexBuffer) === -1) {\r\n                        vertexBufferArray.push(vertexBuffer);\r\n                    }\r\n\r\n                    const meshes = vertexBufferToMeshesMap.get(vertexBuffer) || [];\r\n                    vertexBufferToMeshesMap.set(vertexBuffer, meshes);\r\n                    if (meshes.indexOf(babylonNode) === -1) {\r\n                        meshes.push(babylonNode);\r\n                    }\r\n                }\r\n            }\r\n\r\n            const morphTargetManager = babylonNode.morphTargetManager;\r\n\r\n            if (morphTargetManager) {\r\n                for (let morphIndex = 0; morphIndex < morphTargetManager.numTargets; morphIndex++) {\r\n                    const morphTarget = morphTargetManager.getTarget(morphIndex);\r\n\r\n                    const meshes = morphTargetsToMeshesMap.get(morphTarget) || [];\r\n                    morphTargetsToMeshesMap.set(morphTarget, meshes);\r\n                    if (meshes.indexOf(babylonNode) === -1) {\r\n                        meshes.push(babylonNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const babylonChildNode of babylonNode.getChildren()) {\r\n            this._collectBuffers(babylonChildNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsToMeshesMap, state);\r\n        }\r\n    }\r\n\r\n    private _exportBuffers(babylonRootNodes: Node[], state: ExporterState): void {\r\n        const bufferToVertexBuffersMap = new Map<Buffer, VertexBuffer[]>();\r\n        const vertexBufferToMeshesMap = new Map<VertexBuffer, AbstractMesh[]>();\r\n        const morphTargetsMeshesMap = new Map<MorphTarget, AbstractMesh[]>();\r\n\r\n        for (const babylonNode of babylonRootNodes) {\r\n            this._collectBuffers(babylonNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsMeshesMap, state);\r\n        }\r\n\r\n        const buffers = Array.from(bufferToVertexBuffersMap.keys());\r\n\r\n        for (const buffer of buffers) {\r\n            const data = buffer.getData();\r\n            if (!data) {\r\n                throw new Error(\"Buffer data is not available\");\r\n            }\r\n\r\n            const vertexBuffers = bufferToVertexBuffersMap.get(buffer);\r\n\r\n            if (!vertexBuffers) {\r\n                continue;\r\n            }\r\n\r\n            const byteStride = vertexBuffers[0].byteStride;\r\n            if (vertexBuffers.some((vertexBuffer) => vertexBuffer.byteStride !== byteStride)) {\r\n                throw new Error(\"Vertex buffers pointing to the same buffer must have the same byte stride\");\r\n            }\r\n\r\n            const bytes = DataArrayToUint8Array(data).slice();\r\n\r\n            // Apply normalizations and color corrections to buffer data in-place.\r\n            for (const vertexBuffer of vertexBuffers) {\r\n                const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                const { byteOffset, byteStride, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n\r\n                switch (kind) {\r\n                    // Normalize normals and tangents.\r\n                    case VertexBuffer.NormalKind:\r\n                    case VertexBuffer.TangentKind: {\r\n                        EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                            const length = Math.sqrt(values[0] * values[0] + values[1] * values[1] + values[2] * values[2]);\r\n                            if (length > 0) {\r\n                                const invLength = 1 / length;\r\n                                values[0] *= invLength;\r\n                                values[1] *= invLength;\r\n                                values[2] *= invLength;\r\n                            }\r\n                        });\r\n                        break;\r\n                    }\r\n                    // Convert StandardMaterial vertex colors from gamma to linear space.\r\n                    case VertexBuffer.ColorKind: {\r\n                        const stdMaterialCount = meshes.filter((mesh) => mesh.material instanceof StandardMaterial || mesh.material == null).length;\r\n                        if (stdMaterialCount == 0) {\r\n                            break; // Buffer not used by StandardMaterials, so no conversion needed.\r\n                        }\r\n                        // TODO: Implement this case.\r\n                        if (stdMaterialCount != meshes.length) {\r\n                            Logger.Warn(\"Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.\");\r\n                            break;\r\n                        }\r\n                        if (type == VertexBuffer.UNSIGNED_BYTE) {\r\n                            Logger.Warn(\"Converting uint8 vertex colors to linear space. Results may look incorrect.\");\r\n                        }\r\n\r\n                        const vertexData3 = new Color3();\r\n                        const vertexData4 = new Color4();\r\n                        const useExactSrgbConversions = this._babylonScene.getEngine().useExactSrgbConversions;\r\n\r\n                        EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                            // Using separate Color3 and Color4 objects to ensure the right functions are called.\r\n                            if (values.length === 3) {\r\n                                vertexData3.fromArray(values, 0);\r\n                                vertexData3.toLinearSpaceToRef(vertexData3, useExactSrgbConversions);\r\n                                vertexData3.toArray(values, 0);\r\n                            } else {\r\n                                vertexData4.fromArray(values, 0);\r\n                                vertexData4.toLinearSpaceToRef(vertexData4, useExactSrgbConversions);\r\n                                vertexData4.toArray(values, 0);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Perform coordinate conversions, if needed, to buffer data in-place (only for positions, normals and tangents).\r\n            if (state.convertToRightHanded) {\r\n                for (const vertexBuffer of vertexBuffers) {\r\n                    const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                    const { byteOffset, byteStride, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n\r\n                    switch (kind) {\r\n                        case VertexBuffer.PositionKind:\r\n                        case VertexBuffer.NormalKind:\r\n                        case VertexBuffer.TangentKind: {\r\n                            EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                                values[0] = -values[0];\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Save converted bytes for min/max computation.\r\n                state.convertedToRightHandedBuffers.set(buffer, bytes);\r\n            }\r\n\r\n            // Create buffer view, but defer accessor creation for later. Instead, track it via ExporterState.\r\n            const bufferView = this._bufferManager.createBufferView(bytes, byteStride);\r\n            state.setVertexBufferView(buffer, bufferView);\r\n\r\n            const floatMatricesIndices = new Map<VertexBuffer, FloatArray>();\r\n\r\n            // If buffers are of type MatricesIndicesKind and have float values, we need to create a new buffer instead.\r\n            for (const vertexBuffer of vertexBuffers) {\r\n                const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                const { kind, totalVertices } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n                switch (kind) {\r\n                    case VertexBuffer.MatricesIndicesKind:\r\n                    case VertexBuffer.MatricesIndicesExtraKind: {\r\n                        if (vertexBuffer.type == VertexBuffer.FLOAT) {\r\n                            const floatData = vertexBuffer.getFloatData(totalVertices);\r\n                            if (floatData !== null) {\r\n                                floatMatricesIndices.set(vertexBuffer, floatData);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (floatMatricesIndices.size !== 0) {\r\n                Logger.Warn(\r\n                    `Joint indices conversion needed: some joint indices are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.`\r\n                );\r\n            }\r\n\r\n            const floatArrayVertexBuffers = Array.from(floatMatricesIndices.keys());\r\n\r\n            for (const vertexBuffer of floatArrayVertexBuffers) {\r\n                const array = floatMatricesIndices.get(vertexBuffer);\r\n\r\n                if (!array) {\r\n                    continue;\r\n                }\r\n\r\n                const is16Bit = FloatsNeed16BitInteger(array);\r\n                const newArray = new (is16Bit ? Uint16Array : Uint8Array)(array.length);\r\n                for (let index = 0; index < array.length; index++) {\r\n                    newArray[index] = array[index];\r\n                }\r\n                const bufferView = this._bufferManager.createBufferView(newArray, 4 * (is16Bit ? 2 : 1));\r\n                state.setRemappedBufferView(buffer, vertexBuffer, bufferView);\r\n            }\r\n        }\r\n\r\n        // Build morph targets buffers\r\n        const morphTargets = Array.from(morphTargetsMeshesMap.keys());\r\n\r\n        for (const morphTarget of morphTargets) {\r\n            const meshes = morphTargetsMeshesMap.get(morphTarget);\r\n\r\n            if (!meshes) {\r\n                continue;\r\n            }\r\n\r\n            const glTFMorphTarget = BuildMorphTargetBuffers(morphTarget, meshes[0], this._bufferManager, this._bufferViews, this._accessors, state.convertToRightHanded);\r\n\r\n            for (const mesh of meshes) {\r\n                state.bindMorphDataToMesh(mesh, glTFMorphTarget);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes a node to be exported to the glTF file\r\n     * @returns A promise that resolves once the node has been exported\r\n     * @internal\r\n     */\r\n    private async _exportNodeAsync(babylonNode: Node, parentNodeChildren: Array<number>, state: ExporterState): Promise<void> {\r\n        let nodeIndex = this._nodeMap.get(babylonNode);\r\n        if (nodeIndex !== undefined) {\r\n            if (!parentNodeChildren.includes(nodeIndex)) {\r\n                parentNodeChildren.push(nodeIndex);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const node = await this._createNodeAsync(babylonNode, state);\r\n\r\n        if (node) {\r\n            nodeIndex = this._nodes.length;\r\n            this._nodes.push(node);\r\n            this._nodeMap.set(babylonNode, nodeIndex);\r\n            state.pushExportedNode(babylonNode);\r\n            parentNodeChildren.push(nodeIndex);\r\n\r\n            // Process node's animations once the node has been added to nodeMap (TODO: This should be refactored)\r\n            const runtimeGLTFAnimation: IAnimation = {\r\n                name: \"runtime animations\",\r\n                channels: [],\r\n                samplers: [],\r\n            };\r\n            const idleGLTFAnimations: IAnimation[] = [];\r\n\r\n            if (!this._babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateMorphTargetAnimationFromMorphTargetAnimations(\r\n                    babylonNode,\r\n                    runtimeGLTFAnimation,\r\n                    idleGLTFAnimations,\r\n                    this._nodeMap,\r\n                    this._nodes,\r\n                    this._bufferManager,\r\n                    this._bufferViews,\r\n                    this._accessors,\r\n                    this._animationSampleRate,\r\n                    state.convertToRightHanded,\r\n                    this._options.shouldExportAnimation\r\n                );\r\n                if (babylonNode.animations.length) {\r\n                    _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(\r\n                        babylonNode,\r\n                        runtimeGLTFAnimation,\r\n                        idleGLTFAnimations,\r\n                        this._nodeMap,\r\n                        this._nodes,\r\n                        this._bufferManager,\r\n                        this._bufferViews,\r\n                        this._accessors,\r\n                        this._animationSampleRate,\r\n                        state.convertToRightHanded,\r\n                        this._options.shouldExportAnimation\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Begin processing child nodes once parent has been added to the node list\r\n        const children = node ? [] : parentNodeChildren;\r\n        for (const babylonChildNode of babylonNode.getChildren()) {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            await this._exportNodeAsync(babylonChildNode, children, state);\r\n        }\r\n\r\n        if (node && children.length) {\r\n            node.children = children;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon.js node. If skipped, returns null.\r\n     * @internal\r\n     */\r\n    private async _createNodeAsync(babylonNode: Node, state: ExporterState): Promise<Nullable<INode>> {\r\n        if (!this._shouldExportNode(babylonNode)) {\r\n            return null;\r\n        }\r\n\r\n        const node: INode = {};\r\n\r\n        if (babylonNode.name) {\r\n            node.name = babylonNode.name;\r\n        }\r\n\r\n        // Node metadata\r\n        if (babylonNode.metadata) {\r\n            const extras = this._options.metadataSelector(babylonNode.metadata);\r\n            if (extras) {\r\n                node.extras = extras;\r\n            }\r\n        }\r\n\r\n        if (babylonNode instanceof TransformNode) {\r\n            this._setNodeTransformation(node, babylonNode, state.convertToRightHanded);\r\n\r\n            if (babylonNode instanceof AbstractMesh) {\r\n                const babylonMesh = babylonNode instanceof InstancedMesh ? babylonNode.sourceMesh : (babylonNode as Mesh);\r\n                if (babylonMesh.subMeshes && babylonMesh.subMeshes.length > 0) {\r\n                    node.mesh = await this._exportMeshAsync(babylonMesh, state);\r\n                }\r\n\r\n                if (babylonNode.skeleton) {\r\n                    const skin = this._skinMap.get(babylonNode.skeleton);\r\n\r\n                    if (skin !== undefined) {\r\n                        if (this._nodesSkinMap.get(skin) === undefined) {\r\n                            this._nodesSkinMap.set(skin, []);\r\n                        }\r\n\r\n                        this._nodesSkinMap.get(skin)?.push(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (babylonNode instanceof TargetCamera) {\r\n            const gltfCamera = this._camerasMap.get(babylonNode);\r\n\r\n            if (gltfCamera) {\r\n                if (this._nodesCameraMap.get(gltfCamera) === undefined) {\r\n                    this._nodesCameraMap.set(gltfCamera, []);\r\n                }\r\n\r\n                this._setCameraTransformation(node, babylonNode, state.convertToRightHanded);\r\n\r\n                // If a parent node exists and can be collapsed, merge their transformations and mark the parent as the camera-containing node.\r\n                const parentBabylonNode = babylonNode.parent;\r\n                if (parentBabylonNode !== null && IsChildCollapsible(babylonNode, parentBabylonNode)) {\r\n                    const parentNodeIndex = this._nodeMap.get(parentBabylonNode);\r\n                    if (parentNodeIndex !== undefined) {\r\n                        const parentNode = this._nodes[parentNodeIndex];\r\n                        CollapseChildIntoParent(node, parentNode);\r\n                        this._nodesCameraMap.get(gltfCamera)?.push(parentNode);\r\n                        return null; // Skip exporting the original child node\r\n                    }\r\n                }\r\n\r\n                this._nodesCameraMap.get(gltfCamera)?.push(node);\r\n            }\r\n        }\r\n\r\n        // Apply extensions to the node. If this resolves to null, it means we should skip exporting this node\r\n        const processedNode = await this._extensionsPostExportNodeAsync(\"exportNodeAsync\", node, babylonNode, this._nodeMap, state.convertToRightHanded);\r\n        if (!processedNode) {\r\n            Logger.Warn(`Not exporting node ${babylonNode.name}`);\r\n            return null;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    private _exportIndices(\r\n        indices: Nullable<IndicesArray>,\r\n        is32Bits: boolean,\r\n        start: number,\r\n        count: number,\r\n        offset: number,\r\n        fillMode: number,\r\n        sideOrientation: number,\r\n        state: ExporterState,\r\n        primitive: IMeshPrimitive\r\n    ): void {\r\n        let indicesToExport = indices;\r\n\r\n        primitive.mode = GetPrimitiveMode(fillMode);\r\n\r\n        // Flip indices if triangle winding order is not CCW, as glTF is always CCW.\r\n        const flip = sideOrientation !== Material.CounterClockWiseSideOrientation && IsTriangleFillMode(fillMode);\r\n        if (flip) {\r\n            if (fillMode === Material.TriangleStripDrawMode || fillMode === Material.TriangleFanDrawMode) {\r\n                throw new Error(\"Triangle strip/fan fill mode is not implemented\");\r\n            }\r\n\r\n            primitive.mode = GetPrimitiveMode(fillMode);\r\n\r\n            const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);\r\n\r\n            if (indices) {\r\n                for (let i = 0; i + 2 < count; i += 3) {\r\n                    newIndices[i] = indices[start + i] + offset;\r\n                    newIndices[i + 1] = indices[start + i + 2] + offset;\r\n                    newIndices[i + 2] = indices[start + i + 1] + offset;\r\n                }\r\n            } else {\r\n                for (let i = 0; i + 2 < count; i += 3) {\r\n                    newIndices[i] = i;\r\n                    newIndices[i + 1] = i + 2;\r\n                    newIndices[i + 2] = i + 1;\r\n                }\r\n            }\r\n\r\n            indicesToExport = newIndices;\r\n        } else if (indices && offset !== 0) {\r\n            const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);\r\n            for (let i = 0; i < count; i++) {\r\n                newIndices[i] = indices[start + i] + offset;\r\n            }\r\n\r\n            indicesToExport = newIndices;\r\n        }\r\n\r\n        if (indicesToExport) {\r\n            let accessorIndex = state.getIndicesAccessor(indices, start, count, offset, flip);\r\n            if (accessorIndex === undefined) {\r\n                const bytes = IndicesArrayToTypedArray(indicesToExport, 0, count, is32Bits);\r\n                const bufferView = this._bufferManager.createBufferView(bytes);\r\n\r\n                const componentType = is32Bits ? AccessorComponentType.UNSIGNED_INT : AccessorComponentType.UNSIGNED_SHORT;\r\n                this._accessors.push(this._bufferManager.createAccessor(bufferView, AccessorType.SCALAR, componentType, count, 0));\r\n                accessorIndex = this._accessors.length - 1;\r\n                state.setIndicesAccessor(indices, start, count, offset, flip, accessorIndex);\r\n            }\r\n\r\n            primitive.indices = accessorIndex;\r\n        }\r\n    }\r\n\r\n    private _exportVertexBuffer(vertexBuffer: VertexBuffer, babylonMaterial: Material, start: number, count: number, state: ExporterState, primitive: IMeshPrimitive): void {\r\n        const kind = vertexBuffer.getKind();\r\n\r\n        if (!IsStandardVertexAttribute(kind)) {\r\n            return;\r\n        }\r\n\r\n        if (kind.startsWith(\"uv\") && !this._options.exportUnusedUVs) {\r\n            if (!babylonMaterial || !this._materialNeedsUVsSet.has(babylonMaterial)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        let accessorIndex = state.getVertexAccessor(vertexBuffer, start, count);\r\n\r\n        if (accessorIndex === undefined) {\r\n            // Get min/max from converted or original data.\r\n            const data = state.convertedToRightHandedBuffers.get(vertexBuffer._buffer) || vertexBuffer._buffer.getData()!;\r\n            const minMax = kind === VertexBuffer.PositionKind ? GetMinMax(data, vertexBuffer, start, count) : undefined;\r\n\r\n            // For the remapped buffer views we created for float matrices indices, make sure to use their updated information.\r\n            const isFloatMatricesIndices =\r\n                (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) && vertexBuffer.type === VertexBuffer.FLOAT;\r\n\r\n            const vertexBufferType = isFloatMatricesIndices ? VertexBuffer.UNSIGNED_BYTE : vertexBuffer.type;\r\n            const vertexBufferNormalized = isFloatMatricesIndices ? undefined : vertexBuffer.normalized;\r\n            const bufferView = isFloatMatricesIndices ? state.getRemappedBufferView(vertexBuffer._buffer, vertexBuffer)! : state.getVertexBufferView(vertexBuffer._buffer)!;\r\n\r\n            const byteOffset = vertexBuffer.byteOffset + start * vertexBuffer.byteStride;\r\n            this._accessors.push(\r\n                this._bufferManager.createAccessor(\r\n                    bufferView,\r\n                    GetAccessorType(kind, state.hasVertexColorAlpha(vertexBuffer)),\r\n                    vertexBufferType,\r\n                    count,\r\n                    byteOffset,\r\n                    minMax,\r\n                    vertexBufferNormalized // TODO: Find other places where this is needed.\r\n                )\r\n            );\r\n            accessorIndex = this._accessors.length - 1;\r\n            state.setVertexAccessor(vertexBuffer, start, count, accessorIndex);\r\n        }\r\n\r\n        primitive.attributes[GetAttributeType(kind)] = accessorIndex;\r\n    }\r\n\r\n    private async _exportMaterialAsync(babylonMaterial: Material, vertexBuffers: { [kind: string]: VertexBuffer }, subMesh: SubMesh, primitive: IMeshPrimitive): Promise<void> {\r\n        let materialIndex = this._materialMap.get(babylonMaterial);\r\n        if (materialIndex === undefined) {\r\n            const hasUVs = vertexBuffers && Object.keys(vertexBuffers).some((kind) => kind.startsWith(\"uv\"));\r\n            babylonMaterial = babylonMaterial instanceof MultiMaterial ? babylonMaterial.subMaterials[subMesh.materialIndex]! : babylonMaterial;\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                materialIndex = await this._materialExporter.exportPBRMaterialAsync(babylonMaterial, hasUVs);\r\n            } else if (babylonMaterial instanceof StandardMaterial) {\r\n                materialIndex = await this._materialExporter.exportStandardMaterialAsync(babylonMaterial, hasUVs);\r\n            } else {\r\n                Logger.Warn(`Unsupported material '${babylonMaterial.name}' with type ${babylonMaterial.getClassName()}`);\r\n                return;\r\n            }\r\n\r\n            this._materialMap.set(babylonMaterial, materialIndex);\r\n        }\r\n\r\n        primitive.material = materialIndex;\r\n    }\r\n\r\n    private async _exportMeshAsync(babylonMesh: Mesh, state: ExporterState): Promise<number> {\r\n        let meshIndex = state.getMesh(babylonMesh);\r\n        if (meshIndex !== undefined) {\r\n            return meshIndex;\r\n        }\r\n\r\n        const mesh: IMesh = { primitives: [] };\r\n        meshIndex = this._meshes.length;\r\n        this._meshes.push(mesh);\r\n        state.setMesh(babylonMesh, meshIndex);\r\n\r\n        const indices = babylonMesh.isUnIndexed ? null : babylonMesh.getIndices();\r\n        const vertexBuffers = babylonMesh.geometry?.getVertexBuffers();\r\n        const morphTargets = state.getMorphTargetsFromMesh(babylonMesh);\r\n\r\n        const isLinesMesh = babylonMesh instanceof LinesMesh;\r\n        const isGreasedLineMesh = babylonMesh instanceof GreasedLineBaseMesh;\r\n\r\n        const subMeshes = babylonMesh.subMeshes;\r\n        if (vertexBuffers && subMeshes && subMeshes.length > 0) {\r\n            for (const subMesh of subMeshes) {\r\n                const primitive: IMeshPrimitive = { attributes: {} };\r\n\r\n                const babylonMaterial = subMesh.getMaterial() || this._babylonScene.defaultMaterial;\r\n\r\n                if (isGreasedLineMesh) {\r\n                    const material: IMaterial = {\r\n                        name: babylonMaterial.name,\r\n                    };\r\n\r\n                    const babylonLinesMesh = babylonMesh;\r\n\r\n                    const colorWhite = Color3.White();\r\n                    const alpha = babylonLinesMesh.material?.alpha ?? 1;\r\n                    const color = babylonLinesMesh.greasedLineMaterial?.color ?? colorWhite;\r\n                    if (!color.equalsWithEpsilon(colorWhite, Epsilon) || alpha < 1) {\r\n                        material.pbrMetallicRoughness = {\r\n                            baseColorFactor: [...color.asArray(), alpha],\r\n                        };\r\n                    }\r\n\r\n                    this._materials.push(material);\r\n                    primitive.material = this._materials.length - 1;\r\n                } else if (isLinesMesh) {\r\n                    // Special case for LinesMesh\r\n                    const material: IMaterial = {\r\n                        name: babylonMaterial.name,\r\n                    };\r\n\r\n                    const babylonLinesMesh = babylonMesh;\r\n\r\n                    if (!babylonLinesMesh.color.equalsWithEpsilon(Color3.White(), Epsilon) || babylonLinesMesh.alpha < 1) {\r\n                        material.pbrMetallicRoughness = {\r\n                            baseColorFactor: [...babylonLinesMesh.color.asArray(), babylonLinesMesh.alpha],\r\n                        };\r\n                    }\r\n\r\n                    this._materials.push(material);\r\n                    primitive.material = this._materials.length - 1;\r\n                } else {\r\n                    // Material\r\n                    // eslint-disable-next-line no-await-in-loop\r\n                    await this._exportMaterialAsync(babylonMaterial, vertexBuffers, subMesh, primitive);\r\n                }\r\n\r\n                // Index buffer\r\n                const fillMode = isLinesMesh || isGreasedLineMesh ? Material.LineListDrawMode : (babylonMesh.overrideRenderingFillMode ?? babylonMaterial.fillMode);\r\n\r\n                let sideOrientation = babylonMaterial._getEffectiveOrientation(babylonMesh);\r\n                if (state.wasAddedByNoopNode && !babylonMesh.getScene().useRightHandedSystem) {\r\n                    // To properly remove a conversion node, we must also cancel out the implicit flip in its children's side orientations.\r\n                    sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n                }\r\n\r\n                this._exportIndices(\r\n                    indices,\r\n                    indices ? AreIndices32Bits(indices, subMesh.indexCount, subMesh.indexStart, subMesh.verticesStart) : subMesh.verticesCount > 65535,\r\n                    indices ? subMesh.indexStart : subMesh.verticesStart,\r\n                    indices ? subMesh.indexCount : subMesh.verticesCount,\r\n                    -subMesh.verticesStart,\r\n                    fillMode,\r\n                    sideOrientation,\r\n                    state,\r\n                    primitive\r\n                );\r\n\r\n                // Vertex buffers\r\n                for (const vertexBuffer of Object.values(vertexBuffers)) {\r\n                    this._exportVertexBuffer(vertexBuffer, babylonMaterial, subMesh.verticesStart, subMesh.verticesCount, state, primitive);\r\n                }\r\n\r\n                if (morphTargets) {\r\n                    primitive.targets = [];\r\n                    for (const gltfMorphTarget of morphTargets) {\r\n                        primitive.targets.push(gltfMorphTarget.attributes);\r\n                    }\r\n                }\r\n\r\n                mesh.primitives.push(primitive);\r\n                this._extensionsPostExportMeshPrimitive(primitive);\r\n            }\r\n        }\r\n\r\n        if (morphTargets) {\r\n            mesh.weights = [];\r\n\r\n            if (!mesh.extras) {\r\n                mesh.extras = {};\r\n            }\r\n            mesh.extras.targetNames = [];\r\n\r\n            for (const gltfMorphTarget of morphTargets) {\r\n                mesh.weights.push(gltfMorphTarget.influence);\r\n                mesh.extras.targetNames.push(gltfMorphTarget.name);\r\n            }\r\n        }\r\n\r\n        return meshIndex;\r\n    }\r\n}\r\n","import type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { GLTFData } from \"./glTFData\";\r\nimport { GLTFExporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Mesh compression methods.\r\n */\r\nexport type MeshCompressionMethod = \"None\" | \"Draco\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon node should be exported or not\r\n     * @param node source Babylon node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the node should be exported (true) or not (false)\r\n     */\r\n    shouldExportNode?(node: Node): boolean;\r\n\r\n    /**\r\n     * Function which indicates whether an animation on the scene should be exported or not\r\n     * @param animation source animation\r\n     * @returns boolean, which indicates whether the animation should be exported (true) or not (false)\r\n     */\r\n    shouldExportAnimation?(animation: Animation): boolean;\r\n\r\n    /**\r\n     * Function to extract the part of the scene or node's `metadata` that will populate the corresponding\r\n     * glTF object's `extras` field. If not defined, `node.metadata.gltf.extras` will be used.\r\n     * @param metadata source metadata to read from\r\n     * @returns the data to store into the glTF extras field\r\n     */\r\n    metadataSelector?(metadata: any): any;\r\n\r\n    /**\r\n     * The sample rate to bake animation curves. Defaults to 1 / 60.\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready. Defaults to false.\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n\r\n    /**\r\n     * Indicates if unused vertex uv attributes should be included in export. Defaults to false.\r\n     */\r\n    exportUnusedUVs?: boolean;\r\n\r\n    /**\r\n     * Remove no-op root nodes when possible. Defaults to true.\r\n     */\r\n    removeNoopRootNodes?: boolean;\r\n\r\n    /**\r\n     * Indicates if coordinate system swapping root nodes should be included in export. Defaults to false.\r\n     * @deprecated Please use removeNoopRootNodes instead\r\n     */\r\n    includeCoordinateSystemConversionNodes?: boolean;\r\n\r\n    /**\r\n     * Indicates what compression method to apply to mesh data.\r\n     */\r\n    meshCompressionMethod?: MeshCompressionMethod;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the scene to .gltf file format\r\n     * @param scene Babylon scene\r\n     * @param fileName Name to use for the .gltf file\r\n     * @param options Exporter options\r\n     * @returns Returns the exported data\r\n     */\r\n    public static async GLTFAsync(scene: Scene, fileName: string, options?: IExportOptions): Promise<GLTFData> {\r\n        if (!options || !options.exportWithoutWaitingForScene) {\r\n            await scene.whenReadyAsync();\r\n        }\r\n\r\n        const exporter = new GLTFExporter(scene, options);\r\n        const data = await exporter.generateGLTFAsync(fileName.replace(/\\.[^/.]+$/, \"\"));\r\n        exporter.dispose();\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Exports the scene to .glb file format\r\n     * @param scene Babylon scene\r\n     * @param fileName Name to use for the .glb file\r\n     * @param options Exporter options\r\n     * @returns Returns the exported data\r\n     */\r\n    public static async GLBAsync(scene: Scene, fileName: string, options?: IExportOptions): Promise<GLTFData> {\r\n        if (!options || !options.exportWithoutWaitingForScene) {\r\n            await scene.whenReadyAsync();\r\n        }\r\n\r\n        const exporter = new GLTFExporter(scene, options);\r\n        const data = await exporter.generateGLBAsync(fileName.replace(/\\.[^/.]+$/, \"\"));\r\n        exporter.dispose();\r\n\r\n        return data;\r\n    }\r\n}\r\n","import type { INode, IEXTMeshGpuInstancing } from \"babylonjs-gltf2interface\";\r\nimport { AccessorType, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport type { BufferManager } from \"../bufferManager\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Node } from \"core/node\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport \"core/Meshes/thinInstanceMesh\";\r\nimport { TmpVectors, Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport { ConvertToRightHandedPosition, ConvertToRightHandedRotation } from \"../glTFUtilities\";\r\n\r\nconst NAME = \"EXT_mesh_gpu_instancing\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_mesh_gpu_instancing implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After node is exported\r\n     * @param context the GLTF context when loading the asset\r\n     * @param node the node exported\r\n     * @param babylonNode the corresponding babylon node\r\n     * @param nodeMap map from babylon node id to node index\r\n     * @param convertToRightHanded true if we need to convert data from left hand to right hand system.\r\n     * @param bufferManager buffer manager\r\n     * @returns nullable promise, resolves with the node\r\n     */\r\n    public async postExportNodeAsync(\r\n        context: string,\r\n        node: Nullable<INode>,\r\n        babylonNode: Node,\r\n        nodeMap: Map<Node, number>,\r\n        convertToRightHanded: boolean,\r\n        bufferManager: BufferManager\r\n    ): Promise<Nullable<INode>> {\r\n        return await new Promise((resolve) => {\r\n            if (node && babylonNode instanceof Mesh) {\r\n                if (babylonNode.hasThinInstances && this._exporter) {\r\n                    this._wasUsed = true;\r\n\r\n                    const noTranslation = Vector3.Zero();\r\n                    const noRotation = Quaternion.Identity();\r\n                    const noScale = Vector3.One();\r\n\r\n                    // retrieve all the instance world matrix\r\n                    const matrix = babylonNode.thinInstanceGetWorldMatrices();\r\n\r\n                    const iwt = TmpVectors.Vector3[2];\r\n                    const iwr = TmpVectors.Quaternion[1];\r\n                    const iws = TmpVectors.Vector3[3];\r\n\r\n                    let hasAnyInstanceWorldTranslation = false;\r\n                    let hasAnyInstanceWorldRotation = false;\r\n                    let hasAnyInstanceWorldScale = false;\r\n\r\n                    // prepare temp buffers\r\n                    const translationBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);\r\n                    const rotationBuffer = new Float32Array(babylonNode.thinInstanceCount * 4);\r\n                    const scaleBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);\r\n\r\n                    let i = 0;\r\n                    for (const m of matrix) {\r\n                        m.decompose(iws, iwr, iwt);\r\n\r\n                        if (convertToRightHanded) {\r\n                            ConvertToRightHandedPosition(iwt);\r\n                            ConvertToRightHandedRotation(iwr);\r\n                        }\r\n\r\n                        // fill the temp buffer\r\n                        translationBuffer.set(iwt.asArray(), i * 3);\r\n                        rotationBuffer.set(iwr.normalize().asArray(), i * 4); // ensure the quaternion is normalized\r\n                        scaleBuffer.set(iws.asArray(), i * 3);\r\n\r\n                        // this is where we decide if there is any transformation\r\n                        hasAnyInstanceWorldTranslation = hasAnyInstanceWorldTranslation || !iwt.equalsWithEpsilon(noTranslation);\r\n                        hasAnyInstanceWorldRotation = hasAnyInstanceWorldRotation || !iwr.equalsWithEpsilon(noRotation);\r\n                        hasAnyInstanceWorldScale = hasAnyInstanceWorldScale || !iws.equalsWithEpsilon(noScale);\r\n\r\n                        i++;\r\n                    }\r\n\r\n                    const extension: IEXTMeshGpuInstancing = {\r\n                        attributes: {},\r\n                    };\r\n\r\n                    // do we need to write TRANSLATION ?\r\n                    if (hasAnyInstanceWorldTranslation) {\r\n                        extension.attributes[\"TRANSLATION\"] = this._buildAccessor(translationBuffer, AccessorType.VEC3, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n                    // do we need to write ROTATION ?\r\n                    if (hasAnyInstanceWorldRotation) {\r\n                        // we decided to stay on FLOAT for now see https://github.com/BabylonJS/Babylon.js/pull/12495\r\n                        extension.attributes[\"ROTATION\"] = this._buildAccessor(rotationBuffer, AccessorType.VEC4, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n                    // do we need to write SCALE ?\r\n                    if (hasAnyInstanceWorldScale) {\r\n                        extension.attributes[\"SCALE\"] = this._buildAccessor(scaleBuffer, AccessorType.VEC3, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n\r\n                    /* eslint-enable @typescript-eslint/naming-convention*/\r\n                    node.extensions = node.extensions || {};\r\n                    node.extensions[NAME] = extension;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n\r\n    private _buildAccessor(buffer: Float32Array, type: AccessorType, count: number, bufferManager: BufferManager): number {\r\n        // build the buffer view\r\n        const bv = bufferManager.createBufferView(buffer);\r\n\r\n        // finally build the accessor\r\n        const accessor = bufferManager.createAccessor(bv, type, AccessorComponentType.FLOAT, count);\r\n        this._exporter._accessors.push(accessor);\r\n        return this._exporter._accessors.length - 1;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_mesh_gpu_instancing(exporter));\r\n","import type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { GLTFExporter } from \"../glTFExporter\";\nimport { MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\nimport type { IAccessor, IBufferView, IKHRDracoMeshCompression, IMeshPrimitive } from \"babylonjs-gltf2interface\";\nimport type { BufferManager } from \"../bufferManager\";\nimport { DracoEncoder } from \"core/Meshes/Compression/dracoEncoder\";\nimport { GetTypedArrayData, GetTypeByteLength } from \"core/Buffers/bufferUtils\";\nimport { GetAccessorElementCount } from \"../glTFUtilities\";\nimport type { DracoAttributeName, IDracoAttributeData, IDracoEncoderOptions } from \"core/Meshes/Compression/dracoEncoder.types\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { Nullable } from \"core/types\";\n\nconst NAME = \"KHR_draco_mesh_compression\";\n\nfunction GetDracoAttributeName(glTFName: string): DracoAttributeName {\n    if (glTFName === \"POSITION\") {\n        return \"POSITION\";\n    } else if (glTFName === \"NORMAL\") {\n        return \"NORMAL\";\n    } else if (glTFName.startsWith(\"COLOR\")) {\n        return \"COLOR\";\n    } else if (glTFName.startsWith(\"TEXCOORD\")) {\n        return \"TEX_COORD\";\n    }\n    return \"GENERIC\";\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_draco_mesh_compression implements IGLTFExporterExtensionV2 {\n    /** Name of this extension */\n    public readonly name = NAME;\n\n    /** Defines whether this extension is enabled */\n    public enabled;\n\n    /** KHR_draco_mesh_compression is required, as uncompressed fallback data is not yet implemented. */\n    public required = true;\n\n    /** BufferViews used for Draco data, which may be eligible for removal after Draco encoding */\n    private _bufferViewsUsed: Set<IBufferView> = new Set();\n\n    /** Accessors that were replaced with Draco data, which may be eligible for removal after Draco encoding */\n    private _accessorsUsed: Set<IAccessor> = new Set();\n\n    /** Promise pool for Draco encoding work */\n    private _encodePromises: Promise<void>[] = [];\n\n    private _wasUsed = false;\n\n    /** @internal */\n    public get wasUsed() {\n        return this._wasUsed;\n    }\n\n    /** @internal */\n    constructor(exporter: GLTFExporter) {\n        this.enabled = exporter.options.meshCompressionMethod === \"Draco\" && DracoEncoder.DefaultAvailable;\n    }\n\n    /** @internal */\n    public dispose() {}\n\n    /** @internal */\n    public postExportMeshPrimitive(primitive: IMeshPrimitive, bufferManager: BufferManager, accessors: IAccessor[]): void {\n        if (!this.enabled) {\n            return;\n        }\n\n        if (primitive.mode !== MeshPrimitiveMode.TRIANGLES && primitive.mode !== MeshPrimitiveMode.TRIANGLE_STRIP) {\n            Logger.Warn(\"Cannot compress primitive with mode \" + primitive.mode + \".\");\n            return;\n        }\n\n        // Collect bufferViews and accessors used by this primitive\n        const primitiveBufferViews: IBufferView[] = [];\n        const primitiveAccessors: IAccessor[] = [];\n\n        // Prepare indices for Draco encoding\n        let indices: Nullable<Uint32Array | Uint16Array> = null;\n        if (primitive.indices !== undefined) {\n            const accessor = accessors[primitive.indices];\n            const bufferView = bufferManager.getBufferView(accessor);\n            // Per exportIndices, indices must be either Uint16Array or Uint32Array\n            indices = bufferManager.getData(bufferView).slice() as Uint32Array | Uint16Array;\n\n            primitiveBufferViews.push(bufferView);\n            primitiveAccessors.push(accessor);\n        }\n\n        // Prepare attributes for Draco encoding\n        const attributes: IDracoAttributeData[] = [];\n        for (const [name, accessorIndex] of Object.entries(primitive.attributes)) {\n            const accessor = accessors[accessorIndex];\n            const bufferView = bufferManager.getBufferView(accessor);\n\n            const size = GetAccessorElementCount(accessor.type);\n            const data = GetTypedArrayData(\n                bufferManager.getData(bufferView),\n                size,\n                accessor.componentType,\n                accessor.byteOffset || 0,\n                bufferView.byteStride || GetTypeByteLength(accessor.componentType) * size,\n                accessor.normalized || false,\n                accessor.count,\n                true\n            );\n\n            attributes.push({ kind: name, dracoName: GetDracoAttributeName(name), size: GetAccessorElementCount(accessor.type), data: data });\n\n            primitiveBufferViews.push(bufferView);\n            primitiveAccessors.push(accessor);\n        }\n\n        // Use sequential encoding to preserve vertex order for cases like morph targets\n        const options: IDracoEncoderOptions = {\n            method: primitive.targets ? \"MESH_SEQUENTIAL_ENCODING\" : \"MESH_EDGEBREAKER_ENCODING\",\n        };\n\n        const promise = DracoEncoder.Default._encodeAsync(attributes, indices, options)\n            // eslint-disable-next-line github/no-then\n            .then((encodedData) => {\n                if (!encodedData) {\n                    Logger.Error(\"Draco encoding failed for primitive.\");\n                    return;\n                }\n\n                const dracoInfo: IKHRDracoMeshCompression = {\n                    bufferView: -1, // bufferView will be set to a real index later, when we write the binary and decide bufferView ordering\n                    attributes: encodedData.attributeIds,\n                };\n                const bufferView = bufferManager.createBufferView(encodedData.data);\n                bufferManager.setBufferView(dracoInfo, bufferView);\n\n                for (const bufferView of primitiveBufferViews) {\n                    this._bufferViewsUsed.add(bufferView);\n                }\n                for (const accessor of primitiveAccessors) {\n                    this._accessorsUsed.add(accessor);\n                }\n\n                primitive.extensions ||= {};\n                primitive.extensions[NAME] = dracoInfo;\n            })\n            // eslint-disable-next-line github/no-then\n            .catch((error) => {\n                Logger.Error(\"Draco encoding failed for primitive: \" + error);\n            });\n\n        this._encodePromises.push(promise);\n\n        this._wasUsed = true;\n    }\n\n    /** @internal */\n    public async preGenerateBinaryAsync(bufferManager: BufferManager): Promise<void> {\n        if (!this.enabled) {\n            return;\n        }\n\n        await Promise.all(this._encodePromises);\n\n        // Cull obsolete bufferViews that were replaced with Draco data\n        this._bufferViewsUsed.forEach((bufferView) => {\n            const references = bufferManager.getPropertiesWithBufferView(bufferView);\n            const onlyUsedByEncodedPrimitives = references.every((object) => {\n                return this._accessorsUsed.has(object as IAccessor); // has() can handle any object, but TS doesn't know that\n            });\n            if (onlyUsedByEncodedPrimitives) {\n                bufferManager.removeBufferView(bufferView);\n            }\n        });\n\n        this._bufferViewsUsed.clear();\n        this._accessorsUsed.clear();\n    }\n}\n\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_draco_mesh_compression(exporter));\n","import type { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { Node } from \"core/node\";\r\nimport { ShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { INode, IKHRLightsPunctual_LightReference, IKHRLightsPunctual_Light, IKHRLightsPunctual } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { ConvertToRightHandedPosition, OmitDefaultValues, CollapseChildIntoParent, IsChildCollapsible } from \"../glTFUtilities\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\nconst DEFAULTS: Omit<IKHRLightsPunctual_Light, \"type\"> = {\r\n    name: \"\",\r\n    color: [1, 1, 1],\r\n    intensity: 1,\r\n    range: Number.MAX_VALUE,\r\n};\r\nconst SPOTDEFAULTS: NonNullable<IKHRLightsPunctual_Light[\"spot\"]> = {\r\n    innerConeAngle: 0,\r\n    outerConeAngle: Math.PI / 4.0,\r\n};\r\nconst LIGHTDIRECTION = Vector3.Backward();\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights_punctual implements IGLTFExporterExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _lights: IKHRLightsPunctual;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._lights as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return !!this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onExporting(): void {\r\n        this._exporter._glTF.extensions![NAME] = this._lights;\r\n    }\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a node\r\n     * @param context The context when exporting the node\r\n     * @param node glTF node\r\n     * @param babylonNode BabylonJS node\r\n     * @param nodeMap Node mapping of babylon node to glTF node index\r\n     * @param convertToRightHanded Flag to convert the values to right-handed\r\n     * @returns nullable INode promise\r\n     */\r\n    public async postExportNodeAsync(context: string, node: INode, babylonNode: Node, nodeMap: Map<Node, number>, convertToRightHanded: boolean): Promise<Nullable<INode>> {\r\n        return await new Promise((resolve) => {\r\n            if (!(babylonNode instanceof Light)) {\r\n                resolve(node);\r\n                return;\r\n            }\r\n\r\n            const lightType =\r\n                babylonNode.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT\r\n                    ? KHRLightsPunctual_LightType.POINT\r\n                    : babylonNode.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT\r\n                      ? KHRLightsPunctual_LightType.DIRECTIONAL\r\n                      : babylonNode.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT\r\n                        ? KHRLightsPunctual_LightType.SPOT\r\n                        : null;\r\n            if (!lightType || !(babylonNode instanceof ShadowLight)) {\r\n                Logger.Warn(`${context}: Light ${babylonNode.name} is not supported in ${NAME}`);\r\n                resolve(node);\r\n                return;\r\n            }\r\n\r\n            if (babylonNode.falloffType !== Light.FALLOFF_GLTF) {\r\n                Logger.Warn(`${context}: Light falloff for ${babylonNode.name} does not match the ${NAME} specification!`);\r\n            }\r\n\r\n            // Set the node's translation and rotation here, since lights are not handled in exportNodeAsync\r\n            if (!babylonNode.position.equalsToFloats(0, 0, 0)) {\r\n                const translation = TmpVectors.Vector3[0].copyFrom(babylonNode.position);\r\n                if (convertToRightHanded) {\r\n                    ConvertToRightHandedPosition(translation);\r\n                }\r\n                node.translation = translation.asArray();\r\n            }\r\n\r\n            // Represent the Babylon light's direction as a quaternion\r\n            // relative to glTF lights' forward direction, (0, 0, -1).\r\n            if (lightType !== KHRLightsPunctual_LightType.POINT) {\r\n                const direction = babylonNode.direction.normalizeToRef(TmpVectors.Vector3[0]);\r\n                if (convertToRightHanded) {\r\n                    ConvertToRightHandedPosition(direction);\r\n                }\r\n\r\n                const lightRotationQuaternion = Quaternion.FromUnitVectorsToRef(LIGHTDIRECTION, direction, TmpVectors.Quaternion[0]);\r\n                if (!Quaternion.IsIdentity(lightRotationQuaternion)) {\r\n                    node.rotation = lightRotationQuaternion.asArray();\r\n                }\r\n            }\r\n\r\n            const light: IKHRLightsPunctual_Light = {\r\n                type: lightType,\r\n                name: babylonNode.name,\r\n                color: babylonNode.diffuse.asArray(),\r\n                intensity: babylonNode.intensity,\r\n                range: babylonNode.range,\r\n            };\r\n            OmitDefaultValues(light, DEFAULTS);\r\n\r\n            // Separately handle the required 'spot' field for spot lights\r\n            if (lightType === KHRLightsPunctual_LightType.SPOT) {\r\n                const babylonSpotLight = babylonNode as SpotLight;\r\n                light.spot = {\r\n                    innerConeAngle: babylonSpotLight.innerAngle / 2.0,\r\n                    outerConeAngle: babylonSpotLight.angle / 2.0,\r\n                };\r\n                OmitDefaultValues(light.spot, SPOTDEFAULTS);\r\n            }\r\n\r\n            this._lights ||= {\r\n                lights: [],\r\n            };\r\n            this._lights.lights.push(light);\r\n\r\n            const lightReference: IKHRLightsPunctual_LightReference = {\r\n                light: this._lights.lights.length - 1,\r\n            };\r\n\r\n            // Assign the light to its parent node, if possible, to condense the glTF\r\n            // Why and when: the glTF loader generates a new parent TransformNode for each light node, which we should undo on export\r\n            const parentBabylonNode = babylonNode.parent;\r\n\r\n            if (parentBabylonNode && IsChildCollapsible(babylonNode, parentBabylonNode)) {\r\n                const parentNodeIndex = nodeMap.get(parentBabylonNode);\r\n                if (parentNodeIndex) {\r\n                    // Combine the light's transformation with the parent's\r\n                    const parentNode = this._exporter._nodes[parentNodeIndex];\r\n                    CollapseChildIntoParent(node, parentNode);\r\n                    parentNode.extensions ||= {};\r\n                    parentNode.extensions[NAME] = lightReference;\r\n\r\n                    // Do not export the original node\r\n                    resolve(null);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            node.extensions ||= {};\r\n            node.extensions[NAME] = lightReference;\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_lights_punctual(exporter));\r\n","import type { IMaterial, IKHRMaterialsAnisotropy } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_anisotropy\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_anisotropy implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.anisotropy.isEnabled && !babylonMaterial.anisotropy.legacy) {\r\n                if (babylonMaterial.anisotropy.texture) {\r\n                    additionalTextures.push(babylonMaterial.anisotropy.texture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.anisotropy.isEnabled || babylonMaterial.anisotropy.legacy) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const anisotropyTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.anisotropy.texture);\r\n\r\n                const anisotropyInfo: IKHRMaterialsAnisotropy = {\r\n                    anisotropyStrength: babylonMaterial.anisotropy.intensity,\r\n                    anisotropyRotation: babylonMaterial.anisotropy.angle,\r\n                    anisotropyTexture: anisotropyTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (anisotropyInfo.anisotropyTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = anisotropyInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_anisotropy(exporter));\r\n","import type { IMaterial, IKHRMaterialsClearcoat } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.clearCoat.isEnabled) {\r\n                if (babylonMaterial.clearCoat.texture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.texture);\r\n                }\r\n                if (!babylonMaterial.clearCoat.useRoughnessFromMainTexture && babylonMaterial.clearCoat.textureRoughness) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n                if (babylonMaterial.clearCoat.bumpTexture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.bumpTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.clearCoat.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const clearCoatTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                let clearCoatTextureRoughnessInfo;\r\n                if (babylonMaterial.clearCoat.useRoughnessFromMainTexture) {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                } else {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n\r\n                if (babylonMaterial.clearCoat.isTintEnabled) {\r\n                    Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                if (babylonMaterial.clearCoat.remapF0OnInterfaceChange) {\r\n                    Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                const clearCoatNormalTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.bumpTexture);\r\n\r\n                const clearCoatInfo: IKHRMaterialsClearcoat = {\r\n                    clearcoatFactor: babylonMaterial.clearCoat.intensity,\r\n                    clearcoatTexture: clearCoatTextureInfo ?? undefined,\r\n                    clearcoatRoughnessFactor: babylonMaterial.clearCoat.roughness,\r\n                    clearcoatRoughnessTexture: clearCoatTextureRoughnessInfo ?? undefined,\r\n                    clearcoatNormalTexture: clearCoatNormalTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (clearCoatInfo.clearcoatTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = clearCoatInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_clearcoat(exporter));\r\n","import type { IMaterial, IKHRMaterialsDiffuseTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nconst NAME = \"KHR_materials_diffuse_transmission\";\r\n\r\n/**\r\n * Get the appropriate translucency intensity texture for the material.\r\n * @internal\r\n */\r\nfunction GetTranslucencyIntensityTexture(context: string, babylonMaterial: PBRMaterial): Nullable<BaseTexture> {\r\n    const subs = babylonMaterial.subSurface;\r\n    let texture = null;\r\n\r\n    // Check if translucency intensity texture is available or can be derived from thickness texture\r\n    if (subs.translucencyIntensityTexture) {\r\n        texture = subs.translucencyIntensityTexture;\r\n    } else if (subs.thicknessTexture && subs.useMaskFromThicknessTexture) {\r\n        texture = subs.thicknessTexture;\r\n    }\r\n\r\n    if (texture && !subs.useGltfStyleTextures) {\r\n        Logger.Warn(`${context}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${babylonMaterial.name}`, 1);\r\n        return null;\r\n    }\r\n\r\n    return texture;\r\n}\r\n\r\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_diffuse_transmission implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n            const translucencyIntensityTexture = GetTranslucencyIntensityTexture(context, babylonMaterial);\r\n            if (translucencyIntensityTexture) {\r\n                additionalTextures.push(translucencyIntensityTexture);\r\n            }\r\n            if (babylonMaterial.subSurface.translucencyColorTexture) {\r\n                additionalTextures.push(babylonMaterial.subSurface.translucencyColorTexture);\r\n            }\r\n            return additionalTextures;\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        if (!subs.isTranslucencyEnabled) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            !mat.unlit &&\r\n            !subs.useAlbedoToTintTranslucency &&\r\n            subs.useGltfStyleTextures &&\r\n            subs.volumeIndexOfRefraction === 1 &&\r\n            subs.minimumThickness === 0 &&\r\n            subs.maximumThickness === 0\r\n        );\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise that resolves with the updated node\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const translucencyIntensityTexture = GetTranslucencyIntensityTexture(context, babylonMaterial);\r\n\r\n                const diffuseTransmissionFactor = subs.translucencyIntensity == 0 ? undefined : subs.translucencyIntensity;\r\n                const diffuseTransmissionTexture = this._exporter._materialExporter.getTextureInfo(translucencyIntensityTexture) ?? undefined;\r\n                const diffuseTransmissionColorFactor = !subs.translucencyColor || subs.translucencyColor.equalsFloats(1.0, 1.0, 1.0) ? undefined : subs.translucencyColor.asArray();\r\n                const diffuseTransmissionColorTexture = this._exporter._materialExporter.getTextureInfo(subs.translucencyColorTexture) ?? undefined;\r\n\r\n                const diffuseTransmissionInfo: IKHRMaterialsDiffuseTransmission = {\r\n                    diffuseTransmissionFactor,\r\n                    diffuseTransmissionTexture,\r\n                    diffuseTransmissionColorFactor,\r\n                    diffuseTransmissionColorTexture,\r\n                };\r\n\r\n                if (diffuseTransmissionTexture || diffuseTransmissionColorTexture) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = diffuseTransmissionInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_diffuse_transmission(exporter));\r\n","import type { IMaterial, IKHRMaterialsDispersion } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nconst NAME = \"KHR_materials_dispersion\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/87bd64a7f5e23c84b6aef2e6082069583ed0ddb4/extensions/2.0/Khronos/KHR_materials_dispersion/README.md)\r\n * @experimental\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_dispersion implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    /** Constructor */\r\n    constructor() {}\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        // this extension requires refraction to be enabled.\r\n        if (!subs.isRefractionEnabled && !subs.isDispersionEnabled) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const dispersion = subs.dispersion;\r\n\r\n                const dispersionInfo: IKHRMaterialsDispersion = {\r\n                    dispersion: dispersion,\r\n                };\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = dispersionInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_materials_dispersion());\r\n","import type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { IMaterial, IKHRMaterialsEmissiveStrength } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_emissive_strength\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_emissive_strength implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    public async postExportMaterialAsync(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return await new Promise((resolve) => {\r\n            if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                return resolve(node);\r\n            }\r\n\r\n            const emissiveColor = babylonMaterial.emissiveColor.asArray();\r\n            const tempEmissiveStrength = Math.max(...emissiveColor);\r\n\r\n            if (tempEmissiveStrength > 1) {\r\n                this._wasUsed = true;\r\n\r\n                node.extensions ||= {};\r\n\r\n                const emissiveStrengthInfo: IKHRMaterialsEmissiveStrength = {\r\n                    emissiveStrength: tempEmissiveStrength,\r\n                };\r\n\r\n                // Normalize each value of the emissive factor to have a max value of 1\r\n                const newEmissiveFactor = babylonMaterial.emissiveColor.scale(1 / emissiveStrengthInfo.emissiveStrength);\r\n\r\n                node.emissiveFactor = newEmissiveFactor.asArray();\r\n                node.extensions[NAME] = emissiveStrengthInfo;\r\n            }\r\n\r\n            return resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_emissive_strength());\r\n","import type { IMaterial, IKHRMaterialsIor } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nconst NAME = \"KHR_materials_ior\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_ior implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        return mat.indexOfRefraction != undefined && mat.indexOfRefraction != 1.5; // 1.5 is normative default value.\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const iorInfo: IKHRMaterialsIor = {\r\n                    ior: babylonMaterial.indexOfRefraction,\r\n                };\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = iorInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_ior());\r\n","import type { IMaterial, IKHRMaterialsIridescence } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_iridescence\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_iridescence implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.iridescence.isEnabled) {\r\n                if (babylonMaterial.iridescence.texture) {\r\n                    additionalTextures.push(babylonMaterial.iridescence.texture);\r\n                }\r\n                if (babylonMaterial.iridescence.thicknessTexture && babylonMaterial.iridescence.thicknessTexture !== babylonMaterial.iridescence.texture) {\r\n                    additionalTextures.push(babylonMaterial.iridescence.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.iridescence.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const iridescenceTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.iridescence.texture);\r\n                const iridescenceThicknessTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.iridescence.thicknessTexture);\r\n\r\n                const iridescenceInfo: IKHRMaterialsIridescence = {\r\n                    iridescenceFactor: babylonMaterial.iridescence.intensity,\r\n                    iridescenceIor: babylonMaterial.iridescence.indexOfRefraction,\r\n                    iridescenceThicknessMinimum: babylonMaterial.iridescence.minimumThickness,\r\n                    iridescenceThicknessMaximum: babylonMaterial.iridescence.maximumThickness,\r\n\r\n                    iridescenceTexture: iridescenceTextureInfo ?? undefined,\r\n                    iridescenceThicknessTexture: iridescenceThicknessTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (iridescenceInfo.iridescenceTexture !== null || iridescenceInfo.iridescenceThicknessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = iridescenceInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_iridescence(exporter));\r\n","import type { IMaterial, IKHRMaterialsSheen } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_sheen\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_sheen implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (babylonMaterial.sheen.isEnabled && babylonMaterial.sheen.texture) {\r\n                return [babylonMaterial.sheen.texture];\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public async postExportMaterialAsync(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return await new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                if (!babylonMaterial.sheen.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n                const sheenInfo: IKHRMaterialsSheen = {\r\n                    sheenColorFactor: babylonMaterial.sheen.color.asArray(),\r\n                    sheenRoughnessFactor: babylonMaterial.sheen.roughness ?? 0,\r\n                };\r\n\r\n                if (sheenInfo.sheenColorTexture !== null || sheenInfo.sheenRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                if (babylonMaterial.sheen.texture) {\r\n                    sheenInfo.sheenColorTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.texture) ?? undefined;\r\n                }\r\n\r\n                if (babylonMaterial.sheen.textureRoughness && !babylonMaterial.sheen.useRoughnessFromMainTexture) {\r\n                    sheenInfo.sheenRoughnessTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.textureRoughness) ?? undefined;\r\n                } else if (babylonMaterial.sheen.texture && babylonMaterial.sheen.useRoughnessFromMainTexture) {\r\n                    sheenInfo.sheenRoughnessTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.texture) ?? undefined;\r\n                }\r\n\r\n                node.extensions[NAME] = sheenInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_sheen(exporter));\r\n","import type { IMaterial, IKHRMaterialsSpecular } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_specular\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_specular implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with the additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.metallicReflectanceTexture) {\r\n                    additionalTextures.push(babylonMaterial.metallicReflectanceTexture);\r\n                }\r\n                if (babylonMaterial.reflectanceTexture) {\r\n                    additionalTextures.push(babylonMaterial.reflectanceTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        return (\r\n            (mat.metallicF0Factor != undefined && mat.metallicF0Factor != 1.0) ||\r\n            (mat.metallicReflectanceColor != undefined && !mat.metallicReflectanceColor.equalsFloats(1.0, 1.0, 1.0)) ||\r\n            this._hasTexturesExtension(mat)\r\n        );\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.metallicReflectanceTexture != null || mat.reflectanceTexture != null;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const metallicReflectanceTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.metallicReflectanceTexture) ?? undefined;\r\n                const reflectanceTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.reflectanceTexture) ?? undefined;\r\n                const metallicF0Factor = babylonMaterial.metallicF0Factor == 1.0 ? undefined : babylonMaterial.metallicF0Factor;\r\n                const metallicReflectanceColor = babylonMaterial.metallicReflectanceColor.equalsFloats(1.0, 1.0, 1.0)\r\n                    ? undefined\r\n                    : babylonMaterial.metallicReflectanceColor.asArray();\r\n\r\n                const specularInfo: IKHRMaterialsSpecular = {\r\n                    specularFactor: metallicF0Factor,\r\n                    specularTexture: metallicReflectanceTexture,\r\n                    specularColorFactor: metallicReflectanceColor,\r\n                    specularColorTexture: reflectanceTexture,\r\n                };\r\n\r\n                if (this._hasTexturesExtension(babylonMaterial)) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = specularInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_specular(exporter));\r\n","import type { IMaterial, IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.subSurface.thicknessTexture) {\r\n                    additionalTextures.push(babylonMaterial.subSurface.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        return (subs.isRefractionEnabled && subs.refractionIntensity != undefined && subs.refractionIntensity != 0) || this._hasTexturesExtension(mat);\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.subSurface.refractionIntensityTexture != null;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns true if successful\r\n     */\r\n    public async postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n            this._wasUsed = true;\r\n\r\n            const subSurface = babylonMaterial.subSurface;\r\n            const transmissionFactor = subSurface.refractionIntensity === 0 ? undefined : subSurface.refractionIntensity;\r\n\r\n            const volumeInfo: IKHRMaterialsTransmission = {\r\n                transmissionFactor: transmissionFactor,\r\n            };\r\n\r\n            if (this._hasTexturesExtension(babylonMaterial)) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n            }\r\n\r\n            if (subSurface.refractionIntensityTexture) {\r\n                if (subSurface.useGltfStyleTextures) {\r\n                    const transmissionTexture = await this._exporter._materialExporter.exportTextureAsync(subSurface.refractionIntensityTexture);\r\n                    if (transmissionTexture) {\r\n                        volumeInfo.transmissionTexture = transmissionTexture;\r\n                    }\r\n                } else {\r\n                    Logger.Warn(`${context}: Exporting a subsurface refraction intensity texture without \\`useGltfStyleTextures\\` is not supported`);\r\n                }\r\n            }\r\n\r\n            node.extensions ||= {};\r\n            node.extensions[NAME] = volumeInfo;\r\n        }\r\n\r\n        return node;\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_transmission(exporter));\r\n","import type { IMaterial } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_unlit implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            let unlitMaterial = false;\r\n\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                unlitMaterial = babylonMaterial.unlit;\r\n            } else if (babylonMaterial instanceof StandardMaterial) {\r\n                unlitMaterial = babylonMaterial.disableLighting;\r\n            }\r\n\r\n            if (unlitMaterial) {\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n\r\n                node.extensions[NAME] = {};\r\n            }\r\n\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_materials_unlit());\r\n","import type { IMaterial, IKHRMaterialsVolume } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\n\r\nconst NAME = \"KHR_materials_volume\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_volume implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.subSurface.thicknessTexture) {\r\n                    additionalTextures.push(babylonMaterial.subSurface.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        // this extension requires either the KHR_materials_transmission or KHR_materials_diffuse_transmission extensions.\r\n        if (!subs.isRefractionEnabled && !subs.isTranslucencyEnabled) {\r\n            return false;\r\n        }\r\n        return (\r\n            (subs.maximumThickness != undefined && subs.maximumThickness != 0) ||\r\n            (subs.tintColorAtDistance != undefined && subs.tintColorAtDistance != Number.POSITIVE_INFINITY) ||\r\n            (subs.tintColor != undefined && subs.tintColor != Color3.White()) ||\r\n            this._hasTexturesExtension(mat)\r\n        );\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.subSurface.thicknessTexture != null;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise that resolves with the updated node\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const thicknessFactor = subs.maximumThickness == 0 ? undefined : subs.maximumThickness;\r\n                const thicknessTexture = this._exporter._materialExporter.getTextureInfo(subs.thicknessTexture) ?? undefined;\r\n                const attenuationDistance = subs.tintColorAtDistance == Number.POSITIVE_INFINITY ? undefined : subs.tintColorAtDistance;\r\n                const attenuationColor = subs.tintColor.equalsFloats(1.0, 1.0, 1.0) ? undefined : subs.tintColor.asArray();\r\n\r\n                const volumeInfo: IKHRMaterialsVolume = {\r\n                    thicknessFactor: thicknessFactor,\r\n                    thicknessTexture: thicknessTexture,\r\n                    attenuationDistance: attenuationDistance,\r\n                    attenuationColor: attenuationColor,\r\n                };\r\n\r\n                if (this._hasTexturesExtension(babylonMaterial)) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = volumeInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_volume(exporter));\r\n","import type { IMaterial, IEXTMaterialsDiffuseRoughness } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"EXT_materials_diffuse_roughness\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_materials_diffuse_roughness implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial._baseDiffuseRoughness) {\r\n                if (babylonMaterial._baseDiffuseRoughnessTexture) {\r\n                    additionalTextures.push(babylonMaterial._baseDiffuseRoughnessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial._baseDiffuseRoughness) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const diffuseRoughnessTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial._baseDiffuseRoughnessTexture);\r\n\r\n                const diffuseRoughnessInfo: IEXTMaterialsDiffuseRoughness = {\r\n                    diffuseRoughnessFactor: babylonMaterial._baseDiffuseRoughness,\r\n                    diffuseRoughnessTexture: diffuseRoughnessTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (diffuseRoughnessInfo.diffuseRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = diffuseRoughnessInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_materials_diffuse_roughness(exporter));\r\n","import type { ITextureInfo, IKHRTextureTransform } from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\n/**\r\n * Computes the adjusted offset for a rotation centered about the origin.\r\n * @internal\r\n */\r\nfunction AdjustOffsetForRotationCenter(babylonTexture: Texture): [number, number] {\r\n    const { uOffset, vOffset, uRotationCenter, vRotationCenter, uScale, vScale, wAng } = babylonTexture;\r\n    const cosAngle = Math.cos(wAng);\r\n    const sinAngle = Math.sin(wAng);\r\n    const scaledURotationCenter = uRotationCenter * uScale;\r\n    const scaledVRotationCenter = vRotationCenter * vScale;\r\n    const deltaU = scaledURotationCenter * (1 - cosAngle) + scaledVRotationCenter * sinAngle;\r\n    const deltaV = scaledVRotationCenter * (1 - cosAngle) - scaledURotationCenter * sinAngle;\r\n    return [uOffset + deltaU, vOffset + deltaV];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_transform implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: Texture): void {\r\n        const scene = babylonTexture.getScene();\r\n        if (!scene) {\r\n            Tools.Warn(`${context}: \"scene\" is not defined for Babylon texture ${babylonTexture.name}!`);\r\n        }\r\n\r\n        /*\r\n         * The KHR_texture_transform schema only supports w rotation around the origin.\r\n         * See https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates.\r\n         */\r\n        if (babylonTexture.uAng !== 0 || babylonTexture.vAng !== 0) {\r\n            Tools.Warn(`${context}: Texture ${babylonTexture.name} with rotation in the u or v axis is not supported in glTF.`);\r\n            // Usually, we'd always early return here if the texture uses an unsupported combination of transform properties,\r\n            // but we're making an exception here to maintain backwards compatibility.\r\n            if (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        const textureTransform: IKHRTextureTransform = {};\r\n        let transformIsRequired = false;\r\n\r\n        if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n            textureTransform.offset = [babylonTexture.uOffset, babylonTexture.vOffset];\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n            textureTransform.scale = [babylonTexture.uScale, babylonTexture.vScale];\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.wAng !== 0) {\r\n            if (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0) {\r\n                // See https://github.com/mrdoob/three.js/issues/15831 for more details.\r\n                if (babylonTexture.homogeneousRotationInUVTransform && babylonTexture.uScale !== babylonTexture.vScale) {\r\n                    Tools.Warn(\r\n                        `${context}: Texture ${babylonTexture.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${NAME}.`\r\n                    );\r\n                    return;\r\n                }\r\n                Tools.Warn(`${context}: Texture ${babylonTexture.name} with non-origin rotation center will be exported using an adjusted offset with ${NAME}.`);\r\n                textureTransform.offset = AdjustOffsetForRotationCenter(babylonTexture);\r\n            }\r\n            textureTransform.rotation = -babylonTexture.wAng;\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.coordinatesIndex !== 0) {\r\n            textureTransform.texCoord = babylonTexture.coordinatesIndex;\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (!transformIsRequired) {\r\n            return;\r\n        }\r\n\r\n        this._wasUsed = true;\r\n        if (!textureInfo.extensions) {\r\n            textureInfo.extensions = {};\r\n        }\r\n        textureInfo.extensions[NAME] = textureTransform;\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_texture_transform());\r\n","/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable babylonjs/available */\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { GLTFExporter } from \"../glTFExporter\";\nimport { GetMimeType } from \"core/Misc/fileTools\";\nimport { ImageMimeType } from \"babylonjs-gltf2interface\";\n\nconst NAME = \"KHR_texture_basisu\";\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_basisu/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_texture_basisu implements IGLTFExporterExtensionV2 {\n    public readonly name = NAME;\n\n    public enabled = true;\n\n    public required = true;\n\n    private _wasUsed = false;\n\n    public get wasUsed() {\n        return this._wasUsed;\n    }\n\n    private _exporter: GLTFExporter;\n\n    constructor(exporter: GLTFExporter) {\n        this._exporter = exporter;\n    }\n\n    public dispose() {}\n\n    public postExportTexture(_: string, textureInfo: BABYLON.GLTF2.ITextureInfo): void {\n        const texture = this._exporter._textures[textureInfo.index];\n        const imageIndex = texture.source;\n        if (imageIndex === undefined) {\n            return;\n        }\n\n        const image = this._exporter._images[imageIndex];\n        const sourceMimeType = image.mimeType || GetMimeType(image.uri!);\n        if (sourceMimeType !== ImageMimeType.KTX2) {\n            return;\n        }\n\n        texture.source = undefined;\n        texture.extensions ||= {};\n        texture.extensions[NAME] = {\n            source: imageIndex,\n        };\n\n        this._wasUsed = true;\n    }\n}\n\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_texture_basisu(exporter));\n","/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable babylonjs/available */\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { GLTFExporter } from \"../glTFExporter\";\nimport { GetMimeType } from \"core/Misc/fileTools\";\nimport { ImageMimeType } from \"babylonjs-gltf2interface\";\n\nconst NAME = \"EXT_texture_webp\";\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_webp/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_texture_webp implements IGLTFExporterExtensionV2 {\n    public readonly name = NAME;\n\n    public enabled = true;\n\n    public required = true;\n\n    private _wasUsed = false;\n\n    public get wasUsed() {\n        return this._wasUsed;\n    }\n\n    private _exporter: GLTFExporter;\n\n    constructor(exporter: GLTFExporter) {\n        this._exporter = exporter;\n    }\n\n    public dispose() {}\n\n    public postExportTexture(_: string, textureInfo: BABYLON.GLTF2.ITextureInfo): void {\n        const texture = this._exporter._textures[textureInfo.index];\n        const imageIndex = texture.source;\n        if (imageIndex === undefined) {\n            return;\n        }\n\n        const image = this._exporter._images[imageIndex];\n        const sourceMimeType = image.mimeType || GetMimeType(image.uri!);\n        if (sourceMimeType !== ImageMimeType.WEBP) {\n            return;\n        }\n\n        texture.source = undefined;\n        texture.extensions ||= {};\n        texture.extensions[NAME] = {\n            source: imageIndex,\n        };\n\n        this._wasUsed = true;\n    }\n}\n\nGLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_texture_webp(exporter));\n","/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable babylonjs/available */\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { GLTFExporter } from \"../glTFExporter\";\nimport { GetMimeType } from \"core/Misc/fileTools\";\nimport { ImageMimeType } from \"babylonjs-gltf2interface\";\n\nconst NAME = \"EXT_texture_avif\";\n\n/**\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/blob/5cb7518cf9a1bfb8268320026961b21caf5a4aac/extensions/2.0/Vendor/EXT_texture_avif/README.md)\n * @experimental\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_texture_avif implements IGLTFExporterExtensionV2 {\n    public readonly name = NAME;\n\n    public enabled = true;\n\n    public required = true;\n\n    private _wasUsed = false;\n\n    public get wasUsed() {\n        return this._wasUsed;\n    }\n\n    private _exporter: GLTFExporter;\n\n    constructor(exporter: GLTFExporter) {\n        this._exporter = exporter;\n    }\n\n    public dispose() {}\n\n    public postExportTexture(_: string, textureInfo: BABYLON.GLTF2.ITextureInfo): void {\n        const texture = this._exporter._textures[textureInfo.index];\n        const imageIndex = texture.source;\n        if (imageIndex === undefined) {\n            return;\n        }\n\n        const image = this._exporter._images[imageIndex];\n        const sourceMimeType = image.mimeType || GetMimeType(image.uri!);\n        if (sourceMimeType !== ImageMimeType.AVIF) {\n            return;\n        }\n\n        texture.source = undefined;\n        texture.extensions ||= {};\n        texture.extensions[NAME] = {\n            source: imageIndex,\n        };\n\n        this._wasUsed = true;\n    }\n}\n\nGLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_texture_avif(exporter));\n","import { Mesh } from \"core/Meshes/mesh\";\r\nimport { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\n\r\n/**\r\n * Class for generating STL data from a Babylon scene.\r\n */\r\nexport class STLExport {\r\n    /**\r\n     * Exports the geometry of a Mesh array in .STL file format (ASCII)\r\n     * @param meshes list defines the mesh to serialize\r\n     * @param download triggers the automatic download of the file.\r\n     * @param fileName changes the downloads fileName.\r\n     * @param binary changes the STL to a binary type.\r\n     * @param isLittleEndian toggle for binary type exporter.\r\n     * @param doNotBakeTransform toggle if meshes transforms should be baked or not.\r\n     * @param supportInstancedMeshes toggle to export instanced Meshes. Enabling support for instanced meshes will override doNoBakeTransform as true\r\n     * @param exportIndividualMeshes toggle to export each mesh as an independent mesh. By default, all the meshes are combined into one mesh. This property has no effect when exporting in binary format\r\n     * @returns the STL as UTF8 string\r\n     */\r\n    public static CreateSTL(\r\n        meshes: (Mesh | InstancedMesh)[],\r\n        download: boolean = true,\r\n        fileName: string = \"stlmesh\",\r\n        binary: boolean = false,\r\n        isLittleEndian: boolean = true,\r\n        doNotBakeTransform: boolean = false,\r\n        supportInstancedMeshes: boolean = false,\r\n        exportIndividualMeshes: boolean = false\r\n    ): any {\r\n        //Binary support adapted from https://gist.github.com/paulkaplan/6d5f0ab2c7e8fdc68a61\r\n\r\n        const getFaceData = function (indices: any, vertices: any, i: number) {\r\n            const id = [indices[i] * 3, indices[i + 1] * 3, indices[i + 2] * 3];\r\n            const v = [\r\n                new Vector3(vertices[id[0]], vertices[id[0] + 2], vertices[id[0] + 1]),\r\n                new Vector3(vertices[id[1]], vertices[id[1] + 2], vertices[id[1] + 1]),\r\n                new Vector3(vertices[id[2]], vertices[id[2] + 2], vertices[id[2] + 1]),\r\n            ];\r\n            const p1p2 = v[0].subtract(v[1]);\r\n            const p3p2 = v[2].subtract(v[1]);\r\n            const n = Vector3.Cross(p3p2, p1p2).normalize();\r\n\r\n            return { v, n };\r\n        };\r\n\r\n        const writeVector = function (dataview: any, offset: number, vector: Vector3, isLittleEndian: boolean) {\r\n            offset = writeFloat(dataview, offset, vector.x, isLittleEndian);\r\n            offset = writeFloat(dataview, offset, vector.y, isLittleEndian);\r\n            return writeFloat(dataview, offset, vector.z, isLittleEndian);\r\n        };\r\n\r\n        const writeFloat = function (dataview: any, offset: number, value: number, isLittleEndian: boolean) {\r\n            dataview.setFloat32(offset, value, isLittleEndian);\r\n            return offset + 4;\r\n        };\r\n\r\n        const getVerticesData = function (mesh: InstancedMesh | Mesh) {\r\n            if (supportInstancedMeshes) {\r\n                let sourceMesh = mesh;\r\n                if (mesh instanceof InstancedMesh) {\r\n                    sourceMesh = mesh.sourceMesh;\r\n                }\r\n                const data = sourceMesh.getVerticesData(VertexBuffer.PositionKind, true, true);\r\n                if (!data) {\r\n                    return [];\r\n                }\r\n                const temp = Vector3.Zero();\r\n                let index;\r\n                for (index = 0; index < data.length; index += 3) {\r\n                    Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], mesh.computeWorldMatrix(true), temp).toArray(data, index);\r\n                }\r\n                return data;\r\n            } else {\r\n                return mesh.getVerticesData(VertexBuffer.PositionKind) || [];\r\n            }\r\n        };\r\n\r\n        if (supportInstancedMeshes) {\r\n            doNotBakeTransform = true;\r\n        }\r\n\r\n        let data: DataView | string = \"\";\r\n\r\n        let faceCount = 0;\r\n        let offset = 0;\r\n\r\n        if (binary) {\r\n            for (let i = 0; i < meshes.length; i++) {\r\n                const mesh = meshes[i];\r\n                const indices = mesh.getIndices();\r\n                faceCount += indices ? indices.length / 3 : 0;\r\n            }\r\n\r\n            const bufferSize = 84 + 50 * faceCount;\r\n            const buffer = new ArrayBuffer(bufferSize);\r\n            data = new DataView(buffer);\r\n\r\n            offset += 80;\r\n            data.setUint32(offset, faceCount, isLittleEndian);\r\n            offset += 4;\r\n        } else {\r\n            if (!exportIndividualMeshes) {\r\n                data = \"solid stlmesh\\r\\n\";\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n            if (!binary && exportIndividualMeshes) {\r\n                data += \"solid \" + mesh.name + \"\\r\\n\";\r\n            }\r\n            if (!doNotBakeTransform && mesh instanceof Mesh) {\r\n                mesh.bakeCurrentTransformIntoVertices();\r\n            }\r\n            const vertices = getVerticesData(mesh);\r\n            const indices = mesh.getIndices() || [];\r\n\r\n            for (let i = 0; i < indices.length; i += 3) {\r\n                const fd = getFaceData(indices, vertices, i);\r\n\r\n                if (binary) {\r\n                    offset = writeVector(data, offset, fd.n, isLittleEndian);\r\n                    offset = writeVector(data, offset, fd.v[0], isLittleEndian);\r\n                    offset = writeVector(data, offset, fd.v[1], isLittleEndian);\r\n                    offset = writeVector(data, offset, fd.v[2], isLittleEndian);\r\n                    offset += 2;\r\n                } else {\r\n                    data += \"\\tfacet normal \" + fd.n.x + \" \" + fd.n.y + \" \" + fd.n.z + \"\\r\\n\";\r\n                    data += \"\\t\\touter loop\\r\\n\";\r\n                    data += \"\\t\\t\\tvertex \" + fd.v[0].x + \" \" + fd.v[0].y + \" \" + fd.v[0].z + \"\\r\\n\";\r\n                    data += \"\\t\\t\\tvertex \" + fd.v[1].x + \" \" + fd.v[1].y + \" \" + fd.v[1].z + \"\\r\\n\";\r\n                    data += \"\\t\\t\\tvertex \" + fd.v[2].x + \" \" + fd.v[2].y + \" \" + fd.v[2].z + \"\\r\\n\";\r\n                    data += \"\\t\\tendloop\\r\\n\";\r\n                    data += \"\\tendfacet\\r\\n\";\r\n                }\r\n            }\r\n            if (!binary && exportIndividualMeshes) {\r\n                data += \"endsolid \" + name + \"\\r\\n\";\r\n            }\r\n        }\r\n\r\n        if (!binary && !exportIndividualMeshes) {\r\n            data += \"endsolid stlmesh\";\r\n        }\r\n\r\n        if (download) {\r\n            const a = document.createElement(\"a\");\r\n            const blob = new Blob([data], { type: \"application/octet-stream\" });\r\n            a.href = window.URL.createObjectURL(blob);\r\n            a.download = fileName + \".stl\";\r\n            a.click();\r\n        }\r\n\r\n        return data;\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Matrix, Vector2 } from \"core/Maths/math.vector\";\r\nimport type { Geometry } from \"core/Meshes/geometry\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { DumpTools } from \"core/Misc/dumpTools\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\nimport { IsNoopNode } from \"../exportUtils\";\r\nimport { GetTextureDataAsync } from \"core/Misc/textureTools\";\r\n\r\n/**\r\n * Ported from https://github.com/mrdoob/three.js/blob/master/examples/jsm/exporters/USDZExporter.js\r\n * Thanks a lot to the three.js team for their amazing work!\r\n */\r\n\r\n// FFlate access\r\ndeclare const fflate: any;\r\n\r\n/**\r\n * Options for the USDZ export\r\n */\r\nexport interface IUSDZExportOptions {\r\n    /**\r\n     * URL to load the fflate library from\r\n     */\r\n    fflateUrl?: string;\r\n    /**\r\n     * Include anchoring properties in the USDZ file\r\n     */\r\n    includeAnchoringProperties?: boolean;\r\n    /**\r\n     * Anchoring type (plane by default)\r\n     */\r\n    anchoringType?: string;\r\n    /**\r\n     * Plane anchoring alignment (horizontal by default)\r\n     */\r\n    planeAnchoringAlignment?: string;\r\n    /**\r\n     * Model file name (model.usda by default)\r\n     */\r\n    modelFileName?: string;\r\n    /**\r\n     * Precision to use for number (5 by default)\r\n     */\r\n    precision?: number;\r\n    /**\r\n     * Export the camera (false by default)\r\n     */\r\n    exportCamera?: boolean;\r\n    /**\r\n     * Camera sensor width (35 by default)\r\n     */\r\n    cameraSensorWidth?: number;\r\n}\r\n\r\nfunction BuildHeader() {\r\n    return `#usda 1.0\r\n    (\r\n        customLayerData = {\r\n            string creator = \"Babylon.js USDZExportAsync\"\r\n        }\r\n        defaultPrim = \"Root\"\r\n        metersPerUnit = 1\r\n        upAxis = \"Y\"\r\n    )`;\r\n}\r\n\r\nfunction BuildRootAndSceneStart(options: IUSDZExportOptions) {\r\n    const alignment =\r\n        options.includeAnchoringProperties === true\r\n            ? `\r\n\t\ttoken preliminary:anchoring:type = \"${options.anchoringType}\"\r\n\t\ttoken preliminary:planeAnchoring:alignment = \"${options.planeAnchoringAlignment}\"`\r\n            : \"\";\r\n    return `def Xform \"Root\"\r\n    {\r\n        def Scope \"Scenes\" (\r\n            kind = \"sceneLibrary\"\r\n        )\r\n        {\r\n            def Xform \"Scene\" (\r\n                customData = {\r\n                    bool preliminary_collidesWithEnvironment = 0\r\n                    string sceneName = \"Scene\"\r\n                }\r\n                sceneName = \"Scene\"\r\n            )\r\n            {${alignment}\r\n            `;\r\n}\r\n\r\nfunction BuildSceneEnd() {\r\n    return `\r\n            }\r\n        }`;\r\n}\r\n\r\nfunction BuildRootEnd() {\r\n    return `\r\n    }`;\r\n}\r\n\r\nfunction BuildMeshVertexCount(geometry: Geometry) {\r\n    const count = geometry.getIndices()?.length ? geometry.getTotalIndices() : geometry.getTotalVertices();\r\n\r\n    return Array(count / 3)\r\n        .fill(3)\r\n        .join(\", \");\r\n}\r\n\r\nfunction BuildMeshVertexIndices(geometry: Geometry) {\r\n    const indices = geometry.getIndices();\r\n    const count = indices?.length ?? geometry.getTotalVertices();\r\n\r\n    const array: number[] = [];\r\n    if (indices !== null) {\r\n        for (let i = 0; i < count; i++) {\r\n            array.push(indices[i]);\r\n        }\r\n    } else {\r\n        for (let i = 0; i < count; i++) {\r\n            array.push(i);\r\n        }\r\n    }\r\n\r\n    return array.join(\", \");\r\n}\r\n\r\nfunction BuildVector3Array(attribute: FloatArray, options: IUSDZExportOptions, stride = 3, convertToRightHanded = false) {\r\n    const array: string[] = [];\r\n\r\n    for (let i = 0; i < attribute.length / stride; i++) {\r\n        const x = attribute[i * stride] * (convertToRightHanded ? -1 : 1);\r\n        const y = attribute[i * stride + 1];\r\n        const z = attribute[i * stride + 2];\r\n\r\n        array.push(`(${x.toPrecision(options.precision)}, ${y.toPrecision(options.precision)}, ${z.toPrecision(options.precision)})`);\r\n    }\r\n\r\n    return array.join(\", \");\r\n}\r\n\r\nfunction BuildVector2Array(attribute: FloatArray, options: IUSDZExportOptions) {\r\n    const array: string[] = [];\r\n\r\n    for (let i = 0; i < attribute.length / 2; i++) {\r\n        const x = attribute[i * 2];\r\n        const y = attribute[i * 2 + 1];\r\n\r\n        array.push(`(${x.toPrecision(options.precision)}, ${(1 - y).toPrecision(options.precision)})`);\r\n    }\r\n\r\n    return array.join(\", \");\r\n}\r\n\r\nfunction BuildAdditionalAttributes(geometry: Geometry, options: IUSDZExportOptions) {\r\n    let string = \"\";\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n        const id = i > 0 ? i : \"\";\r\n        const uvAttribute = geometry.getVerticesData(VertexBuffer.UVKind + (id ? id + 1 : \"\")); // UV names go like \"uv\", \"uv2\", \"uv3\", etc.\r\n\r\n        if (uvAttribute) {\r\n            string += `\r\n\t\ttexCoord2f[] primvars:st${id} = [${BuildVector2Array(uvAttribute, options)}] (\r\n\t\t\tinterpolation = \"vertex\"\r\n\t\t)`;\r\n        }\r\n    }\r\n\r\n    // vertex colors\r\n\r\n    const colorAttribute = geometry.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n    if (colorAttribute) {\r\n        string += `\r\n\tcolor3f[] primvars:displayColor = [${BuildVector3Array(colorAttribute, options, colorAttribute.length / geometry.getTotalVertices())}] (\r\n\t\tinterpolation = \"vertex\"\r\n\t\t)`;\r\n    }\r\n\r\n    return string;\r\n}\r\n\r\nfunction BuildMesh(geometry: Geometry, options: IUSDZExportOptions, windingOrder: string, convertToRightHanded: boolean) {\r\n    const name = \"Geometry\";\r\n    const position = geometry.getVerticesData(VertexBuffer.PositionKind);\r\n    const normal = geometry.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n    if (!position || !normal) {\r\n        return;\r\n    }\r\n\r\n    return `\r\n\tdef Mesh \"${name}\"\r\n\t{\r\n        uniform token orientation = \"${windingOrder}\"\r\n\t\tint[] faceVertexCounts = [${BuildMeshVertexCount(geometry)}]\r\n\t\tint[] faceVertexIndices = [${BuildMeshVertexIndices(geometry)}]\r\n\t\tnormal3f[] normals = [${BuildVector3Array(normal, options, undefined, convertToRightHanded)}] (\r\n\t\t\tinterpolation = \"vertex\"\r\n\t\t)\r\n\t\tpoint3f[] points = [${BuildVector3Array(position, options, undefined, convertToRightHanded)}]\r\n        ${BuildAdditionalAttributes(geometry, options)}\r\n\t\tuniform token subdivisionScheme = \"none\"\r\n\t}\r\n`;\r\n}\r\n\r\nfunction BuildMeshObject(geometry: Geometry, options: IUSDZExportOptions, windingOrder: string, convertToRightHanded: boolean) {\r\n    const meshObject = BuildMesh(geometry, options, windingOrder, convertToRightHanded);\r\n    return `\r\n        def \"Geometry\"\r\n        {\r\n        ${meshObject}\r\n        }\r\n        `;\r\n}\r\n\r\nfunction BuildUSDFileAsString(dataToInsert: string) {\r\n    let output = BuildHeader();\r\n    output += dataToInsert;\r\n    return fflate.strToU8(output);\r\n}\r\n\r\nfunction BuildMatrix(matrix: Matrix) {\r\n    const array = matrix.m as number[];\r\n\r\n    return `( ${BuildMatrixRow(array, 0)}, ${BuildMatrixRow(array, 4)}, ${BuildMatrixRow(array, 8)}, ${BuildMatrixRow(array, 12)} )`;\r\n}\r\n\r\nfunction BuildMatrixRow(array: number[], offset: number) {\r\n    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\r\n}\r\n\r\nfunction BuildXform(mesh: Mesh, matrix: Matrix) {\r\n    const name = \"Object_\" + mesh.uniqueId;\r\n    const transform = BuildMatrix(matrix);\r\n\r\n    return `def Xform \"${name}\" (\r\n\tprepend references = @./geometries/Geometry_${mesh.geometry!.uniqueId}.usda@</Geometry>\r\n\tprepend apiSchemas = [\"MaterialBindingAPI\"]\r\n)\r\n{\r\n\tmatrix4d xformOp:transform = ${transform}\r\n\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\t\r\n\r\n    rel material:binding = </Root/Materials/Material_${mesh.material!.uniqueId}>\r\n}\r\n\r\n`;\r\n}\r\n\r\nfunction BuildMaterials(materials: { [key: string]: Material }, textureToExports: { [key: string]: BaseTexture }, options: IUSDZExportOptions) {\r\n    const array: string[] = [];\r\n\r\n    for (const uuid in materials) {\r\n        const material = materials[uuid];\r\n\r\n        array.push(BuildMaterial(material, textureToExports, options));\r\n    }\r\n\r\n    return `\r\n    def \"Materials\"\r\n{\r\n${array.join(\"\")}\r\n}\r\n\r\n`;\r\n}\r\n\r\nfunction BuildWrapping(wrapping: number) {\r\n    switch (wrapping) {\r\n        case Constants.TEXTURE_CLAMP_ADDRESSMODE:\r\n            return \"clamp\";\r\n        case Constants.TEXTURE_MIRROR_ADDRESSMODE:\r\n            return \"mirror\";\r\n        case Constants.TEXTURE_WRAP_ADDRESSMODE:\r\n        default:\r\n            return \"repeat\";\r\n    }\r\n}\r\n\r\nfunction BuildColor4(color: Color3) {\r\n    return `(${color.r}, ${color.g}, ${color.b}, 1.0)`;\r\n}\r\n\r\nfunction BuildVector2(vector: Vector2) {\r\n    return `(${vector.x}, ${vector.y})`;\r\n}\r\n\r\nfunction BuildColor(color: Color3) {\r\n    return `(${color.r}, ${color.g}, ${color.b})`;\r\n}\r\n\r\nfunction BuildTexture(\r\n    texture: Texture,\r\n    material: Material,\r\n    mapType: string,\r\n    color: Nullable<Color3>,\r\n    textureToExports: { [key: string]: BaseTexture },\r\n    options: IUSDZExportOptions\r\n) {\r\n    const id = texture.getInternalTexture()!.uniqueId + \"_\" + texture.invertY;\r\n\r\n    textureToExports[id] = texture;\r\n\r\n    const uv = texture.coordinatesIndex > 0 ? \"st\" + texture.coordinatesIndex : \"st\";\r\n    const repeat = new Vector2(texture.uScale, texture.vScale);\r\n    const offset = new Vector2(texture.uOffset, texture.vOffset);\r\n    const rotation = texture.wAng;\r\n\r\n    // rotation is around the wrong point. after rotation we need to shift offset again so that we're rotating around the right spot\r\n    const xRotationOffset = Math.sin(rotation);\r\n    const yRotationOffset = Math.cos(rotation);\r\n\r\n    // texture coordinates start in the opposite corner, need to correct\r\n    offset.y = 1 - offset.y - repeat.y;\r\n\r\n    offset.x += xRotationOffset * repeat.x;\r\n    offset.y += (1 - yRotationOffset) * repeat.y;\r\n\r\n    return `\r\n    def Shader \"PrimvarReader_${mapType}\"\r\n    {\r\n        uniform token info:id = \"UsdPrimvarReader_float2\"\r\n        float2 inputs:fallback = (0.0, 0.0)\r\n        token inputs:varname = \"${uv}\"\r\n        float2 outputs:result\r\n    }\r\n\r\n    def Shader \"Transform2d_${mapType}\"\r\n    {\r\n        uniform token info:id = \"UsdTransform2d\"\r\n        token inputs:in.connect = </Root/Materials/Material_${material.uniqueId}/PrimvarReader_${mapType}.outputs:result>\r\n        float inputs:rotation = ${(rotation * (180 / Math.PI)).toFixed(options.precision)}\r\n        float2 inputs:scale = ${BuildVector2(repeat)}\r\n        float2 inputs:translation = ${BuildVector2(offset)}\r\n        float2 outputs:result\r\n    }\r\n\r\n    def Shader \"Texture_${texture.uniqueId}_${mapType}\"\r\n    {\r\n        uniform token info:id = \"UsdUVTexture\"\r\n        asset inputs:file = @textures/Texture_${id}.png@\r\n        float2 inputs:st.connect = </Root/Materials/Material_${material.uniqueId}/Transform2d_${mapType}.outputs:result>\r\n        ${color ? \"float4 inputs:scale = \" + BuildColor4(color) : \"\"}\r\n        token inputs:sourceColorSpace = \"${texture.gammaSpace ? \"sRGB\" : \"raw\"}\"\r\n        token inputs:wrapS = \"${BuildWrapping(texture.wrapU)}\"\r\n        token inputs:wrapT = \"${BuildWrapping(texture.wrapV)}\"\r\n        float outputs:r\r\n        float outputs:g\r\n        float outputs:b\r\n        float3 outputs:rgb\r\n        ${material.needAlphaBlending() || material.needAlphaTesting() ? \"float outputs:a\" : \"\"}\r\n    }`;\r\n}\r\n\r\nfunction ExtractTextureInformations(material: Material) {\r\n    const defaults = {\r\n        diffuseMap: null,\r\n        diffuse: null,\r\n        alphaCutOff: 0,\r\n        emissiveMap: null,\r\n        emissive: null,\r\n        normalMap: null,\r\n        roughnessMap: null,\r\n        roughnessChannel: \"a\",\r\n        roughness: 0,\r\n        metalnessMap: null,\r\n        metalnessChannel: \"r\",\r\n        metalness: 0,\r\n        aoMap: null,\r\n        aoMapChannel: \"rgb\",\r\n        aoMapIntensity: 0,\r\n        alphaMap: null,\r\n        ior: 1,\r\n        clearCoatEnabled: false,\r\n        clearCoat: 0,\r\n        clearCoatMap: null,\r\n        clearCoatRoughness: 0,\r\n        clearCoatRoughnessMap: null,\r\n    };\r\n\r\n    if (material instanceof StandardMaterial) {\r\n        return {\r\n            ...defaults,\r\n            diffuseMap: material.diffuseTexture,\r\n            diffuse: material.diffuseColor,\r\n            alphaCutOff: material.alphaCutOff,\r\n            emissiveMap: material.emissiveTexture,\r\n            emissive: material.emissiveColor,\r\n            roughness: 1,\r\n            alphaMap: material.opacityTexture,\r\n        };\r\n    }\r\n    if (material instanceof PBRBaseMaterial) {\r\n        return {\r\n            ...defaults,\r\n            diffuseMap: material._albedoTexture,\r\n            diffuse: material._albedoColor,\r\n            alphaCutOff: material._alphaCutOff,\r\n            emissiveMap: material._emissiveTexture,\r\n            emissive: material._emissiveColor,\r\n            normalMap: material._bumpTexture,\r\n            roughnessMap: material._metallicTexture,\r\n            roughnessChannel: material._useRoughnessFromMetallicTextureAlpha ? \"a\" : \"g\",\r\n            roughness: material._roughness ?? 1,\r\n            metalnessMap: material._metallicTexture,\r\n            metalnessChannel: material._useMetallnessFromMetallicTextureBlue ? \"b\" : \"r\",\r\n            metalness: material._metallic ?? 0,\r\n            aoMap: material._ambientTexture,\r\n            aoMapChannel: material._useAmbientInGrayScale ? \"r\" : \"rgb\",\r\n            aoMapIntensity: material._ambientTextureStrength,\r\n            alphaMap: material._opacityTexture,\r\n            ior: material.subSurface.indexOfRefraction,\r\n            clearCoatEnabled: material.clearCoat.isEnabled,\r\n            clearCoat: material.clearCoat.intensity,\r\n            clearCoatMap: material.clearCoat.texture,\r\n            clearCoatRoughness: material.clearCoat.roughness,\r\n            clearCoatRoughnessMap: material.clearCoat.useRoughnessFromMainTexture ? material.clearCoat.texture : material.clearCoat.textureRoughness,\r\n        };\r\n    }\r\n    return defaults;\r\n}\r\n\r\nfunction BuildMaterial(material: Material, textureToExports: { [key: string]: BaseTexture }, options: IUSDZExportOptions) {\r\n    // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\r\n\r\n    const pad = \"\t\t\t\";\r\n    const inputs = [];\r\n    const samplers = [];\r\n\r\n    const {\r\n        diffuseMap,\r\n        diffuse,\r\n        alphaCutOff,\r\n        emissiveMap,\r\n        emissive,\r\n        normalMap,\r\n        roughnessMap,\r\n        roughnessChannel,\r\n        roughness,\r\n        metalnessMap,\r\n        metalnessChannel,\r\n        metalness,\r\n        aoMap,\r\n        aoMapChannel,\r\n        aoMapIntensity,\r\n        alphaMap,\r\n        ior,\r\n        clearCoatEnabled,\r\n        clearCoat,\r\n        clearCoatMap,\r\n        clearCoatRoughness,\r\n        clearCoatRoughnessMap,\r\n    } = ExtractTextureInformations(material);\r\n\r\n    if (diffuseMap !== null) {\r\n        inputs.push(`${pad}color3f inputs:diffuseColor.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${diffuseMap.uniqueId}_diffuse.outputs:rgb>`);\r\n\r\n        if (material.needAlphaBlending()) {\r\n            inputs.push(`${pad}float inputs:opacity.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${diffuseMap.uniqueId}_diffuse.outputs:a>`);\r\n        } else if (material.needAlphaTesting()) {\r\n            inputs.push(`${pad}float inputs:opacity.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${diffuseMap.uniqueId}_diffuse.outputs:a>`);\r\n            inputs.push(`${pad}float inputs:opacityThreshold = ${alphaCutOff}`);\r\n        }\r\n\r\n        samplers.push(BuildTexture(diffuseMap as Texture, material, \"diffuse\", diffuse, textureToExports, options));\r\n    } else {\r\n        inputs.push(`${pad}color3f inputs:diffuseColor = ${BuildColor(diffuse || Color3.White())}`);\r\n    }\r\n\r\n    if (emissiveMap !== null) {\r\n        inputs.push(`${pad}color3f inputs:emissiveColor.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${emissiveMap.uniqueId}_emissive.outputs:rgb>`);\r\n\r\n        samplers.push(BuildTexture(emissiveMap as Texture, material, \"emissive\", emissive, textureToExports, options));\r\n    } else if (emissive && emissive.toLuminance() > 0) {\r\n        inputs.push(`${pad}color3f inputs:emissiveColor = ${BuildColor(emissive)}`);\r\n    }\r\n\r\n    if (normalMap !== null) {\r\n        inputs.push(`${pad}normal3f inputs:normal.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${normalMap.uniqueId}_normal.outputs:rgb>`);\r\n\r\n        samplers.push(BuildTexture(normalMap as Texture, material, \"normal\", null, textureToExports, options));\r\n    }\r\n\r\n    if (aoMap !== null) {\r\n        inputs.push(`${pad}float inputs:occlusion.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${aoMap.uniqueId}_occlusion.outputs:${aoMapChannel}>`);\r\n\r\n        samplers.push(BuildTexture(aoMap as Texture, material, \"occlusion\", new Color3(aoMapIntensity, aoMapIntensity, aoMapIntensity), textureToExports, options));\r\n    }\r\n\r\n    if (roughnessMap !== null) {\r\n        inputs.push(\r\n            `${pad}float inputs:roughness.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${roughnessMap.uniqueId}_roughness.outputs:${roughnessChannel}>`\r\n        );\r\n\r\n        samplers.push(BuildTexture(roughnessMap as Texture, material, \"roughness\", new Color3(roughness, roughness, roughness), textureToExports, options));\r\n    } else {\r\n        inputs.push(`${pad}float inputs:roughness = ${roughness}`);\r\n    }\r\n\r\n    if (metalnessMap !== null) {\r\n        inputs.push(`${pad}float inputs:metallic.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${metalnessMap.uniqueId}_metallic.outputs:${metalnessChannel}>`);\r\n\r\n        samplers.push(BuildTexture(metalnessMap as Texture, material, \"metallic\", new Color3(metalness, metalness, metalness), textureToExports, options));\r\n    } else {\r\n        inputs.push(`${pad}float inputs:metallic = ${metalness}`);\r\n    }\r\n\r\n    if (alphaMap !== null) {\r\n        inputs.push(`${pad}float inputs:opacity.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${alphaMap.uniqueId}_opacity.outputs:r>`);\r\n        inputs.push(`${pad}float inputs:opacityThreshold = 0.0001`);\r\n\r\n        samplers.push(BuildTexture(alphaMap as Texture, material, \"opacity\", null, textureToExports, options));\r\n    } else {\r\n        inputs.push(`${pad}float inputs:opacity = ${material.alpha}`);\r\n    }\r\n\r\n    if (clearCoatEnabled) {\r\n        if (clearCoatMap !== null) {\r\n            inputs.push(`${pad}float inputs:clearcoat.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${clearCoatMap.uniqueId}_clearcoat.outputs:r>`);\r\n            samplers.push(BuildTexture(clearCoatMap as Texture, material, \"clearcoat\", new Color3(clearCoat, clearCoat, clearCoat), textureToExports, options));\r\n        } else {\r\n            inputs.push(`${pad}float inputs:clearcoat = ${clearCoat}`);\r\n        }\r\n\r\n        if (clearCoatRoughnessMap !== null) {\r\n            inputs.push(\r\n                `${pad}float inputs:clearcoatRoughness.connect = </Root/Materials/Material_${material.uniqueId}/Texture_${clearCoatRoughnessMap.uniqueId}_clearcoatRoughness.outputs:g>`\r\n            );\r\n            samplers.push(\r\n                BuildTexture(\r\n                    clearCoatRoughnessMap as Texture,\r\n                    material,\r\n                    \"clearcoatRoughness\",\r\n                    new Color3(clearCoatRoughness, clearCoatRoughness, clearCoatRoughness),\r\n                    textureToExports,\r\n                    options\r\n                )\r\n            );\r\n        } else {\r\n            inputs.push(`${pad}float inputs:clearcoatRoughness = ${clearCoatRoughness}`);\r\n        }\r\n    }\r\n\r\n    inputs.push(`${pad}float inputs:ior = ${ior}`);\r\n\r\n    return `\r\n\tdef Material \"Material_${material.uniqueId}\"\r\n\t{\r\n\t\tdef Shader \"PreviewSurface\"\r\n\t\t{\r\n\t\t\tuniform token info:id = \"UsdPreviewSurface\"\r\n${inputs.join(\"\\n\")}\r\n\t\t\tint inputs:useSpecularWorkflow = 0\r\n\t\t\ttoken outputs:surface\r\n\t\t}\r\n\r\n\t\ttoken outputs:surface.connect = </Root/Materials/Material_${material.uniqueId}/PreviewSurface.outputs:surface>\r\n\r\n${samplers.join(\"\\n\")}\r\n\r\n\t}\r\n`;\r\n}\r\n\r\nfunction BuildCamera(camera: Camera, options: IUSDZExportOptions) {\r\n    const name = \"Camera_\" + camera.uniqueId;\r\n    const matrix = Matrix.RotationY(Math.PI).multiply(camera.getWorldMatrix()); // work towards positive z\r\n\r\n    const transform = BuildMatrix(matrix);\r\n\r\n    if (camera.mode === Constants.ORTHOGRAPHIC_CAMERA) {\r\n        return `def Camera \"${name}\"\r\n\t\t{\r\n\t\t\tmatrix4d xformOp:transform = ${transform}\r\n\t\t\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\r\n\r\n\t\t\tfloat2 clippingRange = (${camera.minZ.toPrecision(options.precision)}, ${camera.maxZ.toPrecision(options.precision)})\r\n\t\t\tfloat horizontalAperture = ${((Math.abs(camera.orthoLeft || 1) + Math.abs(camera.orthoRight || 1)) * 10).toPrecision(options.precision)}\r\n\t\t\tfloat verticalAperture = ${((Math.abs(camera.orthoTop || 1) + Math.abs(camera.orthoBottom || 1)) * 10).toPrecision(options.precision)}\r\n\t\t\ttoken projection = \"orthographic\"\r\n\t\t}\r\n\t\r\n\t`;\r\n    } else {\r\n        const aspect = camera.getEngine().getAspectRatio(camera);\r\n        const sensorwidth = options.cameraSensorWidth || 35;\r\n\r\n        return `def Camera \"${name}\"\r\n\t\t{\r\n\t\t\tmatrix4d xformOp:transform = ${transform}\r\n\t\t\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\r\n\r\n\t\t\tfloat2 clippingRange = (${camera.minZ.toPrecision(options.precision)}, ${camera.maxZ.toPrecision(options.precision)})\r\n\t\t\tfloat focalLength = ${(sensorwidth / (2 * Math.tan(camera.fov * 0.5))).toPrecision(options.precision)}\r\n            token projection = \"perspective\"\r\n\t\t\tfloat horizontalAperture = ${(sensorwidth * aspect).toPrecision(options.precision)}\r\n\t\t\tfloat verticalAperture = ${(sensorwidth / aspect).toPrecision(options.precision)}            \r\n\t\t}\r\n\t\r\n\t`;\r\n    }\r\n}\r\n\r\nfunction ExtractMeshInformations(mesh: Mesh) {\r\n    mesh.computeWorldMatrix(true);\r\n    const matrix = mesh.getWorldMatrix().clone();\r\n    const sceneIsRightHanded = mesh.getScene().useRightHandedSystem;\r\n    let sideOrientation = mesh.material?._getEffectiveOrientation(mesh) ?? mesh.sideOrientation;\r\n    let convertToRightHanded = !sceneIsRightHanded;\r\n\r\n    // Search for a root conversion node from the glTF loader in the mesh's ancestors.\r\n    let current = mesh.parent;\r\n    while (current) {\r\n        if (IsNoopNode(current, sceneIsRightHanded) && current.parent === null) {\r\n            if (!sceneIsRightHanded) {\r\n                // If it's a RH->LH node, cancel out its inversion effect on the mesh's matrix and winding order.\r\n                matrix.multiplyToRef(current.getWorldMatrix().invert(), matrix);\r\n                sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n            }\r\n            convertToRightHanded = false;\r\n            break;\r\n        }\r\n        current = current.parent;\r\n    }\r\n\r\n    if (matrix.determinant() < 0) {\r\n        // RealityKit doesn't seem to automatically flip faces of a mesh with negative scale, like other engines do (including us).\r\n        Tools.Warn(`Mesh ${mesh.name} has a negative scale, which may look incorrect in destinations like QuickLook.`);\r\n    }\r\n\r\n    return {\r\n        matrix,\r\n        windingOrder: sideOrientation === Material.ClockWiseSideOrientation ? \"leftHanded\" : \"rightHanded\",\r\n        convertToRightHanded,\r\n    };\r\n}\r\n\r\n/**\r\n *\r\n * @param scene scene to export\r\n * @param options options to configure the export\r\n * @param meshPredicate predicate to filter the meshes to export\r\n * @returns a uint8 array containing the USDZ file\r\n * @see [Simple sphere](https://playground.babylonjs.com/#H2G5XW#6)\r\n * @see [Red sphere](https://playground.babylonjs.com/#H2G5XW#7)\r\n * @see [Boombox](https://playground.babylonjs.com/#5N3RWK#5)\r\n */\r\nexport async function USDZExportAsync(scene: Scene, options: Partial<IUSDZExportOptions>, meshPredicate?: (m: Mesh) => boolean): Promise<Uint8Array> {\r\n    const localOptions = {\r\n        fflateUrl: \"https://unpkg.com/fflate@0.8.2\",\r\n        includeAnchoringProperties: true,\r\n        anchoringType: \"plane\",\r\n        planeAnchoringAlignment: \"horizontal\",\r\n        modelFileName: \"model.usda\",\r\n        precision: 5,\r\n        exportCamera: false,\r\n        cameraSensorWidth: 35,\r\n        ...options,\r\n    };\r\n\r\n    // Get the fflate library\r\n    if (typeof fflate === \"undefined\") {\r\n        await Tools.LoadScriptAsync(localOptions.fflateUrl);\r\n    }\r\n\r\n    // Start the export\r\n    const files: { [key: string]: any } = {};\r\n\r\n    // model file should be first in USDZ archive so we init it here\r\n    files[localOptions.modelFileName] = null;\r\n\r\n    let output = BuildHeader();\r\n    output += BuildRootAndSceneStart(localOptions);\r\n\r\n    const materialToExports: { [key: string]: Material } = {};\r\n\r\n    // Meshes\r\n    for (const abstractMesh of scene.meshes) {\r\n        if (abstractMesh.getTotalVertices() === 0) {\r\n            continue;\r\n        }\r\n        const mesh = abstractMesh as Mesh;\r\n        const geometry = mesh.geometry;\r\n        const material = mesh.material;\r\n\r\n        if (!material || !geometry || (meshPredicate && !meshPredicate(mesh))) {\r\n            continue;\r\n        }\r\n\r\n        const supportedMaterials = [\"StandardMaterial\", \"PBRMaterial\", \"PBRMetallicRoughnessMaterial\"];\r\n\r\n        if (supportedMaterials.indexOf(material.getClassName()) !== -1) {\r\n            const geometryFileName = \"geometries/Geometry_\" + geometry.uniqueId + \".usda\";\r\n            const { matrix, windingOrder, convertToRightHanded } = ExtractMeshInformations(mesh);\r\n\r\n            if (!(geometryFileName in files)) {\r\n                const meshObject = BuildMeshObject(geometry, localOptions, windingOrder, convertToRightHanded);\r\n                files[geometryFileName] = BuildUSDFileAsString(meshObject);\r\n            }\r\n\r\n            if (!(material.uniqueId in materialToExports)) {\r\n                materialToExports[material.uniqueId] = material;\r\n            }\r\n\r\n            output += BuildXform(mesh, matrix);\r\n        } else {\r\n            Tools.Warn(\"USDZExportAsync does not support this material type: \" + material.getClassName());\r\n        }\r\n    }\r\n\r\n    // Camera\r\n    if (scene.activeCamera && localOptions.exportCamera) {\r\n        output += BuildCamera(scene.activeCamera, localOptions);\r\n    }\r\n\r\n    // Close scene\r\n    output += BuildSceneEnd();\r\n\r\n    // Materials\r\n    const textureToExports: { [key: string]: BaseTexture } = {};\r\n    output += BuildMaterials(materialToExports, textureToExports, localOptions);\r\n\r\n    // Close root\r\n    output += BuildRootEnd();\r\n\r\n    // Compress\r\n    files[localOptions.modelFileName] = fflate.strToU8(output);\r\n\r\n    // Textures\r\n    for (const id in textureToExports) {\r\n        const texture = textureToExports[id];\r\n\r\n        const size = texture.getSize();\r\n        // eslint-disable-next-line no-await-in-loop\r\n        const textureData = await GetTextureDataAsync(texture);\r\n\r\n        // eslint-disable-next-line no-await-in-loop\r\n        const fileContent = await DumpTools.DumpDataAsync(size.width, size.height, textureData, \"image/png\", undefined, false, true);\r\n\r\n        files[`textures/Texture_${id}.png`] = new Uint8Array(fileContent as ArrayBuffer).slice(); // This is to avoid getting a link and not a copy\r\n    }\r\n\r\n    // 64 byte alignment\r\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\r\n\r\n    let offset = 0;\r\n\r\n    for (const filename in files) {\r\n        const file = files[filename];\r\n        if (!file) {\r\n            continue;\r\n        }\r\n        const headerSize = 34 + filename.length;\r\n\r\n        offset += headerSize;\r\n\r\n        const offsetMod64 = offset & 63;\r\n\r\n        if (offsetMod64 !== 4) {\r\n            const padLength = 64 - offsetMod64;\r\n            const padding = new Uint8Array(padLength);\r\n\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            files[filename] = [file, { extra: { 12345: padding } }];\r\n        }\r\n\r\n        offset = file.length;\r\n    }\r\n\r\n    return fflate.zipSync(files, { level: 0 });\r\n}\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as Exporters from \"serializers/glTF/glTFFileExporter\";\r\nimport * as Datas from \"serializers/glTF/2.0/glTFData\";\r\nimport * as Serializers from \"serializers/glTF/2.0/glTFSerializer\";\r\nimport * as Extensions from \"serializers/glTF/2.0/Extensions/index\";\r\nimport * as GLTF2 from \"serializers/glTF/2.0/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    const BABYLON = (<any>globalObject).BABYLON;\r\n    BABYLON.GLTF2 = BABYLON.GLTF2 || {};\r\n    BABYLON.GLTF2.Exporter = BABYLON.GLTF2.Exporter || {};\r\n    BABYLON.GLTF2.Exporter.Extensions = BABYLON.GLTF2.Exporter.Extensions || {};\r\n\r\n    const keys = [];\r\n    for (const key in Exporters) {\r\n        BABYLON[key] = (<any>Exporters)[key];\r\n        keys.push(key);\r\n    }\r\n    for (const key in Datas) {\r\n        BABYLON[key] = (<any>Datas)[key];\r\n        keys.push(key);\r\n    }\r\n    for (const key in Serializers) {\r\n        BABYLON[key] = (<any>Serializers)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (const key in Extensions) {\r\n        BABYLON.GLTF2.Exporter.Extensions[key] = (<any>Extensions)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (const key in GLTF2) {\r\n        // Prevent Reassignment.\r\n        if (keys.indexOf(key) > -1) {\r\n            continue;\r\n        }\r\n\r\n        BABYLON.GLTF2.Exporter[key] = (<any>GLTF2)[key];\r\n    }\r\n}\r\n\r\nexport * from \"serializers/glTF/glTFFileExporter\";\r\nexport * from \"serializers/glTF/2.0/index\";\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as Serializers from \"serializers/OBJ/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (const serializer in Serializers) {\r\n        (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n    }\r\n}\r\n\r\nexport * from \"serializers/OBJ/index\";\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as Serializers from \"serializers/stl/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (const serializer in Serializers) {\r\n        (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n    }\r\n}\r\n\r\nexport * from \"serializers/stl/index\";\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as Serializers from \"serializers/USDZ/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (const serializer in Serializers) {\r\n        (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n    }\r\n}\r\n\r\nexport * from \"serializers/USDZ/index\";\r\n","import * as serializers from \"@lts/serializers/legacy/legacy\";\r\nexport { serializers };\r\nexport default serializers;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__597__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","OBJ","meshes","materials","matlibname","globalposition","output","v","textureV","push","j","length","mesh","objectName","name","inverseTransform","transform","computeWorldMatrix","Matrix","invertToRef","bakeTransformIntoVertices","mat","material","id","geometry","trunkVerts","getVerticesData","trunkNormals","trunkUV","trunkFaces","getIndices","currentV","currentTextureV","handednessSign","getScene","useRightHandedSystem","i","blanks","defaultMaterial","_getEffectiveOrientation","Material","ClockWiseSideOrientation","offset1","offset2","indices","String","textureIndices","facePositions","faceUVs","faceNormals","Tools","Warn","join","MTL","m","specularPower","toFixed","alpha","ambientColor","b","diffuseColor","specularColor","emissiveColor","ambientTexture","diffuseTexture","specularTexture","bumpTexture","opacityTexture","__IGLTFExporterExtension","files","downloadFiles","blob","Blob","type","GetMimeType","Download","__assign","assign","t","s","n","arguments","p","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","result","done","then","__generator","body","f","y","_","label","sent","trys","ops","create","Iterator","verb","iterator","op","TypeError","pop","__spreadArray","to","from","pack","ar","l","Array","slice","concat","SuppressedError","Epsilon","DielectricSpecular","Color3","MaxSpecularPower","White","Black","GetCachedImageAsync","babylonTexture","internalTexture","getInternalTexture","source","invertY","buffer","_buffer","mimeType","LoadFileAsync","url","data","ArrayBuffer","isView","byteOffset","byteLength","arrayBuffer","HTMLImageElement","src","_SolveMetallic","diffuse","specular","oneMinusSpecularStrength","a","Scalar","Clamp","Math","sqrt","_ConvertToGLTFPBRMetallicRoughness","babylonStandardMaterial","toLinearSpace","getEngine","useExactSrgbConversions","scale","opacity","roughness","SpecularPowerToRoughness","baseColorFactor","metallicFactor","roughnessFactor","SetAlphaMode","glTFMaterial","babylonMaterial","needAlphaBlending","alphaMode","needAlphaTesting","alphaCutoff","alphaCutOff","CreateWhiteTexture","width","height","scene","Uint8Array","RawTexture","CreateRGBATexture","ConvertPixelArrayToFloat32","pixels","Float32Array","Error","_exporter","_textureMap","Map","_internalTextureToImage","getTextureInfo","exportStandardMaterialAsync","hasUVs","pbrMetallicRoughness","backFaceCulling","twoSidedLighting","doubleSided","promises","exportTextureAsync","textureInfo","baseColorTexture","normalTexture","level","emissiveTexture","emissiveFactor","occlusionTexture","index","_materialNeedsUVsSet","add","all","Constants","ALPHA_COMBINE","toString","equalsWithEpsilon","asArray","_finishMaterialAsync","_materials","textures","_extensionsPostExportMaterialAdditionalTextures","texture","_extensionsPostExportMaterialAsync","_getImageDataAsync","DumpTools","DumpDataAsync","_resizeTexturesToSameDimensions","texture1","texture2","resizedTexture1","resizedTexture2","texture1Size","getSize","texture2Size","Texture","TextureTools","CreateResizedCopy","_convertSpecularGlossinessTexturesToMetallicRoughnessAsync","specularGlossinessTexture","factors","resizedTextures","diffuseSize","diffuseBuffer","specularGlossinessBuffer","readPixels","diffusePixels","specularPixels","metallicRoughnessBuffer","baseColorBuffer","maxBaseColor","maxMetallic","maxRoughness","h","w","offset","multiply","glossiness","specularGlossiness","metallicRoughness","_convertSpecularGlossinessToMetallicRoughness","max","baseColor","metallic","hasAlpha","writeOutMetallicRoughnessTexture","writeOutBaseColorTexture","destinationOffset","linearBaseColorPixel","FromInts","sRGBBaseColorPixel","toGammaSpace","metallicRoughnessTextureData","baseColorTextureData","diffusePerceivedBrightness","_getPerceivedBrightness","specularPerceivedBrightness","_getMaxComponent","baseColorFromDiffuse","baseColorFromSpecular","subtract","Lerp","clampToRef","color","_convertMetalRoughFactorsToMetallicRoughnessAsync","babylonPBRMaterial","glTFPbrMetallicRoughness","_albedoColor","_metallic","_roughness","albedoTexture","_albedoTexture","glTFTexture","metallicTexture","_metallicTexture","metallicRoughnessTexture","_getTextureSampler","sampler","wrapS","_getGLTFTextureWrapMode","wrapU","wrapT","wrapV","samplingMode","LINEAR_LINEAR","magFilter","minFilter","LINEAR_NEAREST","NEAREST_LINEAR","NEAREST_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","NEAREST_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","LINEAR_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPNEAREST","wrapMode","WRAP_ADDRESSMODE","CLAMP_ADDRESSMODE","MIRROR_ADDRESSMODE","_convertSpecGlossFactorsToMetallicRoughnessAsync","specGloss","_reflectivityColor","_microSurface","reflectivityTexture","_reflectivityTexture","useMicrosurfaceFromReflectivityMapAlpha","_useMicroSurfaceFromReflectivityMapAlpha","samplerIndex","_exportTextureSampler","metallicRoughnessFactors","_textures","imageIndex","_exportImage","_exportTextureInfo","coordinatesIndex","exportPBRMaterialAsync","useMetallicRoughness","isMetallicWorkflow","albedoColor","_setMetallicRoughnessPbrMaterialAsync","WithinEpsilon","_twoSidedLighting","_bumpTexture","_ambientTexture","texCoord","extensions","ambientTextureStrength","_ambientTextureStrength","strength","_emissiveTexture","_emissiveColor","_exportTextureImageAsync","set","_extensionsPostExportTextures","requestedMimeType","internalTextureToImage","internalTextureUniqueId","uniqueId","imageIndexPromise","cache","size","GetTextureDataAsync","image","images","_images","_shouldUseGlb","bufferView","_bufferManager","createBufferView","setBufferView","baseName","replace","extension","GetFileExtensionFromMimeType","some","uri","RandomId","_imageData","textureIndex","findIndex","samplers","_samplers","ConvertHandednessMatrix","Compose","Vector3","Quaternion","Identity","Zero","IsNoopNode","node","TransformNode","getWorldMatrix","IdentityReadOnly","multiplyToRef","TmpVectors","AbstractMesh","DefaultTranslation","DefaultRotation","DefaultScale","One","DefaultLoaderCameraParentScaleLh","GetVertexBufferInfo","vertexBuffer","byteStride","normalized","componentCount","totalVertices","reduce","current","getTotalVertices","Number","MAX_VALUE","count","kind","getKind","GetAccessorElementCount","accessorType","IsStandardVertexAttribute","VertexBuffer","PositionKind","NormalKind","TangentKind","ColorKind","MatricesIndicesKind","MatricesIndicesExtraKind","MatricesWeightsKind","MatricesWeightsExtraKind","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","GetPrimitiveMode","fillMode","TriangleFillMode","TriangleStripDrawMode","TriangleFanDrawMode","PointListDrawMode","PointFillMode","LineLoopDrawMode","LineListDrawMode","LineStripDrawMode","NormalizeTangent","tangent","x","z","ConvertToRightHandedPosition","ConvertToRightHandedRotation","absX","abs","absY","sign","absZ","absW","Rotate180Y","rotation","copyFromFloats","CollapseChildIntoParent","parentNode","parentTranslation","FromArrayToRef","translation","parentRotation","parentMatrix","ComposeToRef","matrix","decompose","IsChildCollapsible","babylonNode","parentBabylonNode","getChildren","parent","expectedScale","TargetCamera","scaling","Logger","OmitDefaultValues","object","defaultValues","entries","defaultValue","isArray","AreArraysEqual","array1","array2","every","val","TypedArrayToWriteMethod","Int8Array","setInt8","dv","bo","setUint8","Uint8ClampedArray","Int16Array","setInt16","Uint16Array","setUint16","Int32Array","setInt32","Uint32Array","setUint32","setFloat32","Float64Array","setFloat64","_data","_dataView","DataView","_byteOffset","writeTypedArray","_checkGrowBuffer","setMethod","constructor","BYTES_PER_ELEMENT","getOutputData","writeUInt8","writeInt8","writeInt16","entry","writeUInt16","writeInt32","writeUInt32","writeFloat32","writeFloat64","newByteLength","newData","GetHighestByteAlignment","_TangentType","_bufferViewToData","_bufferViewToProperties","_accessorToBufferView","generateBinary","bufferViews","totalByteLength","forEach","dataWriter","DataWriter","keys","sort","bufferViewIndex","getPropertiesWithBufferView","delete","createAccessor","componentType","minMax","_verifyBufferView","accessor","min","removeBufferView","bv","getBufferView","getData","has","_IsTransformable","Camera","Light","_CreateNodeAnimation","babylonTransformNode","animation","animationChannelTargetPath","useQuaternion","animationSampleRate","inputs","outputs","keyFrames","getKeys","minMaxKeyFrames","_GLTFAnimation","_CalculateMinMaxKeyFrames","interpolationOrBake","_DeduceInterpolation","interpolation","interpolationType","shouldBakeAnimation","_CreateBakedAnimation","framePerSecond","_CreateLinearOrStepAnimation","_CreateCubicSplineAnimation","samplerInterpolation","inputsMin","FloatRound","inputsMax","_DeduceAnimationInfo","dataAccessorType","property","targetProperty","split","_CreateNodeAnimationFromNodeAnimations","runtimeGLTFAnimation","idleGLTFAnimations","nodeMap","nodes","bufferManager","accessors","useRightHanded","shouldExportAnimation","glTFAnimation","animations","animationInfo","channels","_AddAnimation","hasRunningRuntimeAnimations","_CreateMorphTargetAnimationFromMorphTargetAnimations","Mesh","morphTargetManager","numTargets","getTarget","combinedAnimation","Animation","dataType","loopMode","enableBlending","combinedAnimationKeys","animationKeys","animationKey","k","frame","setKeys","_CreateNodeAndMorphAnimationFromAnimationGroups","babylonScene","glTFAnimations","leftHandedNodes","animationGroups","animationGroup","morphAnimations","sampleAnimations","morphAnimationMeshes","Set","animationGroupFrameDiff","targetAnimation","targetedAnimations","target","convertToRightHanded","MorphTarget","morphTargetManagers","find","babylonMesh","combinedAnimationGroup","sampleAnimationKeys","numAnimationKeys","morphTarget","animationsByMorphTarget","morphTargetAnimation","ANIMATIONTYPE_FLOAT","influence","inTangent","outTangent","morphAnimationChannels","keyframeAccessorIndex","dataAccessorIndex","animationSampler","animationChannel","animationData","currentInput","newInputs","shift","nodeIndex","inputData","outputToWrite","toArray","FromEulerVectorToRef","input","path","minFrame","maxFrame","fps","sampleRate","minMaxFrames","time","quaternionCache","previousTime","maxUsedFrame","currKeyFrame","nextKeyFrame","prevKeyFrame","endFrame","equals","state","repeatCount","_interpolate","_SetInterpolatedValue","_ConvertFactorToVector3OrQuaternion","factor","basePositionRotationOrScale","_GetBasePositionRotationOrScale","componentName","FromArray","normalize","cacheValue","RotationYawPitchRollToRef","keyFrame","_AddKeyframeValue","_AddSplineTangent","INTANGENT","OUTTANGENT","q","rotationQuaternion","position","newPositionRotationOrScale","animationType","ANIMATIONTYPE_VECTOR3","array","RotationYawPitchRoll","posRotScale","ANIMATIONTYPE_QUATERNION","tangentType","tangentValue","Infinity","BuildMorphTargetBuffers","attributes","flipX","difference","vertexCount","hasPositions","morphPositions","getPositions","originalPositions","positionData","originalPosition","subtractToRef","floatSize","hasNormals","morphNormals","getNormals","originalNormals","normalData","originalNormal","hasTangents","morphTangents","getTangents","originalTangents","tangentData","originalTangent","morphTangent","hasColors","morphColors","getColors","originalColors","getVertexBuffer","componentSize","colorData","originalColor","difference4","Vector4","wasAddedByNoopNode","_indicesAccessorMap","_vertexBufferViewMap","_vertexAccessorMap","_remappedBufferView","_meshMorphTargetMap","_vertexMapColorAlpha","_exportedNodes","_meshMap","convertedToRightHandedBuffers","getIndicesAccessor","start","flip","setIndicesAccessor","accessorIndex","map1","map2","map3","map4","pushExportedNode","getNodesSet","getVertexBufferView","setVertexBufferView","setRemappedBufferView","getRemappedBufferView","getVertexAccessor","setVertexAccessor","hasVertexColorAlpha","setHasVertexColorAlpha","getMesh","setMesh","meshIndex","bindMorphDataToMesh","morphData","morphTargets","indexOf","getMorphTargetsFromMesh","options","EngineStore","LastCreatedScene","_glTF","asset","Engine","Version","version","_animations","_accessors","_bufferViews","_cameras","_meshes","_nodes","_scenes","_skins","_materialExporter","GLTFMaterialExporter","_extensions","BufferManager","_shouldExportNodeMap","_nodeMap","_materialMap","_camerasMap","_nodesCameraMap","_skinMap","_nodesSkinMap","_babylonScene","_options","shouldExportNode","metadataSelector","metadata","gltf","extras","exportWithoutWaitingForScene","exportUnusedUVs","removeNoopRootNodes","includeCoordinateSystemConversionNodes","meshCompressionMethod","_loadExtensions","_ApplyExtension","actionAsync","currentPromise","newNode","_ApplyExtensions","GLTFExporter","_ExtensionNames","_extensionsPostExportNodeAsync","context","postExportNodeAsync","postExportMaterialAsync","postExportMaterialAdditionalTextures","postExportTexture","_extensionsPostExportMeshPrimitive","primitive","postExportMeshPrimitive","_extensionsPreGenerateBinaryAsync","preGenerateBinaryAsync","_forEachExtensions","action","enabled","_extensionsOnExporting","wasUsed","extensionsUsed","required","extensionsRequired","onExporting","_ExtensionFactories","dispose","RegisterExtension","UnregisterExtension","splice","_generateJSON","bufferByteLength","fileName","prettyPrint","buffers","scenes","cameras","skins","JSON","stringify","generateGLTFAsync","glTFPrefix","_generateBinaryAsync","binaryBuffer","jsonText","bin","glTFFileName","glTFBinFile","container","GLTFData","_exportSceneAsync","_getPadding","num","remainder","generateGLBAsync","glbFileName","jsonLength","TextEncoder","encoder","encodedJsonText","encode","jsonPadding","binPadding","headerLength","blankCharCode","charCodeAt","charCode","codePointAt","_setNodeTransformation","getPivotPoint","copyFrom","clone","FromEulerAngles","_setCameraTransformation","babylonCamera","_listAvailableCameras","camera","glTFCamera","mode","PERSPECTIVE_CAMERA","perspective","aspectRatio","getAspectRatio","yfov","fovMode","FOVMODE_VERTICAL_FIXED","fov","znear","minZ","zfar","maxZ","halfWidth","orthoLeft","orthoRight","getRenderWidth","halfHeight","orthoBottom","orthoTop","getRenderHeight","orthographic","xmag","ymag","_exportAndAssignCameras","values","gltfCamera","usedNodes","_listAvailableSkeletons","skeletons","skeleton","bones","joints","_exportAndAssignSkeletons","leftHandNodes","skin","boneIndexMap","maxBoneIndex","bone","boneIndex","getIndex","inverseBindMatrices","transformNode","getTransformNode","boneMatrix","getAbsoluteInverseBindMatrix","skinnedNodes","skinIndex","rootNodesRH","rootNodesLH","rootNoopNodesRH","rootNodes","rootNode","stateLH","ExporterState","_exportNodesAsync","stateRH","noopRH","_animationSampleRate","_shouldExportNode","babylonRootNodes","_exportBuffers","_exportNodeAsync","_collectBuffers","bufferToVertexBuffersMap","vertexBufferToMeshesMap","morphTargetsToMeshesMap","vertexBuffers","getVertexBuffers","hasVertexAlpha","vertexBufferArray","morphIndex","babylonChildNode","morphTargetsMeshesMap","bytes","floatData","DataArrayToUint8Array","EnumerateFloatValues","invLength","stdMaterialCount","filter","StandardMaterial","UNSIGNED_BYTE","Color4","fromArray","toLinearSpaceToRef","floatMatricesIndices","FLOAT","getFloatData","is16Bit","newArray","glTFMorphTarget","parentNodeChildren","includes","_createNodeAsync","idleGLTFAnimation","children","InstancedMesh","sourceMesh","subMeshes","_exportMeshAsync","parentNodeIndex","_exportIndices","is32Bits","sideOrientation","indicesToExport","CounterClockWiseSideOrientation","IsTriangleFillMode","newIndices","subarray","IndicesArrayToTypedArray","_exportVertexBuffer","startsWith","fill","GetMinMax","isFloatMatricesIndices","vertexBufferType","vertexBufferNormalized","GetAccessorType","GetAttributeType","_exportMaterialAsync","subMesh","materialIndex","MultiMaterial","subMaterials","PBRBaseMaterial","getClassName","primitives","isUnIndexed","isLinesMesh","LinesMesh","isGreasedLineMesh","GreasedLineBaseMesh","getMaterial","babylonLinesMesh","colorWhite","greasedLineMaterial","overrideRenderingFillMode","AreIndices32Bits","indexCount","indexStart","verticesStart","verticesCount","targets","gltfMorphTarget","weights","targetNames","GLTFAsync","whenReadyAsync","exporter","GLBAsync","NAME","_wasUsed","hasThinInstances","noTranslation","noRotation","noScale","thinInstanceGetWorldMatrices","iwt","iwr","iws","hasAnyInstanceWorldTranslation","hasAnyInstanceWorldRotation","hasAnyInstanceWorldScale","translationBuffer","thinInstanceCount","rotationBuffer","scaleBuffer","_buildAccessor","EXT_mesh_gpu_instancing","_bufferViewsUsed","_accessorsUsed","_encodePromises","DracoEncoder","DefaultAvailable","primitiveBufferViews","primitiveAccessors","glTFName","GetTypedArrayData","GetTypeByteLength","dracoName","method","promise","Default","_encodeAsync","encodedData","dracoInfo","attributeIds","catch","error","clear","KHR_draco_mesh_compression","DEFAULTS","intensity","range","SPOTDEFAULTS","innerConeAngle","outerConeAngle","PI","LIGHTDIRECTION","Backward","_lights","lightType","getTypeID","LIGHTTYPEID_POINTLIGHT","LIGHTTYPEID_DIRECTIONALLIGHT","LIGHTTYPEID_SPOTLIGHT","ShadowLight","falloffType","FALLOFF_GLTF","equalsToFloats","direction","normalizeToRef","lightRotationQuaternion","FromUnitVectorsToRef","IsIdentity","light","babylonSpotLight","spot","innerAngle","angle","lights","lightReference","KHR_lights_punctual","additionalTextures","anisotropy","isEnabled","legacy","anisotropyTextureInfo","anisotropyInfo","anisotropyStrength","anisotropyRotation","anisotropyTexture","KHR_materials_anisotropy","clearCoat","useRoughnessFromMainTexture","textureRoughness","clearCoatTextureRoughnessInfo","clearCoatTextureInfo","isTintEnabled","remapF0OnInterfaceChange","clearCoatNormalTextureInfo","clearCoatInfo","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatNormalTexture","KHR_materials_clearcoat","GetTranslucencyIntensityTexture","subs","subSurface","translucencyIntensityTexture","thicknessTexture","useMaskFromThicknessTexture","useGltfStyleTextures","PBRMaterial","_isExtensionEnabled","translucencyColorTexture","unlit","isTranslucencyEnabled","useAlbedoToTintTranslucency","volumeIndexOfRefraction","minimumThickness","maximumThickness","diffuseTransmissionFactor","translucencyIntensity","diffuseTransmissionTexture","diffuseTransmissionColorFactor","translucencyColor","equalsFloats","diffuseTransmissionColorTexture","diffuseTransmissionInfo","KHR_materials_diffuse_transmission","isRefractionEnabled","isDispersionEnabled","dispersionInfo","dispersion","KHR_materials_dispersion","tempEmissiveStrength","emissiveStrengthInfo","emissiveStrength","newEmissiveFactor","KHR_materials_emissive_strength","indexOfRefraction","iorInfo","ior","KHR_materials_ior","iridescence","iridescenceTextureInfo","iridescenceThicknessTextureInfo","iridescenceInfo","iridescenceFactor","iridescenceIor","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceTexture","iridescenceThicknessTexture","KHR_materials_iridescence","sheen","sheenInfo","sheenColorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","KHR_materials_sheen","metallicReflectanceTexture","reflectanceTexture","metallicF0Factor","metallicReflectanceColor","_hasTexturesExtension","specularInfo","specularFactor","specularColorFactor","specularColorTexture","KHR_materials_specular","refractionIntensity","refractionIntensityTexture","transmissionFactor","volumeInfo","transmissionTexture","KHR_materials_transmission","unlitMaterial","disableLighting","KHR_materials_unlit","tintColorAtDistance","POSITIVE_INFINITY","tintColor","thicknessFactor","attenuationDistance","attenuationColor","KHR_materials_volume","_baseDiffuseRoughness","_baseDiffuseRoughnessTexture","diffuseRoughnessTextureInfo","diffuseRoughnessInfo","diffuseRoughnessFactor","diffuseRoughnessTexture","EXT_materials_diffuse_roughness","uAng","vAng","uRotationCenter","vRotationCenter","textureTransform","transformIsRequired","uOffset","vOffset","uScale","vScale","wAng","homogeneousRotationInUVTransform","cosAngle","cos","sinAngle","sin","scaledURotationCenter","scaledVRotationCenter","AdjustOffsetForRotationCenter","KHR_texture_transform","KHR_texture_basisu","EXT_texture_webp","EXT_texture_avif","CreateSTL","download","binary","isLittleEndian","doNotBakeTransform","supportInstancedMeshes","exportIndividualMeshes","getFaceData","vertices","p1p2","p3p2","Cross","writeVector","dataview","vector","writeFloat","temp","TransformCoordinatesFromFloatsToRef","faceCount","bakeCurrentTransformIntoVertices","fd","document","createElement","href","URL","createObjectURL","click","BuildVector3Array","attribute","stride","toPrecision","precision","BuildVector2Array","BuildMeshObject","windingOrder","meshObject","normal","getTotalIndices","BuildMeshVertexCount","BuildMeshVertexIndices","string","uvAttribute","colorAttribute","BuildAdditionalAttributes","BuildMesh","BuildUSDFileAsString","dataToInsert","fflate","strToU8","BuildMatrix","BuildMatrixRow","BuildXform","BuildWrapping","wrapping","TEXTURE_CLAMP_ADDRESSMODE","TEXTURE_MIRROR_ADDRESSMODE","TEXTURE_WRAP_ADDRESSMODE","BuildVector2","BuildColor","BuildTexture","mapType","textureToExports","uv","repeat","Vector2","xRotationOffset","yRotationOffset","BuildColor4","gammaSpace","BuildMaterial","pad","defaults","diffuseMap","emissiveMap","emissive","normalMap","roughnessMap","roughnessChannel","metalnessMap","metalnessChannel","metalness","aoMap","aoMapChannel","aoMapIntensity","alphaMap","clearCoatEnabled","clearCoatMap","clearCoatRoughness","clearCoatRoughnessMap","_alphaCutOff","_useRoughnessFromMetallicTextureAlpha","_useMetallnessFromMetallicTextureBlue","_useAmbientInGrayScale","_opacityTexture","ExtractTextureInformations","toLuminance","ExtractMeshInformations","sceneIsRightHanded","invert","determinant","USDZExportAsync","meshPredicate","localOptions","fflateUrl","includeAnchoringProperties","anchoringType","planeAnchoringAlignment","modelFileName","exportCamera","cameraSensorWidth","LoadScriptAsync","alignment","BuildRootAndSceneStart","materialToExports","abstractMesh","geometryFileName","activeCamera","RotationY","ORTHOGRAPHIC_CAMERA","aspect","sensorwidth","tan","BuildCamera","uuid","BuildMaterials","textureData","fileContent","filename","file","headerSize","offsetMod64","padding","extra","zipSync","globalObject","BABYLON","GLTF2","Exporter","Extensions","serializer"],"sourceRoot":""}