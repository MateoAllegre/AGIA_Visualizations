{"version":3,"file":"babylon.glTF1FileLoader.min.js","mappings":"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","sources":["webpack://LOADERS/webpack/universalModuleDefinition","webpack://LOADERS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://LOADERS/webpack/bootstrap","webpack://LOADERS/webpack/runtime/define property getters","webpack://LOADERS/webpack/runtime/global","webpack://LOADERS/webpack/runtime/hasOwnProperty shorthand","webpack://LOADERS/webpack/runtime/make namespace object","webpack://LOADERS/../../../../node_modules/tslib/tslib.es6.mjs","webpack://LOADERS/../../../dev/loaders/src/glTF/glTFValidation.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/glTFFileLoader.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/glTFFileLoader.metadata.ts","webpack://LOADERS/../../../lts/loaders/src/legacy/legacy-glTF.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/1.0/glTFLoader.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts","webpack://LOADERS/../../../lts/loaders/src/legacy/legacy-glTF1.ts","webpack://LOADERS/./src/glTF1FileLoader.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-loaders\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-loaders\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"LOADERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__597__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__597__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","/* eslint-disable github/no-then */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable @typescript-eslint/promise-function-async */\r\nimport type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let GLTFValidator: GLTF2.IGLTFValidator;\r\n\r\n// WorkerGlobalScope\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function importScripts(...urls: string[]): void;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction ValidateAsync(\r\n    data: string | Uint8Array,\r\n    rootUrl: string,\r\n    fileName: string,\r\n    getExternalResource: (uri: string) => Promise<Uint8Array>\r\n): Promise<GLTF2.IGLTFValidationResults> {\r\n    const options: GLTF2.IGLTFValidationOptions = {\r\n        externalResourceFunction: getExternalResource,\r\n    };\r\n\r\n    if (fileName) {\r\n        options.uri = rootUrl === \"file:\" ? fileName : rootUrl + fileName;\r\n    }\r\n\r\n    return ArrayBuffer.isView(data) ? GLTFValidator.validateBytes(data, options) : GLTFValidator.validateString(data, options);\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction WorkerFunc(): void {\r\n    const pendingExternalResources: Array<{ resolve: (data: any) => void; reject: (reason: any) => void }> = [];\r\n\r\n    onmessage = (message) => {\r\n        const data = message.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                importScripts(data.url);\r\n                break;\r\n            }\r\n            case \"validate\": {\r\n                ValidateAsync(\r\n                    data.data,\r\n                    data.rootUrl,\r\n                    data.fileName,\r\n                    (uri) =>\r\n                        new Promise((resolve, reject) => {\r\n                            const index = pendingExternalResources.length;\r\n                            pendingExternalResources.push({ resolve, reject });\r\n                            postMessage({ id: \"getExternalResource\", index: index, uri: uri });\r\n                        })\r\n                ).then(\r\n                    (value) => {\r\n                        postMessage({ id: \"validate.resolve\", value: value });\r\n                    },\r\n                    (reason) => {\r\n                        postMessage({ id: \"validate.reject\", reason: reason });\r\n                    }\r\n                );\r\n                break;\r\n            }\r\n            case \"getExternalResource.resolve\": {\r\n                pendingExternalResources[data.index].resolve(data.value);\r\n                break;\r\n            }\r\n            case \"getExternalResource.reject\": {\r\n                pendingExternalResources[data.index].reject(data.reason);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for glTF validation\r\n */\r\nexport interface IGLTFValidationConfiguration {\r\n    /**\r\n     * The url of the glTF validator.\r\n     */\r\n    url: string;\r\n}\r\n\r\n/**\r\n * glTF validation\r\n */\r\nexport class GLTFValidation {\r\n    /**\r\n     * The configuration. Defaults to `{ url: \"https://cdn.babylonjs.com/gltf_validator.js\" }`.\r\n     */\r\n    public static Configuration: IGLTFValidationConfiguration = {\r\n        url: `${Tools._DefaultCdnUrl}/gltf_validator.js`,\r\n    };\r\n\r\n    private static _LoadScriptPromise: Promise<void>;\r\n\r\n    /**\r\n     * Validate a glTF asset using the glTF-Validator.\r\n     * @param data The JSON of a glTF or the array buffer of a binary glTF\r\n     * @param rootUrl The root url for the glTF\r\n     * @param fileName The file name for the glTF\r\n     * @param getExternalResource The callback to get external resources for the glTF validator\r\n     * @returns A promise that resolves with the glTF validation results once complete\r\n     */\r\n    public static ValidateAsync(\r\n        data: string | Uint8Array,\r\n        rootUrl: string,\r\n        fileName: string,\r\n        getExternalResource: (uri: string) => Promise<Uint8Array>\r\n    ): Promise<GLTF2.IGLTFValidationResults> {\r\n        if (typeof Worker === \"function\") {\r\n            return new Promise((resolve, reject) => {\r\n                const workerContent = `${ValidateAsync}(${WorkerFunc})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                const worker = new Worker(workerBlobUrl);\r\n\r\n                const onError = (error: ErrorEvent) => {\r\n                    worker.removeEventListener(\"error\", onError);\r\n                    worker.removeEventListener(\"message\", onMessage);\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(error);\r\n                };\r\n\r\n                const onMessage = (message: MessageEvent) => {\r\n                    const data = message.data;\r\n                    switch (data.id) {\r\n                        case \"getExternalResource\": {\r\n                            getExternalResource(data.uri).then(\r\n                                (value) => {\r\n                                    worker.postMessage({ id: \"getExternalResource.resolve\", index: data.index, value: value }, [value.buffer]);\r\n                                },\r\n                                (reason) => {\r\n                                    worker.postMessage({ id: \"getExternalResource.reject\", index: data.index, reason: reason });\r\n                                }\r\n                            );\r\n                            break;\r\n                        }\r\n                        case \"validate.resolve\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            resolve(data.value);\r\n                            worker.terminate();\r\n                            break;\r\n                        }\r\n                        case \"validate.reject\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            reject(data.reason);\r\n                            worker.terminate();\r\n                        }\r\n                    }\r\n                };\r\n\r\n                worker.addEventListener(\"error\", onError);\r\n                worker.addEventListener(\"message\", onMessage);\r\n\r\n                worker.postMessage({ id: \"init\", url: Tools.GetBabylonScriptURL(this.Configuration.url) });\r\n\r\n                if (ArrayBuffer.isView(data)) {\r\n                    // Slice the data to avoid copying the whole array buffer.\r\n                    const slicedData = data.slice();\r\n                    worker.postMessage({ id: \"validate\", data: slicedData, rootUrl: rootUrl, fileName: fileName }, [slicedData.buffer]);\r\n                } else {\r\n                    worker.postMessage({ id: \"validate\", data: data, rootUrl: rootUrl, fileName: fileName });\r\n                }\r\n            });\r\n        } else {\r\n            if (!this._LoadScriptPromise) {\r\n                this._LoadScriptPromise = Tools.LoadBabylonScriptAsync(this.Configuration.url);\r\n            }\r\n\r\n            return this._LoadScriptPromise.then(() => {\r\n                return ValidateAsync(data, rootUrl, fileName, getExternalResource);\r\n            });\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable github/no-then */\r\n/* eslint-disable @typescript-eslint/no-floating-promises */\r\n/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable @typescript-eslint/promise-function-async */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { ISceneLoaderPluginFactory, ISceneLoaderPluginAsync, ISceneLoaderProgressEvent, ISceneLoaderAsyncResult, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene, IDisposable } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IFileRequest } from \"core/Misc/fileRequest\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DataReader } from \"core/Misc/dataReader\";\r\nimport { GLTFValidation } from \"./glTFValidation\";\r\nimport { GLTFFileLoaderMetadata, GLTFMagicBase64Encoded } from \"./glTFFileLoader.metadata\";\r\nimport type { LoadFileError } from \"core/Misc/fileTools\";\r\nimport { DecodeBase64UrlToBinary } from \"core/Misc/fileTools\";\r\nimport { RuntimeError, ErrorCodes } from \"core/Misc/error\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\n\r\n/**\r\n * Defines options for glTF loader extensions. This interface is extended by specific extensions.\r\n */\r\nexport interface GLTFLoaderExtensionOptions extends Record<string, Record<string, unknown> | undefined> {}\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the glTF loader.\r\n         */\r\n        [GLTFFileLoaderMetadata.name]: Partial<GLTFLoaderOptions>;\r\n    }\r\n}\r\n\r\ninterface IFileRequestInfo extends IFileRequest {\r\n    _lengthComputable?: boolean;\r\n    _loaded?: number;\r\n    _total?: number;\r\n}\r\n\r\nfunction readAsync(arrayBuffer: ArrayBuffer, byteOffset: number, byteLength: number): Promise<Uint8Array> {\r\n    try {\r\n        return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n}\r\n\r\nfunction readViewAsync(arrayBufferView: ArrayBufferView, byteOffset: number, byteLength: number): Promise<Uint8Array> {\r\n    try {\r\n        if (byteOffset < 0 || byteOffset >= arrayBufferView.byteLength) {\r\n            throw new RangeError(\"Offset is out of range.\");\r\n        }\r\n\r\n        if (byteOffset + byteLength > arrayBufferView.byteLength) {\r\n            throw new RangeError(\"Length is out of range.\");\r\n        }\r\n\r\n        return Promise.resolve(new Uint8Array(arrayBufferView.buffer, arrayBufferView.byteOffset + byteOffset, byteLength));\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Mode that determines the coordinate system to use.\r\n */\r\nexport enum GLTFLoaderCoordinateSystemMode {\r\n    /**\r\n     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\r\n     */\r\n    AUTO,\r\n\r\n    /**\r\n     * Sets the useRightHandedSystem flag on the scene.\r\n     */\r\n    FORCE_RIGHT_HANDED,\r\n}\r\n\r\n/**\r\n * Mode that determines what animations will start.\r\n */\r\nexport enum GLTFLoaderAnimationStartMode {\r\n    /**\r\n     * No animation will start.\r\n     */\r\n    NONE,\r\n\r\n    /**\r\n     * The first animation will start.\r\n     */\r\n    FIRST,\r\n\r\n    /**\r\n     * All animations will start.\r\n     */\r\n    ALL,\r\n}\r\n\r\n/**\r\n * Interface that contains the data for the glTF asset.\r\n */\r\nexport interface IGLTFLoaderData {\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    json: object;\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    bin: Nullable<IDataBuffer>;\r\n}\r\n\r\n/**\r\n * Interface for extending the loader.\r\n */\r\nexport interface IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines the order of this extension.\r\n     * The loader sorts the extensions using these values when loading.\r\n     */\r\n    order?: number;\r\n}\r\n\r\n/**\r\n * Loader state.\r\n */\r\nexport enum GLTFLoaderState {\r\n    /**\r\n     * The asset is loading.\r\n     */\r\n    LOADING,\r\n\r\n    /**\r\n     * The asset is ready for rendering.\r\n     */\r\n    READY,\r\n\r\n    /**\r\n     * The asset is completely loaded.\r\n     */\r\n    COMPLETE,\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFLoader extends IDisposable {\r\n    importMeshAsync: (\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ) => Promise<ISceneLoaderAsyncResult>;\r\n    loadAsync: (scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;\r\n}\r\n\r\n/**\r\n * Adds default/implicit options to extension specific options.\r\n */\r\ntype DefaultExtensionOptions<BaseExtensionOptions> = {\r\n    /**\r\n     * Defines if the extension is enabled\r\n     */\r\n    enabled?: boolean;\r\n} & BaseExtensionOptions;\r\n\r\nabstract class GLTFLoaderOptions {\r\n    // eslint-disable-next-line babylonjs/available\r\n    protected copyFrom(options?: Partial<Readonly<GLTFLoaderOptions>>) {\r\n        if (options) {\r\n            this.alwaysComputeBoundingBox = options.alwaysComputeBoundingBox ?? this.alwaysComputeBoundingBox;\r\n            this.alwaysComputeSkeletonRootNode = options.alwaysComputeSkeletonRootNode ?? this.alwaysComputeSkeletonRootNode;\r\n            this.animationStartMode = options.animationStartMode ?? this.animationStartMode;\r\n            this.capturePerformanceCounters = options.capturePerformanceCounters ?? this.capturePerformanceCounters;\r\n            this.compileMaterials = options.compileMaterials ?? this.compileMaterials;\r\n            this.compileShadowGenerators = options.compileShadowGenerators ?? this.compileShadowGenerators;\r\n            this.coordinateSystemMode = options.coordinateSystemMode ?? this.coordinateSystemMode;\r\n            this.createInstances = options.createInstances ?? this.createInstances;\r\n            this.customRootNode = options.customRootNode;\r\n            this.extensionOptions = options.extensionOptions ?? this.extensionOptions;\r\n            this.loadAllMaterials = options.loadAllMaterials ?? this.loadAllMaterials;\r\n            this.loadMorphTargets = options.loadMorphTargets ?? this.loadMorphTargets;\r\n            this.loadNodeAnimations = options.loadNodeAnimations ?? this.loadNodeAnimations;\r\n            this.loadOnlyMaterials = options.loadOnlyMaterials ?? this.loadOnlyMaterials;\r\n            this.loadSkins = options.loadSkins ?? this.loadSkins;\r\n            this.loggingEnabled = options.loggingEnabled ?? this.loggingEnabled;\r\n            this.onCameraLoaded = options.onCameraLoaded;\r\n            this.onMaterialLoaded = options.onMaterialLoaded;\r\n            this.onMeshLoaded = options.onMeshLoaded;\r\n            this.onParsed = options.onParsed;\r\n            this.onSkinLoaded = options.onSkinLoaded;\r\n            this.onTextureLoaded = options.onTextureLoaded;\r\n            this.onValidated = options.onValidated;\r\n            this.preprocessUrlAsync = options.preprocessUrlAsync ?? this.preprocessUrlAsync;\r\n            this.skipMaterials = options.skipMaterials ?? this.skipMaterials;\r\n            this.targetFps = options.targetFps ?? this.targetFps;\r\n            this.transparencyAsCoverage = options.transparencyAsCoverage ?? this.transparencyAsCoverage;\r\n            this.useClipPlane = options.useClipPlane ?? this.useClipPlane;\r\n            this.useGltfTextureNames = options.useGltfTextureNames ?? this.useGltfTextureNames;\r\n            this.useRangeRequests = options.useRangeRequests ?? this.useRangeRequests;\r\n            this.useSRGBBuffers = options.useSRGBBuffers ?? this.useSRGBBuffers;\r\n            this.validate = options.validate ?? this.validate;\r\n        }\r\n    }\r\n\r\n    // --------------\r\n    // Common options\r\n    // --------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public abstract onParsed?: ((loaderData: IGLTFLoaderData) => void) | undefined;\r\n\r\n    // ----------\r\n    // V2 options\r\n    // ----------\r\n\r\n    /**\r\n     * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.\r\n     */\r\n    public alwaysComputeBoundingBox = false;\r\n\r\n    /**\r\n     * Defines if the loader should always compute the nearest common ancestor of the skeleton joints instead of using `skin.skeleton`. Defaults to false.\r\n     * Set this to true if loading assets with invalid `skin.skeleton` values.\r\n     */\r\n    public alwaysComputeSkeletonRootNode = false;\r\n\r\n    /**\r\n     * The animation start mode. Defaults to FIRST.\r\n     */\r\n    public animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public abstract capturePerformanceCounters: boolean;\r\n\r\n    /**\r\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\r\n     */\r\n    public compileMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\r\n     */\r\n    public compileShadowGenerators = false;\r\n\r\n    /**\r\n     * The coordinate system mode. Defaults to AUTO.\r\n     */\r\n    public coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\r\n\r\n    /**\r\n     * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.\r\n     */\r\n    public createInstances = true;\r\n\r\n    /**\r\n     * Defines the node to use as the root of the hierarchy when loading the scene (default: undefined). If not defined, a root node will be automatically created.\r\n     * You can also pass null if you don't want a root node to be created.\r\n     */\r\n    public customRootNode?: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Defines options for glTF extensions.\r\n     */\r\n    public extensionOptions: {\r\n        // NOTE: This type is doing two things:\r\n        // 1. Adding an implicit 'enabled' property to the options for each extension.\r\n        // 2. Creating a mapped type of all the options of all the extensions to make it just look like a consolidated plain object in intellisense for the user.\r\n        [Extension in keyof GLTFLoaderExtensionOptions]?: {\r\n            [Option in keyof DefaultExtensionOptions<GLTFLoaderExtensionOptions[Extension]>]: DefaultExtensionOptions<GLTFLoaderExtensionOptions[Extension]>[Option];\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.\r\n     */\r\n    public loadAllMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should load morph targets. Defaults to true.\r\n     */\r\n    public loadMorphTargets = true;\r\n\r\n    /**\r\n     * Defines if the loader should load node animations. Defaults to true.\r\n     * NOTE: The animation of this node will still load if the node is also a joint of a skin and `loadSkins` is true.\r\n     */\r\n    public loadNodeAnimations = true;\r\n\r\n    /**\r\n     * If true, load only the materials defined in the file. Defaults to false.\r\n     */\r\n    public loadOnlyMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should load skins. Defaults to true.\r\n     */\r\n    public loadSkins = true;\r\n\r\n    /**\r\n     * If true, enable logging for the loader. Defaults to false.\r\n     */\r\n    public abstract loggingEnabled: boolean;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public abstract onCameraLoaded?: (camera: Camera) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public abstract onMaterialLoaded?: (material: Material) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public abstract onMeshLoaded?: (mesh: AbstractMesh) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     */\r\n    public abstract onSkinLoaded?: (node: TransformNode, skinnedNode: TransformNode) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public abstract onTextureLoaded?: (texture: BaseTexture) => void;\r\n\r\n    /**\r\n     * Callback raised after the asset is validated.\r\n     */\r\n    public abstract onValidated?: (results: GLTF2.IGLTFValidationResults) => void;\r\n\r\n    /**\r\n     * Function called before loading a url referenced by the asset.\r\n     * @param url url referenced by the asset\r\n     * @returns Async url to load\r\n     */\r\n    public preprocessUrlAsync = (url: string) => Promise.resolve(url);\r\n\r\n    /**\r\n     * If true, do not load any materials defined in the file. Defaults to false.\r\n     */\r\n    public skipMaterials = false;\r\n\r\n    /**\r\n     * When loading glTF animations, which are defined in seconds, target them to this FPS. Defaults to 60.\r\n     */\r\n    public targetFps = 60;\r\n\r\n    /**\r\n     * Defines if the Alpha blended materials are only applied as coverage.\r\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\r\n     * If true, no extra effects are applied to transparent pixels.\r\n     */\r\n    public transparencyAsCoverage = false;\r\n\r\n    /**\r\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\r\n     */\r\n    public useClipPlane = false;\r\n\r\n    /**\r\n     * If true, the loader will derive the name for Babylon textures from the glTF texture name, image name, or image url. Defaults to false.\r\n     * Note that it is possible for multiple Babylon textures to share the same name when the Babylon textures load from the same glTF texture or image.\r\n     */\r\n    public useGltfTextureNames = false;\r\n\r\n    /**\r\n     * Defines if the loader should use range requests when load binary glTF files from HTTP.\r\n     * Enabling will disable offline support and glTF validator.\r\n     * Defaults to false.\r\n     */\r\n    public useRangeRequests = false;\r\n\r\n    /**\r\n     * If true, load the color (gamma encoded) textures into sRGB buffers (if supported by the GPU), which will yield more accurate results when sampling the texture. Defaults to true.\r\n     */\r\n    public useSRGBBuffers = true;\r\n\r\n    /**\r\n     * Defines if the loader should validate the asset.\r\n     */\r\n    public validate = false;\r\n}\r\n\r\n/**\r\n * File loader for loading glTF files into a scene.\r\n */\r\nexport class GLTFFileLoader extends GLTFLoaderOptions implements IDisposable, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /** @internal */\r\n    public static _CreateGLTF1Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /** @internal */\r\n    public static _CreateGLTF2Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /**\r\n     * Creates a new glTF file loader.\r\n     * @param options The options for the loader\r\n     */\r\n    public constructor(options?: Partial<Readonly<GLTFLoaderOptions>>) {\r\n        super();\r\n        this.copyFrom(options);\r\n    }\r\n\r\n    // --------------------\r\n    // Begin Common options\r\n    // --------------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public onParsedObservable = new Observable<IGLTFLoaderData>();\r\n\r\n    private _onParsedObserver: Nullable<Observer<IGLTFLoaderData>>;\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public set onParsed(callback: ((loaderData: IGLTFLoaderData) => void) | undefined) {\r\n        if (this._onParsedObserver) {\r\n            this.onParsedObservable.remove(this._onParsedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onParsedObserver = this.onParsedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    // ------------------\r\n    // End Common options\r\n    // ------------------\r\n\r\n    // ----------------\r\n    // Begin V1 options\r\n    // ----------------\r\n\r\n    /**\r\n     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\r\n     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\r\n     * Defaults to true.\r\n     * @internal\r\n     */\r\n    public static IncrementalLoading = true;\r\n\r\n    /**\r\n     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\r\n     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\r\n     * @internal\r\n     */\r\n    public static HomogeneousCoordinates = false;\r\n\r\n    // --------------\r\n    // End V1 options\r\n    // --------------\r\n\r\n    /**\r\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public readonly onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n\r\n    private _onMeshLoadedObserver: Nullable<Observer<AbstractMesh>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public set onMeshLoaded(callback: ((mesh: AbstractMesh) => void) | undefined) {\r\n        if (this._onMeshLoadedObserver) {\r\n            this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     * @param node - the transform node that corresponds to the original glTF skin node used for animations\r\n     * @param skinnedNode - the transform node that is the skinned mesh itself or the parent of the skinned meshes\r\n     */\r\n    public readonly onSkinLoadedObservable = new Observable<{ node: TransformNode; skinnedNode: TransformNode }>();\r\n\r\n    private _onSkinLoadedObserver: Nullable<Observer<{ node: TransformNode; skinnedNode: TransformNode }>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     */\r\n    public set onSkinLoaded(callback: ((node: TransformNode, skinnedNode: TransformNode) => void) | undefined) {\r\n        if (this._onSkinLoadedObserver) {\r\n            this.onSkinLoadedObservable.remove(this._onSkinLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onSkinLoadedObserver = this.onSkinLoadedObservable.add((data) => callback(data.node, data.skinnedNode));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public readonly onTextureLoadedObservable = new Observable<BaseTexture>();\r\n\r\n    private _onTextureLoadedObserver: Nullable<Observer<BaseTexture>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public set onTextureLoaded(callback: ((texture: BaseTexture) => void) | undefined) {\r\n        if (this._onTextureLoadedObserver) {\r\n            this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public readonly onMaterialLoadedObservable = new Observable<Material>();\r\n\r\n    private _onMaterialLoadedObserver: Nullable<Observer<Material>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public set onMaterialLoaded(callback: ((material: Material) => void) | undefined) {\r\n        if (this._onMaterialLoadedObserver) {\r\n            this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public readonly onCameraLoadedObservable = new Observable<Camera>();\r\n\r\n    private _onCameraLoadedObserver: Nullable<Observer<Camera>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public set onCameraLoaded(callback: ((camera: Camera) => void) | undefined) {\r\n        if (this._onCameraLoadedObserver) {\r\n            this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public readonly onCompleteObservable = new Observable<void>();\r\n\r\n    private _onCompleteObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public set onComplete(callback: () => void) {\r\n        if (this._onCompleteObserver) {\r\n            this.onCompleteObservable.remove(this._onCompleteObserver);\r\n        }\r\n        this._onCompleteObserver = this.onCompleteObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when an error occurs.\r\n     */\r\n    public readonly onErrorObservable = new Observable<any>();\r\n\r\n    private _onErrorObserver: Nullable<Observer<any>>;\r\n\r\n    /**\r\n     * Callback raised when an error occurs.\r\n     */\r\n    public set onError(callback: (reason: any) => void) {\r\n        if (this._onErrorObserver) {\r\n            this.onErrorObservable.remove(this._onErrorObserver);\r\n        }\r\n        this._onErrorObserver = this.onErrorObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after the loader is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<void>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised after the loader is disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after a loader extension is created.\r\n     * Set additional options for a loader extension in this event.\r\n     */\r\n    public readonly onExtensionLoadedObservable = new Observable<IGLTFLoaderExtension>();\r\n\r\n    private _onExtensionLoadedObserver: Nullable<Observer<IGLTFLoaderExtension>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void) {\r\n        if (this._onExtensionLoadedObserver) {\r\n            this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\r\n        }\r\n        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader logging is enabled.\r\n     */\r\n    public get loggingEnabled(): boolean {\r\n        return this._loggingEnabled;\r\n    }\r\n\r\n    public set loggingEnabled(value: boolean) {\r\n        if (this._loggingEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._loggingEnabled = value;\r\n\r\n        if (this._loggingEnabled) {\r\n            this._log = this._logEnabled;\r\n        } else {\r\n            this._log = this._logDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public get capturePerformanceCounters(): boolean {\r\n        return this._capturePerformanceCounters;\r\n    }\r\n\r\n    public set capturePerformanceCounters(value: boolean) {\r\n        if (this._capturePerformanceCounters === value) {\r\n            return;\r\n        }\r\n\r\n        this._capturePerformanceCounters = value;\r\n\r\n        if (this._capturePerformanceCounters) {\r\n            this._startPerformanceCounter = this._startPerformanceCounterEnabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterEnabled;\r\n        } else {\r\n            this._startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\r\n     */\r\n    public readonly onValidatedObservable = new Observable<GLTF2.IGLTFValidationResults>();\r\n\r\n    private _onValidatedObserver: Nullable<Observer<GLTF2.IGLTFValidationResults>>;\r\n\r\n    /**\r\n     * Callback raised after the asset is validated.\r\n     */\r\n    public set onValidated(callback: (results: GLTF2.IGLTFValidationResults) => void) {\r\n        if (this._onValidatedObserver) {\r\n            this.onValidatedObservable.remove(this._onValidatedObserver);\r\n        }\r\n        this._onValidatedObserver = this.onValidatedObservable.add(callback);\r\n    }\r\n\r\n    private _loader: Nullable<IGLTFLoader> = null;\r\n    private _state: Nullable<GLTFLoaderState> = null;\r\n    private _progressCallback?: (event: ISceneLoaderProgressEvent) => void;\r\n    private _requests = new Array<IFileRequestInfo>();\r\n\r\n    /**\r\n     * Name of the loader (\"gltf\")\r\n     */\r\n    public readonly name = GLTFFileLoaderMetadata.name;\r\n\r\n    /** @internal */\r\n    public readonly extensions = GLTFFileLoaderMetadata.extensions;\r\n\r\n    /**\r\n     * Disposes the loader, releases resources during load, and cancels any outstanding requests.\r\n     */\r\n    public dispose(): void {\r\n        if (this._loader) {\r\n            this._loader.dispose();\r\n            this._loader = null;\r\n        }\r\n\r\n        for (const request of this._requests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._requests.length = 0;\r\n\r\n        delete this._progressCallback;\r\n\r\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\r\n\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onSkinLoadedObservable.clear();\r\n        this.onTextureLoadedObservable.clear();\r\n        this.onMaterialLoadedObservable.clear();\r\n        this.onCameraLoadedObservable.clear();\r\n        this.onCompleteObservable.clear();\r\n        this.onExtensionLoadedObservable.clear();\r\n\r\n        this.onDisposeObservable.notifyObservers(undefined);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string | ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        name?: string\r\n    ): Nullable<IFileRequest> {\r\n        if (ArrayBuffer.isView(fileOrUrl)) {\r\n            this._loadBinary(scene, fileOrUrl, rootUrl, onSuccess, onError, name);\r\n            return null;\r\n        }\r\n\r\n        this._progressCallback = onProgress;\r\n\r\n        const fileName = (fileOrUrl as File).name || Tools.GetFilename(fileOrUrl as string);\r\n\r\n        if (useArrayBuffer) {\r\n            if (this.useRangeRequests) {\r\n                if (this.validate) {\r\n                    Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\r\n                }\r\n\r\n                const fileRequest: IFileRequest = {\r\n                    abort: () => {},\r\n                    onCompleteObservable: new Observable<IFileRequest>(),\r\n                };\r\n\r\n                const dataBuffer = {\r\n                    readAsync: (byteOffset: number, byteLength: number) => {\r\n                        return new Promise<ArrayBufferView>((resolve, reject) => {\r\n                            this._loadFile(\r\n                                scene,\r\n                                fileOrUrl,\r\n                                (data) => {\r\n                                    resolve(new Uint8Array(data as ArrayBuffer));\r\n                                },\r\n                                true,\r\n                                (error) => {\r\n                                    reject(error);\r\n                                },\r\n                                (webRequest) => {\r\n                                    webRequest.setRequestHeader(\"Range\", `bytes=${byteOffset}-${byteOffset + byteLength - 1}`);\r\n                                }\r\n                            );\r\n                        });\r\n                    },\r\n                    byteLength: 0,\r\n                };\r\n\r\n                this._unpackBinaryAsync(new DataReader(dataBuffer)).then(\r\n                    (loaderData) => {\r\n                        fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                        onSuccess(loaderData);\r\n                    },\r\n                    onError ? (error) => onError(undefined, error) : undefined\r\n                );\r\n\r\n                return fileRequest;\r\n            }\r\n\r\n            return this._loadFile(\r\n                scene,\r\n                fileOrUrl,\r\n                (data) => {\r\n                    this._validate(scene, new Uint8Array(data as ArrayBuffer, 0, (data as ArrayBuffer).byteLength), rootUrl, fileName);\r\n                    this._unpackBinaryAsync(\r\n                        new DataReader({\r\n                            readAsync: (byteOffset, byteLength) => readAsync(data as ArrayBuffer, byteOffset, byteLength),\r\n                            byteLength: (data as ArrayBuffer).byteLength,\r\n                        })\r\n                    ).then(\r\n                        (loaderData) => {\r\n                            onSuccess(loaderData);\r\n                        },\r\n                        onError ? (error) => onError(undefined, error) : undefined\r\n                    );\r\n                },\r\n                true,\r\n                onError\r\n            );\r\n        } else {\r\n            return this._loadFile(\r\n                scene,\r\n                fileOrUrl,\r\n                (data) => {\r\n                    try {\r\n                        this._validate(scene, data as string, rootUrl, fileName);\r\n                        onSuccess({ json: this._parseJson(data as string) });\r\n                    } catch {\r\n                        if (onError) {\r\n                            onError();\r\n                        }\r\n                    }\r\n                },\r\n                false,\r\n                onError\r\n            );\r\n        }\r\n    }\r\n\r\n    private _loadBinary(\r\n        scene: Scene,\r\n        data: ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        fileName?: string\r\n    ): void {\r\n        this._validate(scene, new Uint8Array(data.buffer, data.byteOffset, data.byteLength), rootUrl, fileName);\r\n        this._unpackBinaryAsync(\r\n            new DataReader({\r\n                readAsync: (byteOffset, byteLength) => readViewAsync(data, byteOffset, byteLength),\r\n                byteLength: data.byteLength,\r\n            })\r\n        ).then(\r\n            (loaderData) => {\r\n                onSuccess(loaderData);\r\n            },\r\n            onError ? (error) => onError(undefined, error) : undefined\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAssetContainerAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<AssetContainer> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n\r\n            // Prepare the asset container.\r\n            const container = new AssetContainer(scene);\r\n\r\n            // Get materials/textures when loading to add to container\r\n            const materials: Array<Material> = [];\r\n            this.onMaterialLoadedObservable.add((material) => {\r\n                materials.push(material);\r\n            });\r\n            const textures: Array<BaseTexture> = [];\r\n            this.onTextureLoadedObservable.add((texture) => {\r\n                textures.push(texture);\r\n            });\r\n            const cameras: Array<Camera> = [];\r\n            this.onCameraLoadedObservable.add((camera) => {\r\n                cameras.push(camera);\r\n            });\r\n\r\n            const morphTargetManagers: Array<MorphTargetManager> = [];\r\n            this.onMeshLoadedObservable.add((mesh) => {\r\n                if (mesh.morphTargetManager) {\r\n                    morphTargetManagers.push(mesh.morphTargetManager);\r\n                }\r\n            });\r\n\r\n            return this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then((result) => {\r\n                Array.prototype.push.apply(container.geometries, result.geometries);\r\n                Array.prototype.push.apply(container.meshes, result.meshes);\r\n                Array.prototype.push.apply(container.particleSystems, result.particleSystems);\r\n                Array.prototype.push.apply(container.skeletons, result.skeletons);\r\n                Array.prototype.push.apply(container.animationGroups, result.animationGroups);\r\n                Array.prototype.push.apply(container.materials, materials);\r\n                Array.prototype.push.apply(container.textures, textures);\r\n                Array.prototype.push.apply(container.lights, result.lights);\r\n                Array.prototype.push.apply(container.transformNodes, result.transformNodes);\r\n                Array.prototype.push.apply(container.cameras, cameras);\r\n                Array.prototype.push.apply(container.morphTargetManagers, morphTargetManagers);\r\n                return container;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public canDirectLoad(data: string): boolean {\r\n        return GLTFFileLoaderMetadata.canDirectLoad(data);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public directLoad(scene: Scene, data: string): Promise<object> {\r\n        if (\r\n            data.startsWith(\"base64,\" + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            data.startsWith(\";base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"application/octet-stream;base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"model/gltf-binary;base64,\" + GLTFMagicBase64Encoded)\r\n        ) {\r\n            const arrayBuffer = DecodeBase64UrlToBinary(data);\r\n\r\n            this._validate(scene, new Uint8Array(arrayBuffer, 0, arrayBuffer.byteLength));\r\n            return this._unpackBinaryAsync(\r\n                new DataReader({\r\n                    readAsync: (byteOffset, byteLength) => readAsync(arrayBuffer, byteOffset, byteLength),\r\n                    byteLength: arrayBuffer.byteLength,\r\n                })\r\n            );\r\n        }\r\n\r\n        this._validate(scene, data);\r\n        return Promise.resolve({ json: this._parseJson(data) });\r\n    }\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    public rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n\r\n    /** @internal */\r\n    public createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync {\r\n        return new GLTFFileLoader(options[GLTFFileLoaderMetadata.name]);\r\n    }\r\n\r\n    /**\r\n     * The loader state or null if the loader is not active.\r\n     */\r\n    public get loaderState(): Nullable<GLTFLoaderState> {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader state changes.\r\n     */\r\n    public onLoaderStateChangedObservable = new Observable<Nullable<GLTFLoaderState>>();\r\n\r\n    /**\r\n     * Returns a promise that resolves when the asset is completely loaded.\r\n     * @returns a promise that resolves when the asset is completely loaded.\r\n     */\r\n    public whenCompleteAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.onCompleteObservable.addOnce(() => {\r\n                resolve();\r\n            });\r\n            this.onErrorObservable.addOnce((reason) => {\r\n                reject(reason);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setState(state: GLTFLoaderState): void {\r\n        if (this._state === state) {\r\n            return;\r\n        }\r\n\r\n        this._state = state;\r\n        this.onLoaderStateChangedObservable.notifyObservers(this._state);\r\n        this._log(GLTFLoaderState[this._state]);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: string | ArrayBuffer) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest) => void,\r\n        onOpened?: (request: WebRequest) => void\r\n    ): IFileRequest {\r\n        const request = scene._loadFile(\r\n            fileOrUrl,\r\n            onSuccess,\r\n            (event) => {\r\n                this._onProgress(event, request);\r\n            },\r\n            true,\r\n            useArrayBuffer,\r\n            onError,\r\n            onOpened\r\n        ) as IFileRequestInfo;\r\n        request.onCompleteObservable.add(() => {\r\n            // Force the length computable to be true since we can guarantee the data is loaded.\r\n            request._lengthComputable = true;\r\n            request._total = request._loaded;\r\n        });\r\n        this._requests.push(request);\r\n        return request;\r\n    }\r\n\r\n    private _onProgress(event: ProgressEvent, request: IFileRequestInfo): void {\r\n        if (!this._progressCallback) {\r\n            return;\r\n        }\r\n\r\n        request._lengthComputable = event.lengthComputable;\r\n        request._loaded = event.loaded;\r\n        request._total = event.total;\r\n\r\n        let lengthComputable = true;\r\n        let loaded = 0;\r\n        let total = 0;\r\n        for (const request of this._requests) {\r\n            if (request._lengthComputable === undefined || request._loaded === undefined || request._total === undefined) {\r\n                return;\r\n            }\r\n\r\n            lengthComputable = lengthComputable && request._lengthComputable;\r\n            loaded += request._loaded;\r\n            total += request._total;\r\n        }\r\n\r\n        this._progressCallback({\r\n            lengthComputable: lengthComputable,\r\n            loaded: loaded,\r\n            total: lengthComputable ? total : 0,\r\n        });\r\n    }\r\n\r\n    private _validate(scene: Scene, data: string | Uint8Array, rootUrl = \"\", fileName = \"\"): void {\r\n        if (!this.validate) {\r\n            return;\r\n        }\r\n\r\n        this._startPerformanceCounter(\"Validate JSON\");\r\n        GLTFValidation.ValidateAsync(data, rootUrl, fileName, (uri) => {\r\n            return this.preprocessUrlAsync(rootUrl + uri).then((url) => {\r\n                return scene._loadFileAsync(url, undefined, true, true).then((data) => {\r\n                    return new Uint8Array(data, 0, data.byteLength);\r\n                });\r\n            });\r\n        }).then(\r\n            (result) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                this.onValidatedObservable.notifyObservers(result);\r\n                this.onValidatedObservable.clear();\r\n            },\r\n            (reason) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                Tools.Warn(`Failed to validate: ${reason.message}`);\r\n                this.onValidatedObservable.clear();\r\n            }\r\n        );\r\n    }\r\n\r\n    private _getLoader(loaderData: IGLTFLoaderData): IGLTFLoader {\r\n        const asset = (<any>loaderData.json).asset || {};\r\n\r\n        this._log(`Asset version: ${asset.version}`);\r\n        asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);\r\n        asset.generator && this._log(`Asset generator: ${asset.generator}`);\r\n\r\n        const version = GLTFFileLoader._parseVersion(asset.version);\r\n        if (!version) {\r\n            throw new Error(\"Invalid version: \" + asset.version);\r\n        }\r\n\r\n        if (asset.minVersion !== undefined) {\r\n            const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\r\n            if (!minVersion) {\r\n                throw new Error(\"Invalid minimum version: \" + asset.minVersion);\r\n            }\r\n\r\n            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {\r\n                throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\r\n            }\r\n        }\r\n\r\n        const createLoaders: { [key: number]: (parent: GLTFFileLoader) => IGLTFLoader } = {\r\n            1: GLTFFileLoader._CreateGLTF1Loader,\r\n            2: GLTFFileLoader._CreateGLTF2Loader,\r\n        };\r\n\r\n        const createLoader = createLoaders[version.major];\r\n        if (!createLoader) {\r\n            throw new Error(\"Unsupported version: \" + asset.version);\r\n        }\r\n\r\n        return createLoader(this);\r\n    }\r\n\r\n    private _parseJson(json: string): object {\r\n        this._startPerformanceCounter(\"Parse JSON\");\r\n        this._log(`JSON length: ${json.length}`);\r\n        const parsed = JSON.parse(json);\r\n        this._endPerformanceCounter(\"Parse JSON\");\r\n        return parsed;\r\n    }\r\n\r\n    private _unpackBinaryAsync(dataReader: DataReader): Promise<IGLTFLoaderData> {\r\n        this._startPerformanceCounter(\"Unpack Binary\");\r\n\r\n        // Read magic + version + length + json length + json format\r\n        return dataReader.loadAsync(20).then(() => {\r\n            const Binary = {\r\n                Magic: 0x46546c67,\r\n            };\r\n\r\n            const magic = dataReader.readUint32();\r\n            if (magic !== Binary.Magic) {\r\n                throw new RuntimeError(\"Unexpected magic: \" + magic, ErrorCodes.GLTFLoaderUnexpectedMagicError);\r\n            }\r\n\r\n            const version = dataReader.readUint32();\r\n\r\n            if (this.loggingEnabled) {\r\n                this._log(`Binary version: ${version}`);\r\n            }\r\n\r\n            const length = dataReader.readUint32();\r\n            if (!this.useRangeRequests && length !== dataReader.buffer.byteLength) {\r\n                Logger.Warn(`Length in header does not match actual data length: ${length} != ${dataReader.buffer.byteLength}`);\r\n            }\r\n\r\n            let unpacked: Promise<IGLTFLoaderData>;\r\n            switch (version) {\r\n                case 1: {\r\n                    unpacked = this._unpackBinaryV1Async(dataReader, length);\r\n                    break;\r\n                }\r\n                case 2: {\r\n                    unpacked = this._unpackBinaryV2Async(dataReader, length);\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(\"Unsupported version: \" + version);\r\n                }\r\n            }\r\n\r\n            this._endPerformanceCounter(\"Unpack Binary\");\r\n\r\n            return unpacked;\r\n        });\r\n    }\r\n\r\n    private _unpackBinaryV1Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ContentFormat = {\r\n            JSON: 0,\r\n        };\r\n\r\n        const contentLength = dataReader.readUint32();\r\n        const contentFormat = dataReader.readUint32();\r\n\r\n        if (contentFormat !== ContentFormat.JSON) {\r\n            throw new Error(`Unexpected content format: ${contentFormat}`);\r\n        }\r\n\r\n        const bodyLength = length - dataReader.byteOffset;\r\n\r\n        const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };\r\n        if (bodyLength !== 0) {\r\n            const startByteOffset = dataReader.byteOffset;\r\n            data.bin = {\r\n                readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                byteLength: bodyLength,\r\n            };\r\n        }\r\n\r\n        return Promise.resolve(data);\r\n    }\r\n\r\n    private _unpackBinaryV2Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ChunkFormat = {\r\n            JSON: 0x4e4f534a,\r\n            BIN: 0x004e4942,\r\n        };\r\n\r\n        // Read the JSON chunk header.\r\n        const chunkLength = dataReader.readUint32();\r\n        const chunkFormat = dataReader.readUint32();\r\n        if (chunkFormat !== ChunkFormat.JSON) {\r\n            throw new Error(\"First chunk format is not JSON\");\r\n        }\r\n\r\n        // Bail if there are no other chunks.\r\n        if (dataReader.byteOffset + chunkLength === length) {\r\n            return dataReader.loadAsync(chunkLength).then(() => {\r\n                return { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n            });\r\n        }\r\n\r\n        // Read the JSON chunk and the length and type of the next chunk.\r\n        return dataReader.loadAsync(chunkLength + 8).then(() => {\r\n            const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n\r\n            const readAsync = (): Promise<IGLTFLoaderData> => {\r\n                const chunkLength = dataReader.readUint32();\r\n                const chunkFormat = dataReader.readUint32();\r\n\r\n                switch (chunkFormat) {\r\n                    case ChunkFormat.JSON: {\r\n                        throw new Error(\"Unexpected JSON chunk\");\r\n                    }\r\n                    case ChunkFormat.BIN: {\r\n                        const startByteOffset = dataReader.byteOffset;\r\n                        data.bin = {\r\n                            readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                            byteLength: chunkLength,\r\n                        };\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        // ignore unrecognized chunkFormat\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (dataReader.byteOffset !== length) {\r\n                    return dataReader.loadAsync(8).then(readAsync);\r\n                }\r\n\r\n                return Promise.resolve(data);\r\n            };\r\n\r\n            return readAsync();\r\n        });\r\n    }\r\n\r\n    private static _parseVersion(version: string): Nullable<{ major: number; minor: number }> {\r\n        if (version === \"1.0\" || version === \"1.0.1\") {\r\n            return {\r\n                major: 1,\r\n                minor: 0,\r\n            };\r\n        }\r\n\r\n        const match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            major: parseInt(match[1]),\r\n            minor: parseInt(match[2]),\r\n        };\r\n    }\r\n\r\n    private static _compareVersion(a: { major: number; minor: number }, b: { major: number; minor: number }): number {\r\n        if (a.major > b.major) {\r\n            return 1;\r\n        }\r\n        if (a.major < b.major) {\r\n            return -1;\r\n        }\r\n        if (a.minor > b.minor) {\r\n            return 1;\r\n        }\r\n        if (a.minor < b.minor) {\r\n            return -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    private static readonly _logSpaces = \"                                \";\r\n    private _logIndentLevel = 0;\r\n    private _loggingEnabled = false;\r\n\r\n    /** @internal */\r\n    public _log = this._logDisabled;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _logOpen(message: string): void {\r\n        this._log(message);\r\n        this._logIndentLevel++;\r\n    }\r\n\r\n    /** @internal */\r\n    public _logClose(): void {\r\n        --this._logIndentLevel;\r\n    }\r\n\r\n    private _logEnabled(message: string): void {\r\n        const spaces = GLTFFileLoader._logSpaces.substring(0, this._logIndentLevel * 2);\r\n        Logger.Log(`${spaces}${message}`);\r\n    }\r\n\r\n    private _logDisabled(message: string): void {}\r\n\r\n    private _capturePerformanceCounters = false;\r\n\r\n    /** @internal */\r\n    public _startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n\r\n    /** @internal */\r\n    public _endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n\r\n    private _startPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.StartPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _startPerformanceCounterDisabled(counterName: string): void {}\r\n\r\n    private _endPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.EndPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _endPerformanceCounterDisabled(counterName: string): void {}\r\n}\r\n\r\nRegisterSceneLoaderPlugin(new GLTFFileLoader());\r\n","import type { ISceneLoaderPluginExtensions, ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const GLTFMagicBase64Encoded = \"Z2xURg\"; // \"glTF\" base64 encoded (without the quotes!)\r\n\r\nexport const GLTFFileLoaderMetadata = {\r\n    name: \"gltf\",\r\n\r\n    extensions: {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".gltf\": { isBinary: false, mimeType: \"model/gltf+json\" },\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".glb\": { isBinary: true, mimeType: \"model/gltf-binary\" },\r\n    } as const satisfies ISceneLoaderPluginExtensions,\r\n\r\n    canDirectLoad(data: string): boolean {\r\n        return (\r\n            (data.indexOf(\"asset\") !== -1 && data.indexOf(\"version\") !== -1) ||\r\n            data.startsWith(\"data:base64,\" + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            data.startsWith(\"data:;base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"data:application/octet-stream;base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"data:model/gltf-binary;base64,\" + GLTFMagicBase64Encoded)\r\n        );\r\n    },\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n","import * as FileLoader from \"loaders/glTF/glTFFileLoader\";\r\nimport * as Validation from \"loaders/glTF/glTFValidation\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst GlobalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof GlobalObject !== \"undefined\") {\r\n    (<any>GlobalObject).BABYLON = (<any>GlobalObject).BABYLON || {};\r\n    for (const key in FileLoader) {\r\n        (<any>GlobalObject).BABYLON[key] = (<any>FileLoader)[key];\r\n    }\r\n    for (const key in Validation) {\r\n        (<any>GlobalObject).BABYLON[key] = (<any>Validation)[key];\r\n    }\r\n}\r\n\r\nexport * from \"loaders/glTF/glTFFileLoader\";\r\nexport * from \"loaders/glTF/glTFValidation\";\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { Skeleton } from \"core/Bones/skeleton\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Enums\r\n * @internal\r\n */\r\nexport enum EComponentType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    FLOAT = 5126,\r\n}\r\n\r\n/** @internal */\r\nexport enum EShaderType {\r\n    FRAGMENT = 35632,\r\n    VERTEX = 35633,\r\n}\r\n\r\n/** @internal */\r\nexport enum EParameterType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    INT = 5124,\r\n    UNSIGNED_INT = 5125,\r\n    FLOAT = 5126,\r\n    FLOAT_VEC2 = 35664,\r\n    FLOAT_VEC3 = 35665,\r\n    FLOAT_VEC4 = 35666,\r\n    INT_VEC2 = 35667,\r\n    INT_VEC3 = 35668,\r\n    INT_VEC4 = 35669,\r\n    BOOL = 35670,\r\n    BOOL_VEC2 = 35671,\r\n    BOOL_VEC3 = 35672,\r\n    BOOL_VEC4 = 35673,\r\n    FLOAT_MAT2 = 35674,\r\n    FLOAT_MAT3 = 35675,\r\n    FLOAT_MAT4 = 35676,\r\n    SAMPLER_2D = 35678,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureWrapMode {\r\n    CLAMP_TO_EDGE = 33071,\r\n    MIRRORED_REPEAT = 33648,\r\n    REPEAT = 10497,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureFilterType {\r\n    NEAREST = 9728,\r\n    LINEAR = 9728,\r\n    NEAREST_MIPMAP_NEAREST = 9984,\r\n    LINEAR_MIPMAP_NEAREST = 9985,\r\n    NEAREST_MIPMAP_LINEAR = 9986,\r\n    LINEAR_MIPMAP_LINEAR = 9987,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureFormat {\r\n    ALPHA = 6406,\r\n    RGB = 6407,\r\n    RGBA = 6408,\r\n    LUMINANCE = 6409,\r\n    LUMINANCE_ALPHA = 6410,\r\n}\r\n\r\n/** @internal */\r\nexport enum ECullingType {\r\n    FRONT = 1028,\r\n    BACK = 1029,\r\n    FRONT_AND_BACK = 1032,\r\n}\r\n\r\n/** @internal */\r\nexport enum EBlendingFunction {\r\n    ZERO = 0,\r\n    ONE = 1,\r\n    SRC_COLOR = 768,\r\n    ONE_MINUS_SRC_COLOR = 769,\r\n    DST_COLOR = 774,\r\n    ONE_MINUS_DST_COLOR = 775,\r\n    SRC_ALPHA = 770,\r\n    ONE_MINUS_SRC_ALPHA = 771,\r\n    DST_ALPHA = 772,\r\n    ONE_MINUS_DST_ALPHA = 773,\r\n    CONSTANT_COLOR = 32769,\r\n    ONE_MINUS_CONSTANT_COLOR = 32770,\r\n    CONSTANT_ALPHA = 32771,\r\n    ONE_MINUS_CONSTANT_ALPHA = 32772,\r\n    SRC_ALPHA_SATURATE = 776,\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFProperty {\r\n    extensions?: { [key: string]: any };\r\n    extras?: object;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFChildRootProperty extends IGLTFProperty {\r\n    name?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAccessor extends IGLTFChildRootProperty {\r\n    bufferView: string;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    count: number;\r\n    type: string;\r\n    componentType: EComponentType;\r\n\r\n    max?: number[];\r\n    min?: number[];\r\n    name?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFBufferView extends IGLTFChildRootProperty {\r\n    buffer: string;\r\n    byteOffset: number;\r\n    byteLength: number;\r\n    byteStride: number;\r\n\r\n    target?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFBuffer extends IGLTFChildRootProperty {\r\n    uri: string;\r\n\r\n    byteLength?: number;\r\n    type?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFShader extends IGLTFChildRootProperty {\r\n    uri: string;\r\n    type: EShaderType;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFProgram extends IGLTFChildRootProperty {\r\n    attributes: string[];\r\n    fragmentShader: string;\r\n    vertexShader: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueParameter {\r\n    type: number;\r\n\r\n    count?: number;\r\n    semantic?: string;\r\n    node?: string;\r\n    value?: number | boolean | string | Array<any>;\r\n    source?: string;\r\n\r\n    babylonValue?: any;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueCommonProfile {\r\n    lightingModel: string;\r\n    texcoordBindings: object;\r\n\r\n    parameters?: Array<any>;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueStatesFunctions {\r\n    blendColor?: number[];\r\n    blendEquationSeparate?: number[];\r\n    blendFuncSeparate?: number[];\r\n    colorMask: boolean[];\r\n    cullFace: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueStates {\r\n    enable: number[];\r\n    functions: IGLTFTechniqueStatesFunctions;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechnique extends IGLTFChildRootProperty {\r\n    parameters: { [key: string]: IGLTFTechniqueParameter };\r\n    program: string;\r\n\r\n    attributes: { [key: string]: string };\r\n    uniforms: { [key: string]: string };\r\n    states: IGLTFTechniqueStates;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMaterial extends IGLTFChildRootProperty {\r\n    technique?: string;\r\n    values: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMeshPrimitive extends IGLTFProperty {\r\n    attributes: { [key: string]: string };\r\n    indices: string;\r\n    material: string;\r\n\r\n    mode?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMesh extends IGLTFChildRootProperty {\r\n    primitives: IGLTFMeshPrimitive[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFImage extends IGLTFChildRootProperty {\r\n    uri: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSampler extends IGLTFChildRootProperty {\r\n    magFilter?: number;\r\n    minFilter?: number;\r\n    wrapS?: number;\r\n    wrapT?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTexture extends IGLTFChildRootProperty {\r\n    sampler: string;\r\n    source: string;\r\n\r\n    format?: ETextureFormat;\r\n    internalFormat?: ETextureFormat;\r\n    target?: number;\r\n    type?: number;\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonTexture?: Texture;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAmbienLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFDirectionalLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFPointLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSpotLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    fallOfAngle?: number;\r\n    fallOffExponent?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFLight extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCameraOrthographic {\r\n    xmag: number;\r\n    ymag: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCameraPerspective {\r\n    aspectRatio: number;\r\n    yfov: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCamera extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationChannelTarget {\r\n    id: string;\r\n    path: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationChannel {\r\n    sampler: string;\r\n    target: IGLTFAnimationChannelTarget;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationSampler {\r\n    input: string;\r\n    output: string;\r\n\r\n    interpolation?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimation extends IGLTFChildRootProperty {\r\n    channels?: IGLTFAnimationChannel[];\r\n    parameters?: { [key: string]: string };\r\n    samplers?: { [key: string]: IGLTFAnimationSampler };\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFNodeInstanceSkin {\r\n    skeletons: string[];\r\n    skin: string;\r\n    meshes: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSkins extends IGLTFChildRootProperty {\r\n    bindShapeMatrix: number[];\r\n    inverseBindMatrices: string;\r\n    jointNames: string[];\r\n\r\n    babylonSkeleton?: Skeleton;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFNode extends IGLTFChildRootProperty {\r\n    camera?: string;\r\n    children: string[];\r\n    skin?: string;\r\n    jointName?: string;\r\n    light?: string;\r\n    matrix: number[];\r\n    mesh?: string;\r\n    meshes?: string[];\r\n    rotation?: number[];\r\n    scale?: number[];\r\n    translation?: number[];\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonNode?: Node;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFScene extends IGLTFChildRootProperty {\r\n    nodes: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFRuntime {\r\n    extensions: { [key: string]: any };\r\n    accessors: { [key: string]: IGLTFAccessor };\r\n    buffers: { [key: string]: IGLTFBuffer };\r\n    bufferViews: { [key: string]: IGLTFBufferView };\r\n    meshes: { [key: string]: IGLTFMesh };\r\n    lights: { [key: string]: IGLTFLight };\r\n    cameras: { [key: string]: IGLTFCamera };\r\n    nodes: { [key: string]: IGLTFNode };\r\n    images: { [key: string]: IGLTFImage };\r\n    textures: { [key: string]: IGLTFTexture };\r\n    shaders: { [key: string]: IGLTFShader };\r\n    programs: { [key: string]: IGLTFProgram };\r\n    samplers: { [key: string]: IGLTFSampler };\r\n    techniques: { [key: string]: IGLTFTechnique };\r\n    materials: { [key: string]: IGLTFMaterial };\r\n    animations: { [key: string]: IGLTFAnimation };\r\n    skins: { [key: string]: IGLTFSkins };\r\n\r\n    currentScene?: object;\r\n    scenes: { [key: string]: IGLTFScene }; // v1.1\r\n\r\n    extensionsUsed: string[];\r\n    extensionsRequired?: string[]; // v1.1\r\n\r\n    buffersCount: number;\r\n    shaderscount: number;\r\n\r\n    scene: Scene;\r\n    rootUrl: string;\r\n\r\n    loadedBufferCount: number;\r\n    loadedBufferViews: { [name: string]: ArrayBufferView };\r\n\r\n    loadedShaderCount: number;\r\n\r\n    importOnlyMeshes: boolean;\r\n    importMeshesNames?: string[];\r\n\r\n    dummyNodes: Node[];\r\n\r\n    assetContainer: Nullable<AssetContainer>;\r\n}\r\n\r\n/** @internal */\r\nexport interface INodeToRoot {\r\n    bone: Bone;\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IJointNode {\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n","import type { IGLTFTechniqueParameter, IGLTFAccessor, IGLTFRuntime, IGLTFBufferView } from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2, Vector3, Vector4, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * Utils functions for GLTF\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFUtils {\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param scene the Scene object\r\n     * @param source the source node where to pick the matrix\r\n     * @param parameter the GLTF technique parameter\r\n     * @param uniformName the name of the shader's uniform\r\n     * @param shaderMaterial the shader material\r\n     */\r\n    public static SetMatrix(scene: Scene, source: Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: ShaderMaterial | Effect): void {\r\n        let mat: Nullable<Matrix> = null;\r\n\r\n        if (parameter.semantic === \"MODEL\") {\r\n            mat = source.getWorldMatrix();\r\n        } else if (parameter.semantic === \"PROJECTION\") {\r\n            mat = scene.getProjectionMatrix();\r\n        } else if (parameter.semantic === \"VIEW\") {\r\n            mat = scene.getViewMatrix();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\r\n        } else if (parameter.semantic === \"MODELVIEW\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\r\n        } else if (parameter.semantic === \"MODELINVERSE\") {\r\n            mat = source.getWorldMatrix().invert();\r\n        } else if (parameter.semantic === \"VIEWINVERSE\") {\r\n            mat = scene.getViewMatrix().invert();\r\n        } else if (parameter.semantic === \"PROJECTIONINVERSE\") {\r\n            mat = scene.getProjectionMatrix().invert();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\r\n        }\r\n\r\n        if (mat) {\r\n            switch (parameter.type) {\r\n                case EParameterType.FLOAT_MAT2:\r\n                    shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT3:\r\n                    shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT4:\r\n                    shaderMaterial.setMatrix(uniformName, mat);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param shaderMaterial the shader material\r\n     * @param uniform the name of the shader's uniform\r\n     * @param value the value of the uniform\r\n     * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n     * @returns true if set, else false\r\n     */\r\n    public static SetUniform(shaderMaterial: ShaderMaterial | Effect, uniform: string, value: any, type: number): boolean {\r\n        switch (type) {\r\n            case EParameterType.FLOAT:\r\n                shaderMaterial.setFloat(uniform, value);\r\n                return true;\r\n            case EParameterType.FLOAT_VEC2:\r\n                shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC3:\r\n                shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC4:\r\n                shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the wrap mode of the texture\r\n     * @param mode the mode value\r\n     * @returns the wrap mode (TEXTURE_WRAP_ADDRESSMODE, MIRROR_ADDRESSMODE or CLAMP_ADDRESSMODE)\r\n     */\r\n    public static GetWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case ETextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case ETextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the byte stride giving an accessor\r\n     * @param accessor the GLTF accessor objet\r\n     * @returns the byte stride\r\n     */\r\n    public static GetByteStrideFromType(accessor: IGLTFAccessor): number {\r\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\r\n        const type = accessor.type;\r\n\r\n        switch (type) {\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n            default:\r\n                return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture filter mode giving a mode value\r\n     * @param mode the filter mode value\r\n     * @returns the filter mode (TODO - needs to be a type?)\r\n     */\r\n    public static GetTextureFilterMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureFilterType.LINEAR:\r\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\r\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\r\n                return Texture.TRILINEAR_SAMPLINGMODE;\r\n            case ETextureFilterType.NEAREST:\r\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\r\n                return Texture.NEAREST_SAMPLINGMODE;\r\n            default:\r\n                return Texture.BILINEAR_SAMPLINGMODE;\r\n        }\r\n    }\r\n\r\n    public static GetBufferFromBufferView(\r\n        gltfRuntime: IGLTFRuntime,\r\n        bufferView: IGLTFBufferView,\r\n        byteOffset: number,\r\n        byteLength: number,\r\n        componentType: EComponentType\r\n    ): ArrayBufferView {\r\n        byteOffset = bufferView.byteOffset + byteOffset;\r\n\r\n        const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\r\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\r\n            throw new Error(\"Buffer access is out of range\");\r\n        }\r\n\r\n        const buffer = loadedBufferView.buffer;\r\n        byteOffset += loadedBufferView.byteOffset;\r\n\r\n        switch (componentType) {\r\n            case EComponentType.BYTE:\r\n                return new Int8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_BYTE:\r\n                return new Uint8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.SHORT:\r\n                return new Int16Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_SHORT:\r\n                return new Uint16Array(buffer, byteOffset, byteLength);\r\n            default:\r\n                return new Float32Array(buffer, byteOffset, byteLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a buffer from its accessor\r\n     * @param gltfRuntime the GLTF runtime\r\n     * @param accessor the GLTF accessor\r\n     * @returns an array buffer view\r\n     */\r\n    public static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any {\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[accessor.bufferView];\r\n        const byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\r\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\r\n    }\r\n\r\n    /**\r\n     * Decodes a buffer view into a string\r\n     * @param view the buffer view\r\n     * @returns a string\r\n     */\r\n    public static DecodeBufferToText(view: ArrayBufferView): string {\r\n        let result = \"\";\r\n        const length = view.byteLength;\r\n\r\n        for (let i = 0; i < length; ++i) {\r\n            result += String.fromCharCode((<any>view)[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the default material of gltf. Related to\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n     * @param scene the Babylon.js scene\r\n     * @returns the default Babylon material\r\n     */\r\n    public static GetDefaultMaterial(scene: Scene): ShaderMaterial {\r\n        if (!GLTFUtils._DefaultMaterial) {\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform mat4 worldView;\",\r\n                \"uniform mat4 projection;\",\r\n                \"\",\r\n                \"attribute vec3 position;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform vec4 u_emission;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_FragColor = u_emission;\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            const shaderPath = {\r\n                vertex: \"GLTFDefaultMaterial\",\r\n                fragment: \"GLTFDefaultMaterial\",\r\n            };\r\n\r\n            const options = {\r\n                attributes: [\"position\"],\r\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\r\n                samplers: new Array<string>(),\r\n                needAlphaBlending: false,\r\n            };\r\n\r\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\r\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\r\n        }\r\n\r\n        return GLTFUtils._DefaultMaterial;\r\n    }\r\n\r\n    // The GLTF default material\r\n    private static _DefaultMaterial: Nullable<ShaderMaterial> = null;\r\n}\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type {\r\n    IGLTFRuntime,\r\n    IGLTFTechniqueParameter,\r\n    IGLTFAnimation,\r\n    IGLTFAnimationSampler,\r\n    IGLTFNode,\r\n    IGLTFSkins,\r\n    INodeToRoot,\r\n    IJointNode,\r\n    IGLTFMesh,\r\n    IGLTFAccessor,\r\n    IGLTFLight,\r\n    IGLTFAmbienLight,\r\n    IGLTFDirectionalLight,\r\n    IGLTFPointLight,\r\n    IGLTFSpotLight,\r\n    IGLTFCamera,\r\n    IGLTFCameraPerspective,\r\n    IGLTFScene,\r\n    IGLTFTechnique,\r\n    IGLTFMaterial,\r\n    IGLTFProgram,\r\n    IGLTFBuffer,\r\n    IGLTFTexture,\r\n    IGLTFImage,\r\n    IGLTFSampler,\r\n    IGLTFShader,\r\n    IGLTFTechniqueStates,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\nimport { Quaternion, Vector3, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader } from \"../glTFFileLoader\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n\r\n/**\r\n * Tokenizer. Used for shaders compatibility\r\n * Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3,\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) {\r\n            return ETokenType.END_OF_INPUT;\r\n        }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test((this.currentString = this.peek())) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n * Values\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nconst BabylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nconst BabylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n * Parse\r\n * @param parsedBuffers\r\n * @param gltfRuntime\r\n */\r\nconst ParseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const buf in parsedBuffers) {\r\n        const parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nconst ParseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const sha in parsedShaders) {\r\n        const parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nconst ParseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (const object in parsedObjects) {\r\n        const parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n * Utils\r\n * @param buffer\r\n */\r\nconst NormalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nconst GetAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        const channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Loads and creates animations\r\n * @param gltfRuntime\r\n */\r\nconst LoadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (const anim in gltfRuntime.animations) {\r\n        const animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        let lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (let i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            const channel = animation.channels[i];\r\n            const sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            let inputData: Nullable<string> = null;\r\n            let outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            } else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            const targetId = channel.target.id;\r\n            let targetNode: any = gltfRuntime.scene.getNodeById(targetId);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetId);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetId + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            const isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            let targetPath = channel.target.path;\r\n            const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = BabylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            let animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                } else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            let babylonAnimation: Nullable<Animation> = null;\r\n            const keys = [];\r\n            let arrayOffset = 0;\r\n            let modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n                gltfRuntime.scene._blockEntityCollection = false;\r\n            }\r\n\r\n            // For each frame\r\n            for (let j = 0; j < bufferInput.length; j++) {\r\n                let value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                } else {\r\n                    // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    const bone = <Bone>targetNode;\r\n                    let translation = Vector3.Zero();\r\n                    let rotationQuaternion = new Quaternion();\r\n                    let scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    let mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    } else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    } else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value,\r\n                    });\r\n                } else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * @returns the bones transformation matrix\r\n * @param node\r\n */\r\nconst ConfigureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    let mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        const scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        const position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    } else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n * Returns the parent bone\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param jointName\r\n * @param newSkeleton\r\n * @returns the parent bone\r\n */\r\nconst GetParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (let i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    const nodes = gltfRuntime.nodes;\r\n    for (const nde in nodes) {\r\n        const node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        const children = node.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                const mat = ConfigureBoneTransformation(node);\r\n                const bone = new Bone(node.name || \"\", newSkeleton, GetParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the appropriate root node\r\n * @param nodesToRoot\r\n * @param id\r\n * @returns the root node\r\n */\r\nconst GetNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n\r\n        for (let j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            const child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the node with the joint name\r\n * @param gltfRuntime\r\n * @param jointName\r\n * @returns the node with the joint name\r\n */\r\nconst GetJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    const nodes = gltfRuntime.nodes;\r\n    let node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName,\r\n        };\r\n    }\r\n\r\n    for (const nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde,\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Checks if a nodes is in joints\r\n * @param skins\r\n * @param id\r\n * @returns true if the node is in joints, else false\r\n */\r\nconst NodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * Fills the nodes to root for bones and builds hierarchy\r\n * @param gltfRuntime\r\n * @param newSkeleton\r\n * @param skins\r\n * @param nodesToRoot\r\n */\r\nconst GetNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (const nde in gltfRuntime.nodes) {\r\n        const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        const id = nde;\r\n\r\n        if (!node.jointName || NodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        const mat = ConfigureBoneTransformation(node);\r\n        const bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n        const children = nodeToRoot.node.children;\r\n\r\n        for (let j = 0; j < children.length; j++) {\r\n            let child: Nullable<INodeToRoot> = null;\r\n\r\n            for (let k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Imports a skeleton\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param mesh\r\n * @param newSkeleton\r\n * @returns the bone name\r\n */\r\nconst ImportSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined): Skeleton => {\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    const nodesToRoot: INodeToRoot[] = [];\r\n    const nodesToRootToAdd: Bone[] = [];\r\n\r\n    GetNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        const node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        const id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        const existingBone = gltfRuntime.scene.getBoneById(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        let foundBone = false;\r\n        let parentBone: Nullable<Bone> = null;\r\n\r\n        for (let j = 0; j < i; j++) {\r\n            const jointNode = GetJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            const joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            const children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (let k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = GetParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        const mat = ConfigureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = GetNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        const bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    const bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (let j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (let i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n * Imports a mesh and its geometries\r\n * @param gltfRuntime\r\n * @param node\r\n * @param meshes\r\n * @param id\r\n * @param newMesh\r\n * @returns the new mesh\r\n */\r\nconst ImportMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        newMesh._parentContainer = gltfRuntime.assetContainer;\r\n        gltfRuntime.scene._blockEntityCollection = false;\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    let vertexData: Nullable<VertexData> = null;\r\n    const verticesStarts: number[] = [];\r\n    const verticesCounts: number[] = [];\r\n    const indexStarts: number[] = [];\r\n    const indexCounts: number[] = [];\r\n\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            const tempVertexData = new VertexData();\r\n\r\n            const primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            const attributes = primitive.attributes;\r\n            let accessor: Nullable<IGLTFAccessor> = null;\r\n            let buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (const semantic in attributes) {\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                } else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (let j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    } else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                } else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    const channel = Number(semantic.split(\"_\")[1]);\r\n                    const uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\r\n                    const uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    NormalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                } else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                } else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                } else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                tempVertexData.indices.set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            } else {\r\n                // Set indices on the fly\r\n                const indices: number[] = [];\r\n                for (let j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            } else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            const material = gltfRuntime.scene.getMaterialById(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        material.subMaterials = subMaterials;\r\n    } else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = subMaterials[0] as StandardMaterial;\r\n    }\r\n\r\n    material._parentContainer = gltfRuntime.assetContainer;\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    gltfRuntime.scene._blockEntityCollection = false;\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    let index = 0;\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n * Configure node transformation from position, rotation and scaling\r\n * @param newNode\r\n * @param position\r\n * @param rotation\r\n * @param scaling\r\n */\r\nconst ConfigureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n * Configures node from transformation matrix\r\n * @param newNode\r\n * @param node\r\n */\r\nconst ConfigureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode) => {\r\n    if (node.matrix) {\r\n        const position = new Vector3(0, 0, 0);\r\n        const rotation = new Quaternion();\r\n        const scaling = new Vector3(0, 0, 0);\r\n        const mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        ConfigureNode(newNode, position, rotation, scaling);\r\n    } else if (node.translation && node.rotation && node.scale) {\r\n        ConfigureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n * Imports a node\r\n * @param gltfRuntime\r\n * @param node\r\n * @param id\r\n * @returns the newly imported node\r\n */\r\nconst ImportNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string): Nullable<Node> => {\r\n    let lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            const skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            const newMesh = ImportMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = ImportSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    } else if (node.meshes) {\r\n        /**\r\n         * Improve meshes property\r\n         */\r\n        const newMesh = ImportMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                const ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            } else if (light.type === \"directional\") {\r\n                const directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            } else if (light.type === \"point\") {\r\n                const pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            } else if (light.type === \"spot\") {\r\n                const spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            if (camera.type === \"orthographic\") {\r\n                const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl();\r\n\r\n                lastNode = orthoCamera;\r\n\r\n                orthoCamera._parentContainer = gltfRuntime.assetContainer;\r\n            } else if (camera.type === \"perspective\") {\r\n                const perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl();\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n                persCamera._parentContainer = gltfRuntime.assetContainer;\r\n            }\r\n\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        } else if (lastNode === null) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            dummy._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            ConfigureNodeFromMatrix(lastNode, node);\r\n        } else {\r\n            const translation = node.translation || [0, 0, 0];\r\n            const rotation = node.rotation || [0, 0, 0, 1];\r\n            const scale = node.scale || [1, 1, 1];\r\n            ConfigureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n * Traverses nodes and creates them\r\n * @param gltfRuntime\r\n * @param id\r\n * @param parent\r\n * @param meshIncluded\r\n */\r\nconst TraverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    const node: IGLTFNode = gltfRuntime.nodes[id];\r\n    let newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        } else {\r\n            meshIncluded = false;\r\n        }\r\n    } else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = ImportNode(gltfRuntime, node, id);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            TraverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n * @param gltfRuntime\r\n */\r\nconst PostLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    let currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (let i = 0; i < currentScene.nodes.length; i++) {\r\n            TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    } else {\r\n        for (const thing in gltfRuntime.scenes) {\r\n            currentScene = gltfRuntime.scenes[thing];\r\n\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    LoadAnimations(gltfRuntime);\r\n\r\n    for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        const skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n * onBind shaderrs callback to set uniforms and matrices\r\n * @param mesh\r\n * @param gltfRuntime\r\n * @param unTreatedUniforms\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param onSuccess\r\n */\r\nconst OnBindShaderMaterial = (\r\n    mesh: AbstractMesh,\r\n    gltfRuntime: IGLTFRuntime,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());\r\n            } else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());\r\n            }\r\n        } else {\r\n            const value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                shaderMaterial.getEffect().setTexture(unif, texture);\r\n            } else {\r\n                GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n * Prepare uniforms to send the only one time\r\n * Loads the appropriate textures\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n */\r\nconst PrepareShaderMaterialUniforms = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n    const techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n     * Prepare values here (not matrices)\r\n     */\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n        let value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        const onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Shader compilation failed\r\n * @param program\r\n * @param shaderMaterial\r\n * @param onError\r\n * @returns callback when shader is compiled\r\n */\r\nconst OnShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n * Shader compilation success\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param unTreatedUniforms\r\n * @param onSuccess\r\n * @returns callback when shader is compiled\r\n */\r\nconst OnShaderCompileSuccess = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    return (_: Effect) => {\r\n        PrepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            OnBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n * Returns the appropriate uniform if already handled by babylon\r\n * @param tokenizer\r\n * @param technique\r\n * @param unTreatedUniforms\r\n * @returns the name of the uniform handled by babylon\r\n */\r\nconst ParseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (const unif in technique.uniforms) {\r\n        const uniform = technique.uniforms[unif];\r\n        const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return BabylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n * All shaders loaded. Create materials one by one\r\n * @param gltfRuntime\r\n */\r\nconst ImportMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (const mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(\r\n            gltfRuntime,\r\n            mat,\r\n            () => {},\r\n            () => {}\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * Implementation of the base glTF spec\r\n * @internal\r\n */\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        const gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: [],\r\n\r\n            assetContainer: null,\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            ParseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            ParseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            ParseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            ParseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            ParseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            ParseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            ParseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            ParseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            ParseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            ParseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            ParseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            ParseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            ParseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            ParseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            ParseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            ParseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            ParseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            ParseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        const buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + buffer.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                onProgress,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + source.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                undefined,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        const sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        const createMipMaps =\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\r\n\r\n        const samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        const blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        const blobURL = URL.createObjectURL(blob);\r\n        const revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            const shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        } else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        const technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            defaultMaterial._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        const program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        const states: IGLTFTechniqueStates = technique.states;\r\n\r\n        const vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        const pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        let newVertexShader = \"\";\r\n        let newPixelShader = \"\";\r\n\r\n        const vertexTokenizer = new Tokenizer(vertexShader);\r\n        const pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        const unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        const uniforms: string[] = [];\r\n        const attributes: string[] = [];\r\n        const samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (const unif in technique.uniforms) {\r\n            const uniform = technique.uniforms[unif];\r\n            const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(BabylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                } else {\r\n                    uniforms.push(unif);\r\n                }\r\n            } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            } else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (const attr in technique.attributes) {\r\n            const attribute = technique.attributes[attr];\r\n            const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                const name = GetAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            const tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            let foundAttribute = false;\r\n\r\n            for (const attr in technique.attributes) {\r\n                const attribute = technique.attributes[attr];\r\n                const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += GetAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += ParseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            const tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += ParseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        const shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id,\r\n        };\r\n\r\n        const options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1,\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = OnShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = OnShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            const functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            const blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ONE &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ADD;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ZERO &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.DST_COLOR &&\r\n                    blendFunc[1] === EBlendingFunction.ZERO &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * glTF V1 Loader\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoader.Extensions[extension.name]) {\r\n            Tools.Error('Tool with the same name \"' + extension.name + '\" already exists');\r\n            return;\r\n        }\r\n\r\n        GLTFLoader.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                gltfRuntime.assetContainer = assetContainer;\r\n                gltfRuntime.importOnlyMeshes = true;\r\n\r\n                if (meshesNames === \"\") {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                } else if (typeof meshesNames === \"string\") {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                    Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n                }\r\n\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                const meshes: AbstractMesh[] = [];\r\n                const skeletons: Skeleton[] = [];\r\n\r\n                // Fill arrays of meshes and skeletons\r\n                for (const nde in gltfRuntime.nodes) {\r\n                    const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                    if (node.babylonNode instanceof AbstractMesh) {\r\n                        meshes.push(node.babylonNode);\r\n                    }\r\n                }\r\n\r\n                for (const skl in gltfRuntime.skins) {\r\n                    const skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                    if (skin.babylonSkeleton instanceof Skeleton) {\r\n                        skeletons.push(skin.babylonSkeleton);\r\n                    }\r\n                }\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        ImportMaterials(gltfRuntime);\r\n                        PostLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                            onSuccess(meshes, skeletons);\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                    onSuccess(meshes, skeletons);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param assetContainer defines the asset container to use (can be null)\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(\r\n                meshesNames,\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                assetContainer,\r\n                (meshes, skeletons) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: [],\r\n                        skeletons: skeletons,\r\n                        animationGroups: [],\r\n                        lights: [],\r\n                        transformNodes: [],\r\n                        geometries: [],\r\n                        spriteManagers: [],\r\n                    });\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess: () => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                // Load runtime extensios\r\n                GLTFLoaderExtension.LoadRuntimeExtensionsAsync(\r\n                    gltfRuntime,\r\n                    () => {\r\n                        // Create nodes\r\n                        this._createNodes(gltfRuntime);\r\n\r\n                        // Load buffers, shaders, materials, etc.\r\n                        this._loadBuffersAsync(gltfRuntime, () => {\r\n                            this._loadShadersAsync(gltfRuntime, () => {\r\n                                ImportMaterials(gltfRuntime);\r\n                                PostLoad(gltfRuntime);\r\n\r\n                                if (!GLTFFileLoader.IncrementalLoading) {\r\n                                    onSuccess();\r\n                                }\r\n                            });\r\n                        });\r\n\r\n                        if (GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    },\r\n                    onError\r\n                );\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from a loaded gltf file and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public async loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void): Promise<void> {\r\n        return await new Promise((resolve, reject) => {\r\n            this._loadAsync(\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        let hasShaders = false;\r\n\r\n        const processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(\r\n                gltfRuntime,\r\n                sha,\r\n                (shaderString) => {\r\n                    if (shaderString instanceof ArrayBuffer) {\r\n                        return;\r\n                    }\r\n\r\n                    gltfRuntime.loadedShaderCount++;\r\n\r\n                    if (shaderString) {\r\n                        Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                        onload();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            const shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            } else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void): void {\r\n        let hasBuffers = false;\r\n\r\n        const processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(\r\n                gltfRuntime,\r\n                buf,\r\n                (bufferView) => {\r\n                    gltfRuntime.loadedBufferCount++;\r\n\r\n                    if (bufferView) {\r\n                        if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                            Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                        }\r\n\r\n                        gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                        onLoad();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            const buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            } else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        let currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        } else {\r\n            // Load all scenes\r\n            for (const thing in gltfRuntime.scenes) {\r\n                currentScene = gltfRuntime.scenes[thing];\r\n\r\n                for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                    TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport abstract class GLTFLoaderExtension {\r\n    private _name: string;\r\n\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n    }\r\n\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading the runtime\r\n     * Return true to stop further extensions from loading the runtime\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading the runtime\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     * @param gltfRuntime\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from creating the runtime\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading buffers\r\n     * Return true to stop further extensions from loading this buffer\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @param onProgress\r\n     * @returns true to stop further extensions from loading this buffer\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading texture buffers\r\n     * Return true to stop further extensions from loading this texture data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this texture data\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for creating textures\r\n     * Return true to stop further extensions from loading this texture\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param buffer\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this texture\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading shader strings\r\n     * Return true to stop further extensions from loading this shader data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this shader data\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading materials\r\n     * Return true to stop further extensions from loading this material\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadRuntimeAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess?: (gltfRuntime: IGLTFRuntime) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    if (!onSuccess) {\r\n                        return;\r\n                    }\r\n                    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    onSuccess();\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (bufferView: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private static _LoadTextureBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: Nullable<ArrayBufferView>) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private static _CreateTextureAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        buffer: ArrayBufferView,\r\n        onSuccess: (texture: Texture) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (const extensionName in GLTFLoader.Extensions) {\r\n            const loaderExtension = GLTFLoader.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();\r\n","import { GLTFLoaderExtension, GLTFLoader, GLTFLoaderBase } from \"./glTFLoader\";\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport type { IGLTFRuntime, IGLTFTexture, IGLTFImage, IGLTFBufferView, IGLTFShader } from \"./glTFLoaderInterfaces\";\r\nimport { EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\n\r\nconst BinaryExtensionBufferName = \"binary_glTF\";\r\n\r\ninterface IGLTFBinaryExtensionShader {\r\n    bufferView: string;\r\n}\r\n\r\ninterface IGLTFBinaryExtensionImage {\r\n    bufferView: string;\r\n    mimeType: string;\r\n    height: number;\r\n    width: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFBinaryExtension extends GLTFLoaderExtension {\r\n    private _bin: IDataBuffer;\r\n\r\n    public constructor() {\r\n        super(\"KHR_binary_glTF\");\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (gltfRuntime: IGLTFRuntime) => void): boolean {\r\n        const extensionsUsed = (<any>data.json).extensionsUsed;\r\n        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {\r\n            return false;\r\n        }\r\n\r\n        this._bin = data.bin;\r\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (id !== BinaryExtensionBufferName) {\r\n            return false;\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, (error) => onError(error.message));\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void): boolean {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n        if (!source.extensions || !(this.name in source.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        const sourceExt: IGLTFBinaryExtensionImage = source.extensions[this.name];\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[sourceExt.bufferView];\r\n        const buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n        onSuccess(buffer);\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void): boolean {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n        if (!shader.extensions || !(this.name in shader.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        const binaryExtensionShader: IGLTFBinaryExtensionShader = shader.extensions[this.name];\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];\r\n        const shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n\r\n        setTimeout(() => {\r\n            const shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);\r\n            onSuccess(shaderString);\r\n        });\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFBinaryExtension());\r\n","import { GLTFLoaderExtension, GLTFLoaderBase, GLTFLoader } from \"./glTFLoader\";\r\n\r\nimport type { IGLTFRuntime, IGLTFMaterial } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\n\r\ninterface IGLTFMaterialsCommonExtensionValues {\r\n    ambient?: number[] | string;\r\n    diffuse?: number[] | string;\r\n    emission?: number[] | string;\r\n    specular?: number[] | string;\r\n    shininess?: number;\r\n    transparency?: number;\r\n}\r\n\r\ninterface IGLTFMaterialsCommonExtension {\r\n    technique: string;\r\n    transparent?: number;\r\n    doubleSided?: boolean;\r\n    values: IGLTFMaterialsCommonExtensionValues;\r\n}\r\n\r\ninterface IGLTFRuntimeCommonExtension {\r\n    lights: { [key: string]: IGLTFLightCommonExtension };\r\n}\r\n\r\ninterface IGLTFLightCommonExtension {\r\n    name: string;\r\n    type: string;\r\n\r\n    ambient?: IGLTFAmbientLightCommonExtension;\r\n    point?: IGLTFPointLightCommonExtension;\r\n    directional?: IGLTFDirectionalLightCommonExtension;\r\n    spot?: IGLTFSpotLightCommonExtension;\r\n}\r\n\r\ninterface IGLTFPointLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\ninterface IGLTFAmbientLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFDirectionalLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFSpotLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    fallOffAngle: number;\r\n    fallOffExponent: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\r\n    constructor() {\r\n        super(\"KHR_materials_common\");\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime): boolean {\r\n        if (!gltfRuntime.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFRuntimeCommonExtension = gltfRuntime.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        // Create lights\r\n        const lights = extension.lights;\r\n        if (lights) {\r\n            for (const thing in lights) {\r\n                const light: IGLTFLightCommonExtension = lights[thing];\r\n\r\n                switch (light.type) {\r\n                    case \"ambient\": {\r\n                        const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\r\n                        const ambient = light.ambient;\r\n                        if (ambient) {\r\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"point\": {\r\n                        const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\r\n                        const point = light.point;\r\n                        if (point) {\r\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"directional\": {\r\n                        const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\r\n                        const directional = light.directional;\r\n                        if (directional) {\r\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"spot\": {\r\n                        const spot = light.spot;\r\n                        if (spot) {\r\n                            const spotLight = new SpotLight(\r\n                                light.name,\r\n                                new Vector3(0, 10, 0),\r\n                                new Vector3(0, -1, 0),\r\n                                spot.fallOffAngle || Math.PI,\r\n                                spot.fallOffExponent || 0.0,\r\n                                gltfRuntime.scene\r\n                            );\r\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        Tools.Warn('GLTF Material Common extension: light type \"' + light.type + \" not supported\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material || !material.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFMaterialsCommonExtension = material.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (extension.technique === \"CONSTANT\") {\r\n            standardMaterial.disableLighting = true;\r\n        }\r\n\r\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\r\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\r\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\r\n\r\n        // Ambient\r\n        if (typeof extension.values.ambient === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\r\n        } else {\r\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\r\n        }\r\n\r\n        // Diffuse\r\n        if (typeof extension.values.diffuse === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\r\n        } else {\r\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\r\n        }\r\n\r\n        // Emission\r\n        if (typeof extension.values.emission === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\r\n        } else {\r\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\r\n        }\r\n\r\n        // Specular\r\n        if (typeof extension.values.specular === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\r\n        } else {\r\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _loadTexture(gltfRuntime: IGLTFRuntime, id: string, material: StandardMaterial, propertyPath: string, onError: (message: string) => void): void {\r\n        // Create buffer from texture url\r\n        GLTFLoaderBase.LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                // Create texture from buffer\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => ((<any>material)[propertyPath] = texture));\r\n            },\r\n            onError\r\n        );\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as GLTF1 from \"loaders/glTF/1.0/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst GlobalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof GlobalObject !== \"undefined\") {\r\n    (<any>GlobalObject).BABYLON = (<any>GlobalObject).BABYLON || {};\r\n    (<any>GlobalObject).BABYLON.GLTF1 = (<any>GlobalObject).BABYLON.GLTF1 || {};\r\n    for (const key in GLTF1) {\r\n        (<any>GlobalObject).BABYLON.GLTF1[key] = (<any>GLTF1)[key];\r\n    }\r\n}\r\n\r\nexport { GLTF1 };\r\n","// eslint-disable-next-line import/export\r\nimport * as loaders from \"@lts/loaders/legacy/legacy-glTF1FileLoader\";\r\nexport { loaders };\r\nexport default loaders;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__597__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","extendStatics","b","setPrototypeOf","__proto__","Array","p","__extends","TypeError","String","__","constructor","create","SuppressedError","ValidateAsync","data","rootUrl","fileName","getExternalResource","options","externalResourceFunction","uri","ArrayBuffer","isView","GLTFValidator","validateBytes","validateString","WorkerFunc","pendingExternalResources","onmessage","message","id","importScripts","url","Promise","resolve","reject","index","length","push","postMessage","then","reason","GLTFLoaderCoordinateSystemMode","GLTFLoaderAnimationStartMode","GLTFLoaderState","Worker","workerContent","workerBlobUrl","URL","createObjectURL","Blob","type","worker","onError","error","removeEventListener","onMessage","buffer","terminate","addEventListener","Tools","GetBabylonScriptURL","Configuration","slicedData","slice","_LoadScriptPromise","LoadBabylonScriptAsync","_DefaultCdnUrl","GLTFMagicBase64Encoded","GLTFFileLoaderMetadata","isBinary","mimeType","readAsync","arrayBuffer","byteOffset","byteLength","Uint8Array","onParsedObservable","Observable","onMeshLoadedObservable","onSkinLoadedObservable","onTextureLoadedObservable","onMaterialLoadedObservable","onCameraLoadedObservable","onCompleteObservable","onErrorObservable","onDisposeObservable","onExtensionLoadedObservable","onValidatedObservable","_loader","_state","_requests","name","extensions","onLoaderStateChangedObservable","_logIndentLevel","_loggingEnabled","_log","_logDisabled","_capturePerformanceCounters","_startPerformanceCounter","_startPerformanceCounterDisabled","_endPerformanceCounter","_endPerformanceCounterDisabled","copyFrom","callback","_onParsedObserver","remove","add","_onMeshLoadedObserver","_onSkinLoadedObserver","node","skinnedNode","_onTextureLoadedObserver","_onMaterialLoadedObserver","_onCameraLoadedObserver","_onCompleteObserver","_onErrorObserver","_onDisposeObserver","_onExtensionLoadedObserver","_logEnabled","_startPerformanceCounterEnabled","_endPerformanceCounterEnabled","_onValidatedObserver","dispose","abort","_progressCallback","preprocessUrlAsync","clear","notifyObservers","loadFile","scene","fileOrUrl","onSuccess","onProgress","useArrayBuffer","_loadBinary","GetFilename","useRangeRequests","validate","Logger","Warn","dataBuffer","_loadFile","webRequest","setRequestHeader","_unpackBinaryAsync","DataReader","loaderData","_validate","json","_parseJson","arrayBufferView","RangeError","readViewAsync","importMeshAsync","meshesNames","_getLoader","loadAsync","loadAssetContainerAsync","container","AssetContainer","materials","material","textures","texture","cameras","camera","morphTargetManagers","mesh","morphTargetManager","result","apply","geometries","meshes","particleSystems","skeletons","animationGroups","lights","transformNodes","canDirectLoad","indexOf","startsWith","directLoad","DecodeBase64UrlToBinary","createPlugin","GLTFFileLoader","whenCompleteAsync","addOnce","_setState","state","onOpened","request","event","_onProgress","_lengthComputable","_total","_loaded","lengthComputable","loaded","total","GLTFValidation","_loadFileAsync","asset","version","minVersion","generator","_parseVersion","Error","_compareVersion","major","minor","createLoader","_CreateGLTF1Loader","_CreateGLTF2Loader","parsed","JSON","parse","dataReader","magic","readUint32","RuntimeError","ErrorCodes","GLTFLoaderUnexpectedMagicError","loggingEnabled","unpacked","_unpackBinaryV1Async","_unpackBinaryV2Async","contentLength","contentFormat","bodyLength","readString","bin","ChunkFormat","chunkLength","skipBytes","match","parseInt","a","_logOpen","_logClose","spaces","_logSpaces","substring","Log","counterName","StartPerformanceCounter","EndPerformanceCounter","IncrementalLoading","HomogeneousCoordinates","alwaysComputeBoundingBox","alwaysComputeSkeletonRootNode","animationStartMode","FIRST","compileMaterials","compileShadowGenerators","coordinateSystemMode","AUTO","createInstances","extensionOptions","loadAllMaterials","loadMorphTargets","loadNodeAnimations","loadOnlyMaterials","loadSkins","skipMaterials","targetFps","transparencyAsCoverage","useClipPlane","useGltfTextureNames","useSRGBBuffers","capturePerformanceCounters","customRootNode","onCameraLoaded","onMaterialLoaded","onMeshLoaded","onParsed","onSkinLoaded","onTextureLoaded","onValidated","RegisterSceneLoaderPlugin","EComponentType","EShaderType","EParameterType","ETextureWrapMode","ETextureFilterType","ETextureFormat","ECullingType","EBlendingFunction","GlobalObject","BABYLON","ETokenType","SetMatrix","source","parameter","uniformName","shaderMaterial","mat","semantic","getWorldMatrix","getProjectionMatrix","getViewMatrix","Matrix","Transpose","multiply","invert","getTransformMatrix","FLOAT_MAT2","setMatrix2x2","GetAsMatrix2x2","FLOAT_MAT3","setMatrix3x3","GetAsMatrix3x3","FLOAT_MAT4","setMatrix","SetUniform","uniform","FLOAT","setFloat","FLOAT_VEC2","setVector2","Vector2","FromArray","FLOAT_VEC3","setVector3","Vector3","FLOAT_VEC4","setVector4","Vector4","GetWrapMode","mode","CLAMP_TO_EDGE","Texture","CLAMP_ADDRESSMODE","MIRRORED_REPEAT","MIRROR_ADDRESSMODE","REPEAT","WRAP_ADDRESSMODE","GetByteStrideFromType","accessor","GetTextureFilterMode","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","TRILINEAR_SAMPLINGMODE","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_SAMPLINGMODE","BILINEAR_SAMPLINGMODE","GetBufferFromBufferView","gltfRuntime","bufferView","componentType","loadedBufferView","loadedBufferViews","BYTE","Int8Array","UNSIGNED_BYTE","SHORT","Int16Array","UNSIGNED_SHORT","Uint16Array","Float32Array","GetBufferFromAccessor","bufferViews","count","GLTFUtils","DecodeBufferToText","view","i","fromCharCode","GetDefaultMaterial","_DefaultMaterial","Effect","ShadersStore","join","attributes","uniforms","samplers","needAlphaBlending","ShaderMaterial","vertex","fragment","setColor4","Color4","toParse","_pos","currentToken","UNKNOWN","currentIdentifier","currentString","isLetterOrDigitPattern","_toParse","_maxPos","getNextToken","isEnd","END_OF_INPUT","read","test","IDENTIFIER","peek","forward","glTFTransforms","BabylonTransforms","glTFAnimationPaths","BabylonAnimationPaths","ParseObject","parsedObjects","runtimeProperty","object","parsedObject","NormalizeUVs","GetAttribute","attributeParameter","channel","Number","split","ConfigureBoneTransformation","translation","rotation","scale","Quaternion","position","Compose","matrix","GetParentBone","skins","jointName","newSkeleton","bones","nodes","nde","children","child","bone","Bone","GetNodeToRoot","nodesToRoot","nodeToRoot","j","GetJointNode","NodeIsInJoints","jointNames","ImportMesh","newMesh","_blockEntityCollection","assetContainer","Mesh","_parentContainer","babylonNode","subMaterials","vertexData","verticesStarts","verticesCounts","indexStarts","indexCounts","meshIndex","meshId","primitives","tempVertexData","VertexData","primitive","accessors","normals","set","positions","uvKind","VertexBuffer","UVKind","uvs","matricesIndices","matricesWeights","colors","indices","Int32Array","merge","getMaterialById","MultiMaterial","StandardMaterial","Geometry","computeWorldMatrix","subMeshes","SubMesh","AddToMesh","ConfigureNode","newNode","scaling","rotationQuaternion","ImportNode","lastNode","importOnlyMeshes","skin","importMeshesNames","skeleton","getLastSkeletonById","Skeleton","babylonSkeleton","nodesToRootToAdd","k","_parent","GetNodesToRoot","jointNode","existingBone","getBoneById","foundBone","parentBone","joint","prepare","ImportSkeleton","light","orthoCamera","FreeCamera","Zero","Camera","ORTHOGRAPHIC_CAMERA","attachControl","perspectiveCamera","persCamera","aspectRatio","getEngine","getRenderWidth","getRenderHeight","znear","zfar","maxZ","minZ","ambienLight","hemiLight","HemisphericLight","color","diffuse","Color3","directionalLight","dirLight","DirectionalLight","pointLight","ptLight","PointLight","spotLight","spLight","SpotLight","fallOfAngle","angle","fallOffExponent","exponent","dummy","decompose","ConfigureNodeFromMatrix","updateCache","TraverseNodes","parent","meshIncluded","PostLoad","currentScene","thing","scenes","anim","animations","animation","channels","lastAnimation","sampler","inputData","outputData","parameters","input","output","bufferInput","bufferOutput","targetId","target","targetNode","getNodeById","getNodeByName","isBone","targetPath","path","targetPathIndex","animationType","Animation","ANIMATIONTYPE_MATRIX","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","babylonAnimation","keys","arrayOffset","modifyKey","getKeys","ANIMATIONLOOPMODE_CYCLE","getBaseMatrix","frame","setKeys","stopAnimation","beginAnimation","LoadAnimations","MAX_VALUE","ParseShaderUniforms","tokenizer","technique","unTreatedUniforms","unif","uniformParameter","transformIndex","ImportMaterials","GLTFLoaderExtension","LoadMaterialAsync","CreateRuntime","parsedData","buffers","images","shaders","programs","techniques","extensionsUsed","buffersCount","shaderscount","loadedBufferCount","loadedShaderCount","dummyNodes","parsedBuffers","buf","parsedBuffer","ParseBuffers","parsedShaders","sha","parsedShader","ParseShaders","LoadBufferAsync","IsBase64","setTimeout","DecodeBase64","LoadFile","status","statusText","LoadTextureBufferAsync","babylonTexture","CreateTextureAsync","createMipMaps","minFilter","NEAREST_MIPMAP_LINEAR","samplingMode","blob","blobURL","revokeBlobURL","revokeObjectURL","newTexture","wrapS","wrapU","wrapT","wrapV","LoadShaderStringAsync","shader","shaderString","atob","defaultMaterial","diffuseColor","sideOrientation","Material","CounterClockWiseSideOrientation","program","states","vertexShader","pixelShader","fragmentShader","newVertexShader","newPixelShader","vertexTokenizer","Tokenizer","pixelTokenizer","SAMPLER_2D","attr","attribute","foundAttribute","shaderPath","enable","effect","OnShaderCompileError","onCompiled","_","materialValues","values","techniqueUniforms","onLoadTexture","setTexture","LoadTextureAsync","PrepareShaderMaterialUniforms","onBind","getEffect","OnBindShaderMaterial","OnShaderCompileSuccess","functions","cullFace","BACK","backFaceCulling","blendFunc","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","alphaMode","Constants","ALPHA_COMBINE","ZERO","ALPHA_ONEONE","ALPHA_ADD","ONE_MINUS_SRC_COLOR","ALPHA_SUBTRACT","DST_COLOR","ALPHA_MULTIPLY","ALPHA_MAXIMIZED","RegisterExtension","extension","GLTFLoader","Extensions","_importMeshAsync","useRightHandedSystem","LoadRuntimeAsync","_createNodes","AbstractMesh","skl","_loadBuffersAsync","_loadShadersAsync","spriteManagers","_loadAsync","LoadRuntimeExtensionsAsync","thisArg","_arguments","body","f","y","t","label","sent","trys","ops","Iterator","next","verb","iterator","n","v","op","done","pop","step","P","fulfilled","rejected","onload","hasShaders","processShader","VERTEX","bind","onLoad","hasBuffers","processBuffer","_name","loadRuntimeAsync","loadRuntimeExtensionsAsync","loadBufferAsync","loadTextureBufferAsync","createTextureAsync","loadShaderStringAsync","loadMaterialAsync","_ApplyExtensions","loaderExtension","GLTFLoaderBase","_LoadTextureBufferAsync","_CreateTextureAsync","func","defaultFunc","extensionName","_bin","sourceExt","binaryExtensionShader","shaderBytes","GLTFBinaryExtension","ambientLight","ambient","point","directional","spot","fallOffAngle","Math","PI","standardMaterial","disableLighting","doubleSided","alpha","transparency","specularPower","shininess","_loadTexture","ambientColor","emission","emissiveColor","specular","specularColor","propertyPath","GLTFMaterialsCommonExtension","GLTF1"],"sourceRoot":""}